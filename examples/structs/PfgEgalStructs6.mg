Definition pack_c_b_u_u_r_r : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set := fun X C f i j R T => (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T).

Theorem pack_c_b_u_u_r_r_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> X = S 0.
let S X C f i j R T. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_u_r_r_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, X = pack_c_b_u_u_r_r X C f i j R T 0.
let X C f i j R T. apply pack_c_b_u_u_r_r_0_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i j R T. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_u_r_r_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_u_r_r X C f i j R T 1) U.
let X C f i j R T. apply pack_c_b_u_u_r_r_1_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_r_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, f x y = decode_b (pack_c_b_u_u_r_r X C f i j R T 2) x y.
let X C f i j R T. apply pack_c_b_u_u_r_r_2_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i j R T. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_u_r_r_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x :e X, i x = decode_u (pack_c_b_u_u_r_r X C f i j R T 3) x.
let X C f i j R T. apply pack_c_b_u_u_r_r_3_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> forall x :e X, j x = decode_u (S 4) x.
let S X C f i j R T. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_c_b_u_u_r_r_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x :e X, j x = decode_u (pack_c_b_u_u_r_r X C f i j R T 4) x.
let X C f i j R T. apply pack_c_b_u_u_r_r_4_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X C f i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_r_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, R x y = decode_r (pack_c_b_u_u_r_r X C f i j R T 5) x y.
let X C f i j R T. apply pack_c_b_u_u_r_r_5_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_c_b_u_u_r_r X C f i j R T -> forall x y :e X, T x y = decode_r (S 6) x y.
let S X C f i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 6) x y.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_r_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, T x y = decode_r (pack_c_b_u_u_r_r X C f i j R T 6) x y.
let X C f i j R T. apply pack_c_b_u_u_r_r_6_eq (pack_c_b_u_u_r_r X C f i j R T) X C f i j R T. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_r_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, pack_c_b_u_u_r_r X C f i j R T = pack_c_b_u_u_r_r X' C' f' i' j' R' T' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y).
let X X' C C' f f' i i' j j' R R' T T'. assume H1.
claim L0: X' = pack_c_b_u_u_r_r X C f i j R T 0.
{ exact pack_c_b_u_u_r_r_0_eq (pack_c_b_u_u_r_r X C f i j R T) X' C' f' i' j' R' T' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_u_r_r_0_eq2 X C f i j R T. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_u_r_r_1_eq2 X C f i j R T U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_r_1_eq2 X' C' f' i' j' R' T' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_u_r_r_2_eq2 X C f i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_r_2_eq2 X' C' f' i' j' R' T' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_u_r_r_3_eq2 X C f i j R T x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_r_3_eq2 X' C' f' i' j' R' T' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_c_b_u_u_r_r_4_eq2 X C f i j R T x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_r_4_eq2 X' C' f' i' j' R' T' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_u_r_r_5_eq2 X C f i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_r_5_eq2 X' C' f' i' j' R' T' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_b_u_u_r_r_6_eq2 X C f i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_r_6_eq2 X' C' f' i' j' R' T' x Lx y Ly.
Qed.

Theorem pack_c_b_u_u_r_r_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_c_b_u_u_r_r X C f i j R T = pack_c_b_u_u_r_r X C' f' i' j' R' T'.
let X C C' f f' i i' j j' R R' T T'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_r X T) = (X,encode_c X C',encode_b X f',encode_u X i',encode_u X j',encode_r X R',encode_r X T').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_b_u_u_r_r : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, q (pack_c_b_u_u_r_r X C f i j R T)) -> q S.

Theorem pack_struct_c_b_u_u_r_r_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, struct_c_b_u_u_r_r (pack_c_b_u_u_r_r X C f i j R T).
let X C f. assume Hf. let i. assume Hi. let j. assume Hj. let R T q. assume Hq.
exact Hq X C f Hf i Hi j Hj R T.
Qed.

Theorem pack_struct_c_b_u_u_r_r_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_c_b_u_u_r_r (pack_c_b_u_u_r_r X C f i j R T) -> forall x y :e X, f x y :e X.
let X C f i j R T. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_r X C f i j R T -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_c_b_u_u_r_r X' C' f' i' j' R' T' = pack_c_b_u_u_r_r X C f i j R T.
  apply pack_c_b_u_u_r_r_inj X' X C' C f' f i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_r_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_c_b_u_u_r_r (pack_c_b_u_u_r_r X C f i j R T) -> forall x :e X, i x :e X.
let X C f i j R T. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_r X C f i j R T -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_c_b_u_u_r_r X' C' f' i' j' R' T' = pack_c_b_u_u_r_r X C f i j R T.
  apply pack_c_b_u_u_r_r_inj X' X C' C f' f i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_r_E4: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_c_b_u_u_r_r (pack_c_b_u_u_r_r X C f i j R T) -> forall x :e X, j x :e X.
let X C f i j R T. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_r X C f i j R T -> forall x :e X, j x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_c_b_u_u_r_r X' C' f' i' j' R' T' = pack_c_b_u_u_r_r X C f i j R T.
  apply pack_c_b_u_u_r_r_inj X' X C' C f' f i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_c_b_u_u_r_r_eta: forall S, struct_c_b_u_u_r_r S -> S = pack_c_b_u_u_r_r (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_r (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_r (z 5)) (decode_r (z 6))).
let X. let C. let f. assume _. let i. assume _. let j. assume _. let R. let T.
prove pack_c_b_u_u_r_r X C f i j R T = pack_c_b_u_u_r_r (pack_c_b_u_u_r_r X C f i j R T 0) (decode_c (pack_c_b_u_u_r_r X C f i j R T 1)) (decode_b (pack_c_b_u_u_r_r X C f i j R T 2)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 3)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 4)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 5)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 6)).
rewrite <- pack_c_b_u_u_r_r_0_eq2 X C f i j R T.
apply pack_c_b_u_u_r_r_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_u_r_r_1_eq2 X C f i j R T U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_r_2_eq2 X C f i j R T.
- exact pack_c_b_u_u_r_r_3_eq2 X C f i j R T.
- exact pack_c_b_u_u_r_r_4_eq2 X C f i j R T.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_u_r_r_5_eq2 X C f i j R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_u_r_r_6_eq2 X C f i j R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_r_r_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).

Theorem unpack_c_b_u_u_r_r_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' f' i' j' R' T' = Phi X C f i j R T)
  ->
  unpack_c_b_u_u_r_r_i (pack_c_b_u_u_r_r X C f i j R T) Phi = Phi X C f i j R T.
let Phi X C f i j R T.
assume HPhi.
prove Phi (pack_c_b_u_u_r_r X C f i j R T 0) (decode_c (pack_c_b_u_u_r_r X C f i j R T 1)) (decode_b (pack_c_b_u_u_r_r X C f i j R T 2)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 3)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 4)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 5)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 6)) = Phi X C f i j R T.
rewrite <- pack_c_b_u_u_r_r_0_eq2 X C f i j R T.
prove Phi X (decode_c (pack_c_b_u_u_r_r X C f i j R T 1)) (decode_b (pack_c_b_u_u_r_r X C f i j R T 2)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 3)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 4)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 5)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 6)) = Phi X C f i j R T.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_r_r X C f i j R T 1) U.
  rewrite <- pack_c_b_u_u_r_r_1_eq2 X C f i j R T U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_r_2_eq2 X C f i j R T.
- exact pack_c_b_u_u_r_r_3_eq2 X C f i j R T.
- exact pack_c_b_u_u_r_r_4_eq2 X C f i j R T.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_u_r_r X C f i j R T 5) x y.
  rewrite <- pack_c_b_u_u_r_r_5_eq2 X C f i j R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_u_u_r_r X C f i j R T 6) x y.
  rewrite <- pack_c_b_u_u_r_r_6_eq2 X C f i j R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_r_r_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).

Theorem unpack_c_b_u_u_r_r_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' f' i' j' R' T' = Phi X C f i j R T)
  ->
  unpack_c_b_u_u_r_r_o (pack_c_b_u_u_r_r X C f i j R T) Phi = Phi X C f i j R T.
let Phi X C f i j R T.
assume HPhi.
prove Phi (pack_c_b_u_u_r_r X C f i j R T 0) (decode_c (pack_c_b_u_u_r_r X C f i j R T 1)) (decode_b (pack_c_b_u_u_r_r X C f i j R T 2)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 3)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 4)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 5)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 6)) = Phi X C f i j R T.
rewrite <- pack_c_b_u_u_r_r_0_eq2 X C f i j R T.
prove Phi X (decode_c (pack_c_b_u_u_r_r X C f i j R T 1)) (decode_b (pack_c_b_u_u_r_r X C f i j R T 2)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 3)) (decode_u (pack_c_b_u_u_r_r X C f i j R T 4)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 5)) (decode_r (pack_c_b_u_u_r_r X C f i j R T 6)) = Phi X C f i j R T.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_r_r X C f i j R T 1) U.
  rewrite <- pack_c_b_u_u_r_r_1_eq2 X C f i j R T U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_r_2_eq2 X C f i j R T.
- exact pack_c_b_u_u_r_r_3_eq2 X C f i j R T.
- exact pack_c_b_u_u_r_r_4_eq2 X C f i j R T.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_u_r_r X C f i j R T 5) x y.
  rewrite <- pack_c_b_u_u_r_r_5_eq2 X C f i j R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_u_u_r_r X C f i j R T 6) x y.
  rewrite <- pack_c_b_u_u_r_r_6_eq2 X C f i j R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_c_b_u_u_r_p : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set := fun X C f i j R P => (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P).

Theorem pack_c_b_u_u_r_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> X = S 0.
let S X C f i j R P. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_u_r_p_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, X = pack_c_b_u_u_r_p X C f i j R P 0.
let X C f i j R P. apply pack_c_b_u_u_r_p_0_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i j R P. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_u_r_p_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_u_r_p X C f i j R P 1) U.
let X C f i j R P. apply pack_c_b_u_u_r_p_1_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i j R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_p_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_c_b_u_u_r_p X C f i j R P 2) x y.
let X C f i j R P. apply pack_c_b_u_u_r_p_2_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i j R P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_u_r_p_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, i x = decode_u (pack_c_b_u_u_r_p X C f i j R P 3) x.
let X C f i j R P. apply pack_c_b_u_u_r_p_3_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> forall x :e X, j x = decode_u (S 4) x.
let S X C f i j R P. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_c_b_u_u_r_p_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, j x = decode_u (pack_c_b_u_u_r_p X C f i j R P 4) x.
let X C f i j R P. apply pack_c_b_u_u_r_p_4_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X C f i j R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_p_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, R x y = decode_r (pack_c_b_u_u_r_p X C f i j R P 5) x y.
let X C f i j R P. apply pack_c_b_u_u_r_p_5_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_u_r_p X C f i j R P -> forall x :e X, P x = decode_p (S 6) x.
let S X C f i j R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_u_r_p_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, P x = decode_p (pack_c_b_u_u_r_p X C f i j R P 6) x.
let X C f i j R P. apply pack_c_b_u_u_r_p_6_eq (pack_c_b_u_u_r_p X C f i j R P) X C f i j R P. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_p_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, pack_c_b_u_u_r_p X C f i j R P = pack_c_b_u_u_r_p X' C' f' i' j' R' P' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x).
let X X' C C' f f' i i' j j' R R' P P'. assume H1.
claim L0: X' = pack_c_b_u_u_r_p X C f i j R P 0.
{ exact pack_c_b_u_u_r_p_0_eq (pack_c_b_u_u_r_p X C f i j R P) X' C' f' i' j' R' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_u_r_p_0_eq2 X C f i j R P. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_u_r_p_1_eq2 X C f i j R P U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_p_1_eq2 X' C' f' i' j' R' P' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_u_r_p_2_eq2 X C f i j R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_p_2_eq2 X' C' f' i' j' R' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_u_r_p_3_eq2 X C f i j R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_p_3_eq2 X' C' f' i' j' R' P' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_c_b_u_u_r_p_4_eq2 X C f i j R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_p_4_eq2 X' C' f' i' j' R' P' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_u_r_p_5_eq2 X C f i j R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_p_5_eq2 X' C' f' i' j' R' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_u_r_p_6_eq2 X C f i j R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_p_6_eq2 X' C' f' i' j' R' P' x Lx.
Qed.

Theorem pack_c_b_u_u_r_p_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_u_u_r_p X C f i j R P = pack_c_b_u_u_r_p X C' f' i' j' R' P'.
let X C C' f f' i i' j j' R R' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,encode_p X P) = (X,encode_c X C',encode_b X f',encode_u X i',encode_u X j',encode_r X R',encode_p X P').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_b_u_u_r_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, q (pack_c_b_u_u_r_p X C f i j R P)) -> q S.

Theorem pack_struct_c_b_u_u_r_p_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, struct_c_b_u_u_r_p (pack_c_b_u_u_r_p X C f i j R P).
let X C f. assume Hf. let i. assume Hi. let j. assume Hj. let R P q. assume Hq.
exact Hq X C f Hf i Hi j Hj R P.
Qed.

Theorem pack_struct_c_b_u_u_r_p_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_c_b_u_u_r_p (pack_c_b_u_u_r_p X C f i j R P) -> forall x y :e X, f x y :e X.
let X C f i j R P. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_p X C f i j R P -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_c_b_u_u_r_p X' C' f' i' j' R' P' = pack_c_b_u_u_r_p X C f i j R P.
  apply pack_c_b_u_u_r_p_inj X' X C' C f' f i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_p_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_c_b_u_u_r_p (pack_c_b_u_u_r_p X C f i j R P) -> forall x :e X, i x :e X.
let X C f i j R P. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_p X C f i j R P -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_c_b_u_u_r_p X' C' f' i' j' R' P' = pack_c_b_u_u_r_p X C f i j R P.
  apply pack_c_b_u_u_r_p_inj X' X C' C f' f i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_p_E4: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_c_b_u_u_r_p (pack_c_b_u_u_r_p X C f i j R P) -> forall x :e X, j x :e X.
let X C f i j R P. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_p X C f i j R P -> forall x :e X, j x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_c_b_u_u_r_p X' C' f' i' j' R' P' = pack_c_b_u_u_r_p X C f i j R P.
  apply pack_c_b_u_u_r_p_inj X' X C' C f' f i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_c_b_u_u_r_p_eta: forall S, struct_c_b_u_u_r_p S -> S = pack_c_b_u_u_r_p (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_p (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_r (z 5)) (decode_p (z 6))).
let X. let C. let f. assume _. let i. assume _. let j. assume _. let R. let P.
prove pack_c_b_u_u_r_p X C f i j R P = pack_c_b_u_u_r_p (pack_c_b_u_u_r_p X C f i j R P 0) (decode_c (pack_c_b_u_u_r_p X C f i j R P 1)) (decode_b (pack_c_b_u_u_r_p X C f i j R P 2)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 3)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 4)) (decode_r (pack_c_b_u_u_r_p X C f i j R P 5)) (decode_p (pack_c_b_u_u_r_p X C f i j R P 6)).
rewrite <- pack_c_b_u_u_r_p_0_eq2 X C f i j R P.
apply pack_c_b_u_u_r_p_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_u_r_p_1_eq2 X C f i j R P U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_p_2_eq2 X C f i j R P.
- exact pack_c_b_u_u_r_p_3_eq2 X C f i j R P.
- exact pack_c_b_u_u_r_p_4_eq2 X C f i j R P.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_u_r_p_5_eq2 X C f i j R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_u_r_p_6_eq2 X C f i j R P x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_r_p_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_u_r_p_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' j' R' P' = Phi X C f i j R P)
  ->
  unpack_c_b_u_u_r_p_i (pack_c_b_u_u_r_p X C f i j R P) Phi = Phi X C f i j R P.
let Phi X C f i j R P.
assume HPhi.
prove Phi (pack_c_b_u_u_r_p X C f i j R P 0) (decode_c (pack_c_b_u_u_r_p X C f i j R P 1)) (decode_b (pack_c_b_u_u_r_p X C f i j R P 2)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 3)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 4)) (decode_r (pack_c_b_u_u_r_p X C f i j R P 5)) (decode_p (pack_c_b_u_u_r_p X C f i j R P 6)) = Phi X C f i j R P.
rewrite <- pack_c_b_u_u_r_p_0_eq2 X C f i j R P.
prove Phi X (decode_c (pack_c_b_u_u_r_p X C f i j R P 1)) (decode_b (pack_c_b_u_u_r_p X C f i j R P 2)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 3)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 4)) (decode_r (pack_c_b_u_u_r_p X C f i j R P 5)) (decode_p (pack_c_b_u_u_r_p X C f i j R P 6)) = Phi X C f i j R P.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_r_p X C f i j R P 1) U.
  rewrite <- pack_c_b_u_u_r_p_1_eq2 X C f i j R P U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_p_2_eq2 X C f i j R P.
- exact pack_c_b_u_u_r_p_3_eq2 X C f i j R P.
- exact pack_c_b_u_u_r_p_4_eq2 X C f i j R P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_u_r_p X C f i j R P 5) x y.
  rewrite <- pack_c_b_u_u_r_p_5_eq2 X C f i j R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_u_r_p X C f i j R P 6) x.
  rewrite <- pack_c_b_u_u_r_p_6_eq2 X C f i j R P x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_r_p_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_u_r_p_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' j' R' P' = Phi X C f i j R P)
  ->
  unpack_c_b_u_u_r_p_o (pack_c_b_u_u_r_p X C f i j R P) Phi = Phi X C f i j R P.
let Phi X C f i j R P.
assume HPhi.
prove Phi (pack_c_b_u_u_r_p X C f i j R P 0) (decode_c (pack_c_b_u_u_r_p X C f i j R P 1)) (decode_b (pack_c_b_u_u_r_p X C f i j R P 2)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 3)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 4)) (decode_r (pack_c_b_u_u_r_p X C f i j R P 5)) (decode_p (pack_c_b_u_u_r_p X C f i j R P 6)) = Phi X C f i j R P.
rewrite <- pack_c_b_u_u_r_p_0_eq2 X C f i j R P.
prove Phi X (decode_c (pack_c_b_u_u_r_p X C f i j R P 1)) (decode_b (pack_c_b_u_u_r_p X C f i j R P 2)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 3)) (decode_u (pack_c_b_u_u_r_p X C f i j R P 4)) (decode_r (pack_c_b_u_u_r_p X C f i j R P 5)) (decode_p (pack_c_b_u_u_r_p X C f i j R P 6)) = Phi X C f i j R P.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_r_p X C f i j R P 1) U.
  rewrite <- pack_c_b_u_u_r_p_1_eq2 X C f i j R P U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_p_2_eq2 X C f i j R P.
- exact pack_c_b_u_u_r_p_3_eq2 X C f i j R P.
- exact pack_c_b_u_u_r_p_4_eq2 X C f i j R P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_u_r_p X C f i j R P 5) x y.
  rewrite <- pack_c_b_u_u_r_p_5_eq2 X C f i j R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_u_r_p X C f i j R P 6) x.
  rewrite <- pack_c_b_u_u_r_p_6_eq2 X C f i j R P x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_u_r_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set := fun X C f i j R c => (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c).

Theorem pack_c_b_u_u_r_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> X = S 0.
let S X C f i j R c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_u_r_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, X = pack_c_b_u_u_r_e X C f i j R c 0.
let X C f i j R c. apply pack_c_b_u_u_r_e_0_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i j R c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_u_r_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_u_r_e X C f i j R c 1) U.
let X C f i j R c. apply pack_c_b_u_u_r_e_1_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i j R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_u_u_r_e X C f i j R c 2) x y.
let X C f i j R c. apply pack_c_b_u_u_r_e_2_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i j R c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_u_r_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_b_u_u_r_e X C f i j R c 3) x.
let X C f i j R c. apply pack_c_b_u_u_r_e_3_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> forall x :e X, j x = decode_u (S 4) x.
let S X C f i j R c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_c_b_u_u_r_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x :e X, j x = decode_u (pack_c_b_u_u_r_e X C f i j R c 4) x.
let X C f i j R c. apply pack_c_b_u_u_r_e_4_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X C f i j R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_r_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_b_u_u_r_e X C f i j R c 5) x y.
let X C f i j R c. apply pack_c_b_u_u_r_e_5_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_c_b_u_u_r_e X C f i j R c -> c = S 6.
let S X C f i j R c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_u_r_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, c = pack_c_b_u_u_r_e X C f i j R c 6.
let X C f i j R c. apply pack_c_b_u_u_r_e_6_eq (pack_c_b_u_u_r_e X C f i j R c) X C f i j R c. reflexivity.
Qed.

Theorem pack_c_b_u_u_r_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall c c':set, pack_c_b_u_u_r_e X C f i j R c = pack_c_b_u_u_r_e X' C' f' i' j' R' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ c = c'.
let X X' C C' f f' i i' j j' R R' c c'. assume H1.
claim L0: X' = pack_c_b_u_u_r_e X C f i j R c 0.
{ exact pack_c_b_u_u_r_e_0_eq (pack_c_b_u_u_r_e X C f i j R c) X' C' f' i' j' R' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_u_r_e_0_eq2 X C f i j R c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_u_r_e_1_eq2 X C f i j R c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_e_1_eq2 X' C' f' i' j' R' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_u_r_e_2_eq2 X C f i j R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_e_2_eq2 X' C' f' i' j' R' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_u_r_e_3_eq2 X C f i j R c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_e_3_eq2 X' C' f' i' j' R' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_c_b_u_u_r_e_4_eq2 X C f i j R c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_e_4_eq2 X' C' f' i' j' R' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_u_r_e_5_eq2 X C f i j R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_e_5_eq2 X' C' f' i' j' R' c' x Lx y Ly.
- prove c = c'.
  rewrite pack_c_b_u_u_r_e_6_eq2 X C f i j R c.
  rewrite H1. symmetry.
  exact pack_c_b_u_u_r_e_6_eq2 X' C' f' i' j' R' c'.
Qed.

Theorem pack_c_b_u_u_r_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_c_b_u_u_r_e X C f i j R c = pack_c_b_u_u_r_e X C' f' i' j' R' c.
let X C C' f f' i i' j j' R R' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_r X R,c) = (X,encode_c X C',encode_b X f',encode_u X i',encode_u X j',encode_r X R',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_u_u_r_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> q (pack_c_b_u_u_r_e X C f i j R c)) -> q S.

Theorem pack_struct_c_b_u_u_r_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> struct_c_b_u_u_r_e (pack_c_b_u_u_r_e X C f i j R c).
let X C f. assume Hf. let i. assume Hi. let j. assume Hj. let R c. assume Hc. let q. assume Hq.
exact Hq X C f Hf i Hi j Hj R c Hc.
Qed.

Theorem pack_struct_c_b_u_u_r_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_c_b_u_u_r_e (pack_c_b_u_u_r_e X C f i j R c) -> forall x y :e X, f x y :e X.
let X C f i j R c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_e X C f i j R c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_r_e X' C' f' i' j' R' c' = pack_c_b_u_u_r_e X C f i j R c.
  apply pack_c_b_u_u_r_e_inj X' X C' C f' f i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_c_b_u_u_r_e (pack_c_b_u_u_r_e X C f i j R c) -> forall x :e X, i x :e X.
let X C f i j R c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_e X C f i j R c -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_r_e X' C' f' i' j' R' c' = pack_c_b_u_u_r_e X C f i j R c.
  apply pack_c_b_u_u_r_e_inj X' X C' C f' f i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_e_E4: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_c_b_u_u_r_e (pack_c_b_u_u_r_e X C f i j R c) -> forall x :e X, j x :e X.
let X C f i j R c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_e X C f i j R c -> forall x :e X, j x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_r_e X' C' f' i' j' R' c' = pack_c_b_u_u_r_e X C f i j R c.
  apply pack_c_b_u_u_r_e_inj X' X C' C f' f i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_r_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_c_b_u_u_r_e (pack_c_b_u_u_r_e X C f i j R c) -> c :e X.
let X C f i j R c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_e X C f i j R c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_r_e X' C' f' i' j' R' c' = pack_c_b_u_u_r_e X C f i j R c.
  apply pack_c_b_u_u_r_e_inj X' X C' C f' f i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_u_u_r_e_eta: forall S, struct_c_b_u_u_r_e S -> S = pack_c_b_u_u_r_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_u_r_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_r (z 5)) (z 6)).
let X. let C. let f. assume _. let i. assume _. let j. assume _. let R. let c. assume _.
prove pack_c_b_u_u_r_e X C f i j R c = pack_c_b_u_u_r_e (pack_c_b_u_u_r_e X C f i j R c 0) (decode_c (pack_c_b_u_u_r_e X C f i j R c 1)) (decode_b (pack_c_b_u_u_r_e X C f i j R c 2)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 3)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 4)) (decode_r (pack_c_b_u_u_r_e X C f i j R c 5)) (pack_c_b_u_u_r_e X C f i j R c 6).
rewrite <- pack_c_b_u_u_r_e_0_eq2 X C f i j R c.
rewrite <- pack_c_b_u_u_r_e_6_eq2 X C f i j R c.
apply pack_c_b_u_u_r_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_u_r_e_1_eq2 X C f i j R c U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_e_2_eq2 X C f i j R c.
- exact pack_c_b_u_u_r_e_3_eq2 X C f i j R c.
- exact pack_c_b_u_u_r_e_4_eq2 X C f i j R c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_u_r_e_5_eq2 X C f i j R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_r_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_c_b_u_u_r_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C' f' i' j' R' c = Phi X C f i j R c)
  ->
  unpack_c_b_u_u_r_e_i (pack_c_b_u_u_r_e X C f i j R c) Phi = Phi X C f i j R c.
let Phi X C f i j R c.
assume HPhi.
prove Phi (pack_c_b_u_u_r_e X C f i j R c 0) (decode_c (pack_c_b_u_u_r_e X C f i j R c 1)) (decode_b (pack_c_b_u_u_r_e X C f i j R c 2)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 3)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 4)) (decode_r (pack_c_b_u_u_r_e X C f i j R c 5)) (pack_c_b_u_u_r_e X C f i j R c 6) = Phi X C f i j R c.
rewrite <- pack_c_b_u_u_r_e_0_eq2 X C f i j R c.
prove Phi X (decode_c (pack_c_b_u_u_r_e X C f i j R c 1)) (decode_b (pack_c_b_u_u_r_e X C f i j R c 2)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 3)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 4)) (decode_r (pack_c_b_u_u_r_e X C f i j R c 5)) (pack_c_b_u_u_r_e X C f i j R c 6) = Phi X C f i j R c.
rewrite <- pack_c_b_u_u_r_e_6_eq2 X C f i j R c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_r_e X C f i j R c 1) U.
  rewrite <- pack_c_b_u_u_r_e_1_eq2 X C f i j R c U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_e_2_eq2 X C f i j R c.
- exact pack_c_b_u_u_r_e_3_eq2 X C f i j R c.
- exact pack_c_b_u_u_r_e_4_eq2 X C f i j R c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_u_r_e X C f i j R c 5) x y.
  rewrite <- pack_c_b_u_u_r_e_5_eq2 X C f i j R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_r_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_c_b_u_u_r_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C' f' i' j' R' c = Phi X C f i j R c)
  ->
  unpack_c_b_u_u_r_e_o (pack_c_b_u_u_r_e X C f i j R c) Phi = Phi X C f i j R c.
let Phi X C f i j R c.
assume HPhi.
prove Phi (pack_c_b_u_u_r_e X C f i j R c 0) (decode_c (pack_c_b_u_u_r_e X C f i j R c 1)) (decode_b (pack_c_b_u_u_r_e X C f i j R c 2)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 3)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 4)) (decode_r (pack_c_b_u_u_r_e X C f i j R c 5)) (pack_c_b_u_u_r_e X C f i j R c 6) = Phi X C f i j R c.
rewrite <- pack_c_b_u_u_r_e_0_eq2 X C f i j R c.
prove Phi X (decode_c (pack_c_b_u_u_r_e X C f i j R c 1)) (decode_b (pack_c_b_u_u_r_e X C f i j R c 2)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 3)) (decode_u (pack_c_b_u_u_r_e X C f i j R c 4)) (decode_r (pack_c_b_u_u_r_e X C f i j R c 5)) (pack_c_b_u_u_r_e X C f i j R c 6) = Phi X C f i j R c.
rewrite <- pack_c_b_u_u_r_e_6_eq2 X C f i j R c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_r_e X C f i j R c 1) U.
  rewrite <- pack_c_b_u_u_r_e_1_eq2 X C f i j R c U HU.
  apply iff_refl.
- exact pack_c_b_u_u_r_e_2_eq2 X C f i j R c.
- exact pack_c_b_u_u_r_e_3_eq2 X C f i j R c.
- exact pack_c_b_u_u_r_e_4_eq2 X C f i j R c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_u_r_e X C f i j R c 5) x y.
  rewrite <- pack_c_b_u_u_r_e_5_eq2 X C f i j R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_c_b_u_u_p_p : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set := fun X C f i j P Q => (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q).

Theorem pack_c_b_u_u_p_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> X = S 0.
let S X C f i j P Q. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_u_p_p_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, X = pack_c_b_u_u_p_p X C f i j P Q 0.
let X C f i j P Q. apply pack_c_b_u_u_p_p_0_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i j P Q. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_u_p_p_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_u_p_p X C f i j P Q 1) U.
let X C f i j P Q. apply pack_c_b_u_u_p_p_1_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i j P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_p_p_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_c_b_u_u_p_p X C f i j P Q 2) x y.
let X C f i j P Q. apply pack_c_b_u_u_p_p_2_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_u_p_p_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_c_b_u_u_p_p X C f i j P Q 3) x.
let X C f i j P Q. apply pack_c_b_u_u_p_p_3_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> forall x :e X, j x = decode_u (S 4) x.
let S X C f i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_c_b_u_u_p_p_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, j x = decode_u (pack_c_b_u_u_p_p X C f i j P Q 4) x.
let X C f i j P Q. apply pack_c_b_u_u_p_p_4_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X C f i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_u_p_p_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_c_b_u_u_p_p X C f i j P Q 5) x.
let X C f i j P Q. apply pack_c_b_u_u_p_p_5_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_u_p_p X C f i j P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X C f i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_b_u_u_p_p_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_c_b_u_u_p_p X C f i j P Q 6) x.
let X C f i j P Q. apply pack_c_b_u_u_p_p_6_eq (pack_c_b_u_u_p_p X C f i j P Q) X C f i j P Q. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_p_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, pack_c_b_u_u_p_p X C f i j P Q = pack_c_b_u_u_p_p X' C' f' i' j' P' Q' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' C C' f f' i i' j j' P P' Q Q'. assume H1.
claim L0: X' = pack_c_b_u_u_p_p X C f i j P Q 0.
{ exact pack_c_b_u_u_p_p_0_eq (pack_c_b_u_u_p_p X C f i j P Q) X' C' f' i' j' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_u_p_p_0_eq2 X C f i j P Q. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_u_p_p_1_eq2 X C f i j P Q U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_p_1_eq2 X' C' f' i' j' P' Q' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_u_p_p_2_eq2 X C f i j P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_p_2_eq2 X' C' f' i' j' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_u_p_p_3_eq2 X C f i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_p_3_eq2 X' C' f' i' j' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_c_b_u_u_p_p_4_eq2 X C f i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_p_4_eq2 X' C' f' i' j' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_u_p_p_5_eq2 X C f i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_p_5_eq2 X' C' f' i' j' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_b_u_u_p_p_6_eq2 X C f i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_p_6_eq2 X' C' f' i' j' P' Q' x Lx.
Qed.

Theorem pack_c_b_u_u_p_p_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_b_u_u_p_p X C f i j P Q = pack_c_b_u_u_p_p X C' f' i' j' P' Q'.
let X C C' f f' i i' j j' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) = (X,encode_c X C',encode_b X f',encode_u X i',encode_u X j',encode_p X P',encode_p X Q').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_b_u_u_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall Q:set -> prop, q (pack_c_b_u_u_p_p X C f i j P Q)) -> q S.

Theorem pack_struct_c_b_u_u_p_p_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_u_p_p (pack_c_b_u_u_p_p X C f i j P Q).
let X C f. assume Hf. let i. assume Hi. let j. assume Hj. let P Q q. assume Hq.
exact Hq X C f Hf i Hi j Hj P Q.
Qed.

Theorem pack_struct_c_b_u_u_p_p_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_u_p_p (pack_c_b_u_u_p_p X C f i j P Q) -> forall x y :e X, f x y :e X.
let X C f i j P Q. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_p X C f i j P Q -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_c_b_u_u_p_p X' C' f' i' j' P' Q' = pack_c_b_u_u_p_p X C f i j P Q.
  apply pack_c_b_u_u_p_p_inj X' X C' C f' f i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_p_p_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_u_p_p (pack_c_b_u_u_p_p X C f i j P Q) -> forall x :e X, i x :e X.
let X C f i j P Q. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_p X C f i j P Q -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_c_b_u_u_p_p X' C' f' i' j' P' Q' = pack_c_b_u_u_p_p X C f i j P Q.
  apply pack_c_b_u_u_p_p_inj X' X C' C f' f i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_p_p_E4: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_u_p_p (pack_c_b_u_u_p_p X C f i j P Q) -> forall x :e X, j x :e X.
let X C f i j P Q. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_p X C f i j P Q -> forall x :e X, j x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_c_b_u_u_p_p X' C' f' i' j' P' Q' = pack_c_b_u_u_p_p X C f i j P Q.
  apply pack_c_b_u_u_p_p_inj X' X C' C f' f i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_c_b_u_u_p_p_eta: forall S, struct_c_b_u_u_p_p S -> S = pack_c_b_u_u_p_p (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_p (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let C. let f. assume _. let i. assume _. let j. assume _. let P. let Q.
prove pack_c_b_u_u_p_p X C f i j P Q = pack_c_b_u_u_p_p (pack_c_b_u_u_p_p X C f i j P Q 0) (decode_c (pack_c_b_u_u_p_p X C f i j P Q 1)) (decode_b (pack_c_b_u_u_p_p X C f i j P Q 2)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 3)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 4)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 5)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 6)).
rewrite <- pack_c_b_u_u_p_p_0_eq2 X C f i j P Q.
apply pack_c_b_u_u_p_p_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_u_p_p_1_eq2 X C f i j P Q U HU.
  apply iff_refl.
- exact pack_c_b_u_u_p_p_2_eq2 X C f i j P Q.
- exact pack_c_b_u_u_p_p_3_eq2 X C f i j P Q.
- exact pack_c_b_u_u_p_p_4_eq2 X C f i j P Q.
- let x. assume Hx.
  rewrite <- pack_c_b_u_u_p_p_5_eq2 X C f i j P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_u_p_p_6_eq2 X C f i j P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_p_p_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_u_p_p_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' i' j' P' Q' = Phi X C f i j P Q)
  ->
  unpack_c_b_u_u_p_p_i (pack_c_b_u_u_p_p X C f i j P Q) Phi = Phi X C f i j P Q.
let Phi X C f i j P Q.
assume HPhi.
prove Phi (pack_c_b_u_u_p_p X C f i j P Q 0) (decode_c (pack_c_b_u_u_p_p X C f i j P Q 1)) (decode_b (pack_c_b_u_u_p_p X C f i j P Q 2)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 3)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 4)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 5)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 6)) = Phi X C f i j P Q.
rewrite <- pack_c_b_u_u_p_p_0_eq2 X C f i j P Q.
prove Phi X (decode_c (pack_c_b_u_u_p_p X C f i j P Q 1)) (decode_b (pack_c_b_u_u_p_p X C f i j P Q 2)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 3)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 4)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 5)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 6)) = Phi X C f i j P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_p_p X C f i j P Q 1) U.
  rewrite <- pack_c_b_u_u_p_p_1_eq2 X C f i j P Q U HU.
  apply iff_refl.
- exact pack_c_b_u_u_p_p_2_eq2 X C f i j P Q.
- exact pack_c_b_u_u_p_p_3_eq2 X C f i j P Q.
- exact pack_c_b_u_u_p_p_4_eq2 X C f i j P Q.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_u_p_p X C f i j P Q 5) x.
  rewrite <- pack_c_b_u_u_p_p_5_eq2 X C f i j P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_u_u_p_p X C f i j P Q 6) x.
  rewrite <- pack_c_b_u_u_p_p_6_eq2 X C f i j P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_p_p_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_u_p_p_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' i' j' P' Q' = Phi X C f i j P Q)
  ->
  unpack_c_b_u_u_p_p_o (pack_c_b_u_u_p_p X C f i j P Q) Phi = Phi X C f i j P Q.
let Phi X C f i j P Q.
assume HPhi.
prove Phi (pack_c_b_u_u_p_p X C f i j P Q 0) (decode_c (pack_c_b_u_u_p_p X C f i j P Q 1)) (decode_b (pack_c_b_u_u_p_p X C f i j P Q 2)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 3)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 4)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 5)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 6)) = Phi X C f i j P Q.
rewrite <- pack_c_b_u_u_p_p_0_eq2 X C f i j P Q.
prove Phi X (decode_c (pack_c_b_u_u_p_p X C f i j P Q 1)) (decode_b (pack_c_b_u_u_p_p X C f i j P Q 2)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 3)) (decode_u (pack_c_b_u_u_p_p X C f i j P Q 4)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 5)) (decode_p (pack_c_b_u_u_p_p X C f i j P Q 6)) = Phi X C f i j P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_p_p X C f i j P Q 1) U.
  rewrite <- pack_c_b_u_u_p_p_1_eq2 X C f i j P Q U HU.
  apply iff_refl.
- exact pack_c_b_u_u_p_p_2_eq2 X C f i j P Q.
- exact pack_c_b_u_u_p_p_3_eq2 X C f i j P Q.
- exact pack_c_b_u_u_p_p_4_eq2 X C f i j P Q.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_u_p_p X C f i j P Q 5) x.
  rewrite <- pack_c_b_u_u_p_p_5_eq2 X C f i j P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_u_u_p_p X C f i j P Q 6) x.
  rewrite <- pack_c_b_u_u_p_p_6_eq2 X C f i j P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_u_p_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> set := fun X C f i j P c => (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c).

Theorem pack_c_b_u_u_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> X = S 0.
let S X C f i j P c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_u_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, X = pack_c_b_u_u_p_e X C f i j P c 0.
let X C f i j P c. apply pack_c_b_u_u_p_e_0_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i j P c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_u_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_u_p_e X C f i j P c 1) U.
let X C f i j P c. apply pack_c_b_u_u_p_e_1_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i j P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_u_u_p_e X C f i j P c 2) x y.
let X C f i j P c. apply pack_c_b_u_u_p_e_2_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i j P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_u_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_b_u_u_p_e X C f i j P c 3) x.
let X C f i j P c. apply pack_c_b_u_u_p_e_3_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> forall x :e X, j x = decode_u (S 4) x.
let S X C f i j P c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_c_b_u_u_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x :e X, j x = decode_u (pack_c_b_u_u_p_e X C f i j P c 4) x.
let X C f i j P c. apply pack_c_b_u_u_p_e_4_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> forall x :e X, P x = decode_p (S 5) x.
let S X C f i j P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_u_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_b_u_u_p_e X C f i j P c 5) x.
let X C f i j P c. apply pack_c_b_u_u_p_e_5_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_c_b_u_u_p_e X C f i j P c -> c = S 6.
let S X C f i j P c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_u_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, c = pack_c_b_u_u_p_e X C f i j P c 6.
let X C f i j P c. apply pack_c_b_u_u_p_e_6_eq (pack_c_b_u_u_p_e X C f i j P c) X C f i j P c. reflexivity.
Qed.

Theorem pack_c_b_u_u_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall c c':set, pack_c_b_u_u_p_e X C f i j P c = pack_c_b_u_u_p_e X' C' f' i' j' P' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' C C' f f' i i' j j' P P' c c'. assume H1.
claim L0: X' = pack_c_b_u_u_p_e X C f i j P c 0.
{ exact pack_c_b_u_u_p_e_0_eq (pack_c_b_u_u_p_e X C f i j P c) X' C' f' i' j' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_u_p_e_0_eq2 X C f i j P c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_u_p_e_1_eq2 X C f i j P c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_e_1_eq2 X' C' f' i' j' P' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_u_p_e_2_eq2 X C f i j P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_e_2_eq2 X' C' f' i' j' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_u_p_e_3_eq2 X C f i j P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_e_3_eq2 X' C' f' i' j' P' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_c_b_u_u_p_e_4_eq2 X C f i j P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_e_4_eq2 X' C' f' i' j' P' c' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_u_p_e_5_eq2 X C f i j P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_e_5_eq2 X' C' f' i' j' P' c' x Lx.
- prove c = c'.
  rewrite pack_c_b_u_u_p_e_6_eq2 X C f i j P c.
  rewrite H1. symmetry.
  exact pack_c_b_u_u_p_e_6_eq2 X' C' f' i' j' P' c'.
Qed.

Theorem pack_c_b_u_u_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_u_u_p_e X C f i j P c = pack_c_b_u_u_p_e X C' f' i' j' P' c.
let X C C' f f' i i' j j' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,encode_p X P,c) = (X,encode_c X C',encode_b X f',encode_u X i',encode_u X j',encode_p X P',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_u_u_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall c:set, c :e X -> q (pack_c_b_u_u_p_e X C f i j P c)) -> q S.

Theorem pack_struct_c_b_u_u_p_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall c:set, c :e X -> struct_c_b_u_u_p_e (pack_c_b_u_u_p_e X C f i j P c).
let X C f. assume Hf. let i. assume Hi. let j. assume Hj. let P c. assume Hc. let q. assume Hq.
exact Hq X C f Hf i Hi j Hj P c Hc.
Qed.

Theorem pack_struct_c_b_u_u_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_c_b_u_u_p_e (pack_c_b_u_u_p_e X C f i j P c) -> forall x y :e X, f x y :e X.
let X C f i j P c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_e X C f i j P c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_p_e X' C' f' i' j' P' c' = pack_c_b_u_u_p_e X C f i j P c.
  apply pack_c_b_u_u_p_e_inj X' X C' C f' f i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_p_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_c_b_u_u_p_e (pack_c_b_u_u_p_e X C f i j P c) -> forall x :e X, i x :e X.
let X C f i j P c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_e X C f i j P c -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_p_e X' C' f' i' j' P' c' = pack_c_b_u_u_p_e X C f i j P c.
  apply pack_c_b_u_u_p_e_inj X' X C' C f' f i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_p_e_E4: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_c_b_u_u_p_e (pack_c_b_u_u_p_e X C f i j P c) -> forall x :e X, j x :e X.
let X C f i j P c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_e X C f i j P c -> forall x :e X, j x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_p_e X' C' f' i' j' P' c' = pack_c_b_u_u_p_e X C f i j P c.
  apply pack_c_b_u_u_p_e_inj X' X C' C f' f i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_c_b_u_u_p_e (pack_c_b_u_u_p_e X C f i j P c) -> c :e X.
let X C f i j P c. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_e X C f i j P c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_u_p_e X' C' f' i' j' P' c' = pack_c_b_u_u_p_e X C f i j P c.
  apply pack_c_b_u_u_p_e_inj X' X C' C f' f i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_u_u_p_e_eta: forall S, struct_c_b_u_u_p_e S -> S = pack_c_b_u_u_p_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_u_p_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let f. assume _. let i. assume _. let j. assume _. let P. let c. assume _.
prove pack_c_b_u_u_p_e X C f i j P c = pack_c_b_u_u_p_e (pack_c_b_u_u_p_e X C f i j P c 0) (decode_c (pack_c_b_u_u_p_e X C f i j P c 1)) (decode_b (pack_c_b_u_u_p_e X C f i j P c 2)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 3)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 4)) (decode_p (pack_c_b_u_u_p_e X C f i j P c 5)) (pack_c_b_u_u_p_e X C f i j P c 6).
rewrite <- pack_c_b_u_u_p_e_0_eq2 X C f i j P c.
rewrite <- pack_c_b_u_u_p_e_6_eq2 X C f i j P c.
apply pack_c_b_u_u_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_u_p_e_1_eq2 X C f i j P c U HU.
  apply iff_refl.
- exact pack_c_b_u_u_p_e_2_eq2 X C f i j P c.
- exact pack_c_b_u_u_p_e_3_eq2 X C f i j P c.
- exact pack_c_b_u_u_p_e_4_eq2 X C f i j P c.
- let x. assume Hx.
  rewrite <- pack_c_b_u_u_p_e_5_eq2 X C f i j P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_u_u_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' j' P' c = Phi X C f i j P c)
  ->
  unpack_c_b_u_u_p_e_i (pack_c_b_u_u_p_e X C f i j P c) Phi = Phi X C f i j P c.
let Phi X C f i j P c.
assume HPhi.
prove Phi (pack_c_b_u_u_p_e X C f i j P c 0) (decode_c (pack_c_b_u_u_p_e X C f i j P c 1)) (decode_b (pack_c_b_u_u_p_e X C f i j P c 2)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 3)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 4)) (decode_p (pack_c_b_u_u_p_e X C f i j P c 5)) (pack_c_b_u_u_p_e X C f i j P c 6) = Phi X C f i j P c.
rewrite <- pack_c_b_u_u_p_e_0_eq2 X C f i j P c.
prove Phi X (decode_c (pack_c_b_u_u_p_e X C f i j P c 1)) (decode_b (pack_c_b_u_u_p_e X C f i j P c 2)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 3)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 4)) (decode_p (pack_c_b_u_u_p_e X C f i j P c 5)) (pack_c_b_u_u_p_e X C f i j P c 6) = Phi X C f i j P c.
rewrite <- pack_c_b_u_u_p_e_6_eq2 X C f i j P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_p_e X C f i j P c 1) U.
  rewrite <- pack_c_b_u_u_p_e_1_eq2 X C f i j P c U HU.
  apply iff_refl.
- exact pack_c_b_u_u_p_e_2_eq2 X C f i j P c.
- exact pack_c_b_u_u_p_e_3_eq2 X C f i j P c.
- exact pack_c_b_u_u_p_e_4_eq2 X C f i j P c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_u_p_e X C f i j P c 5) x.
  rewrite <- pack_c_b_u_u_p_e_5_eq2 X C f i j P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_u_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_u_u_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' j' P' c = Phi X C f i j P c)
  ->
  unpack_c_b_u_u_p_e_o (pack_c_b_u_u_p_e X C f i j P c) Phi = Phi X C f i j P c.
let Phi X C f i j P c.
assume HPhi.
prove Phi (pack_c_b_u_u_p_e X C f i j P c 0) (decode_c (pack_c_b_u_u_p_e X C f i j P c 1)) (decode_b (pack_c_b_u_u_p_e X C f i j P c 2)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 3)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 4)) (decode_p (pack_c_b_u_u_p_e X C f i j P c 5)) (pack_c_b_u_u_p_e X C f i j P c 6) = Phi X C f i j P c.
rewrite <- pack_c_b_u_u_p_e_0_eq2 X C f i j P c.
prove Phi X (decode_c (pack_c_b_u_u_p_e X C f i j P c 1)) (decode_b (pack_c_b_u_u_p_e X C f i j P c 2)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 3)) (decode_u (pack_c_b_u_u_p_e X C f i j P c 4)) (decode_p (pack_c_b_u_u_p_e X C f i j P c 5)) (pack_c_b_u_u_p_e X C f i j P c 6) = Phi X C f i j P c.
rewrite <- pack_c_b_u_u_p_e_6_eq2 X C f i j P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_p_e X C f i j P c 1) U.
  rewrite <- pack_c_b_u_u_p_e_1_eq2 X C f i j P c U HU.
  apply iff_refl.
- exact pack_c_b_u_u_p_e_2_eq2 X C f i j P c.
- exact pack_c_b_u_u_p_e_3_eq2 X C f i j P c.
- exact pack_c_b_u_u_p_e_4_eq2 X C f i j P c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_u_p_e X C f i j P c 5) x.
  rewrite <- pack_c_b_u_u_p_e_5_eq2 X C f i j P c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_u_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> set := fun X C f i j c d => (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d).

Theorem pack_c_b_u_u_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> X = S 0.
let S X C f i j c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_u_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, X = pack_c_b_u_u_e_e X C f i j c d 0.
let X C f i j c d. apply pack_c_b_u_u_e_e_0_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i j c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_u_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_u_e_e X C f i j c d 1) U.
let X C f i j c d. apply pack_c_b_u_u_e_e_1_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i j c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_u_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_c_b_u_u_e_e X C f i j c d 2) x y.
let X C f i j c d. apply pack_c_b_u_u_e_e_2_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i j c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_u_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_c_b_u_u_e_e X C f i j c d 3) x.
let X C f i j c d. apply pack_c_b_u_u_e_e_3_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> forall x :e X, j x = decode_u (S 4) x.
let S X C f i j c d. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_c_b_u_u_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x :e X, j x = decode_u (pack_c_b_u_u_e_e X C f i j c d 4) x.
let X C f i j c d. apply pack_c_b_u_u_e_e_4_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> c = S 5.
let S X C f i j c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_b_u_u_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, c = pack_c_b_u_u_e_e X C f i j c d 5.
let X C f i j c d. apply pack_c_b_u_u_e_e_5_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_c_b_u_u_e_e X C f i j c d -> d = S 6.
let S X C f i j c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_u_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, d = pack_c_b_u_u_e_e X C f i j c d 6.
let X C f i j c d. apply pack_c_b_u_u_e_e_6_eq (pack_c_b_u_u_e_e X C f i j c d) X C f i j c d. reflexivity.
Qed.

Theorem pack_c_b_u_u_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall c c':set, forall d d':set, pack_c_b_u_u_e_e X C f i j c d = pack_c_b_u_u_e_e X' C' f' i' j' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ c = c' /\ d = d'.
let X X' C C' f f' i i' j j' c c' d d'. assume H1.
claim L0: X' = pack_c_b_u_u_e_e X C f i j c d 0.
{ exact pack_c_b_u_u_e_e_0_eq (pack_c_b_u_u_e_e X C f i j c d) X' C' f' i' j' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_u_e_e_0_eq2 X C f i j c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_u_e_e_1_eq2 X C f i j c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_e_e_1_eq2 X' C' f' i' j' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_u_e_e_2_eq2 X C f i j c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_e_e_2_eq2 X' C' f' i' j' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_u_e_e_3_eq2 X C f i j c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_e_e_3_eq2 X' C' f' i' j' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_c_b_u_u_e_e_4_eq2 X C f i j c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_u_e_e_4_eq2 X' C' f' i' j' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_b_u_u_e_e_5_eq2 X C f i j c d.
  rewrite H1. symmetry.
  exact pack_c_b_u_u_e_e_5_eq2 X' C' f' i' j' c' d'.
- prove d = d'.
  rewrite pack_c_b_u_u_e_e_6_eq2 X C f i j c d.
  rewrite H1. symmetry.
  exact pack_c_b_u_u_e_e_6_eq2 X' C' f' i' j' c' d'.
Qed.

Theorem pack_c_b_u_u_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 pack_c_b_u_u_e_e X C f i j c d = pack_c_b_u_u_e_e X C' f' i' j' c d.
let X C C' f f' i i' j j' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_u X j,c,d) = (X,encode_c X C',encode_b X f',encode_u X i',encode_u X j',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_b_u_u_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_b_u_u_e_e X C f i j c d)) -> q S.

Theorem pack_struct_c_b_u_u_e_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall c:set, c :e X -> forall d:set, d :e X -> struct_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d).
let X C f. assume Hf. let i. assume Hi. let j. assume Hj. let c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C f Hf i Hi j Hj c Hc d Hd.
Qed.

Theorem pack_struct_c_b_u_u_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d) -> forall x y :e X, f x y :e X.
let X C f i j c d. assume H1. apply H1 (fun z => z = pack_c_b_u_u_e_e X C f i j c d -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_u_e_e X' C' f' i' j' c' d' = pack_c_b_u_u_e_e X C f i j c d.
  apply pack_c_b_u_u_e_e_inj X' X C' C f' f i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_e_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d) -> forall x :e X, i x :e X.
let X C f i j c d. assume H1. apply H1 (fun z => z = pack_c_b_u_u_e_e X C f i j c d -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_u_e_e X' C' f' i' j' c' d' = pack_c_b_u_u_e_e X C f i j c d.
  apply pack_c_b_u_u_e_e_inj X' X C' C f' f i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_e_e_E4: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d) -> forall x :e X, j x :e X.
let X C f i j c d. assume H1. apply H1 (fun z => z = pack_c_b_u_u_e_e X C f i j c d -> forall x :e X, j x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_u_e_e X' C' f' i' j' c' d' = pack_c_b_u_u_e_e X C f i j c d.
  apply pack_c_b_u_u_e_e_inj X' X C' C f' f i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d) -> c :e X.
let X C f i j c d. assume H1. apply H1 (fun z => z = pack_c_b_u_u_e_e X C f i j c d -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_u_e_e X' C' f' i' j' c' d' = pack_c_b_u_u_e_e X C f i j c d.
  apply pack_c_b_u_u_e_e_inj X' X C' C f' f i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_u_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d) -> d :e X.
let X C f i j c d. assume H1. apply H1 (fun z => z = pack_c_b_u_u_e_e X C f i j c d -> d :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_u_e_e X' C' f' i' j' c' d' = pack_c_b_u_u_e_e X C f i j c d.
  apply pack_c_b_u_u_e_e_inj X' X C' C f' f i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_b_u_u_e_e_eta: forall S, struct_c_b_u_u_e_e S -> S = pack_c_b_u_u_e_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_u_e_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (z 5) (z 6)).
let X. let C. let f. assume _. let i. assume _. let j. assume _. let c. assume _. let d. assume _.
prove pack_c_b_u_u_e_e X C f i j c d = pack_c_b_u_u_e_e (pack_c_b_u_u_e_e X C f i j c d 0) (decode_c (pack_c_b_u_u_e_e X C f i j c d 1)) (decode_b (pack_c_b_u_u_e_e X C f i j c d 2)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 3)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 4)) (pack_c_b_u_u_e_e X C f i j c d 5) (pack_c_b_u_u_e_e X C f i j c d 6).
rewrite <- pack_c_b_u_u_e_e_0_eq2 X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_5_eq2 X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_6_eq2 X C f i j c d.
apply pack_c_b_u_u_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_u_e_e_1_eq2 X C f i j c d U HU.
  apply iff_refl.
- exact pack_c_b_u_u_e_e_2_eq2 X C f i j c d.
- exact pack_c_b_u_u_e_e_3_eq2 X C f i j c d.
- exact pack_c_b_u_u_e_e_4_eq2 X C f i j c d.
Qed.


Definition unpack_c_b_u_u_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (S 5) (S 6).

Theorem unpack_c_b_u_u_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) -> Phi X C' f' i' j' c d = Phi X C f i j c d)
  ->
  unpack_c_b_u_u_e_e_i (pack_c_b_u_u_e_e X C f i j c d) Phi = Phi X C f i j c d.
let Phi X C f i j c d.
assume HPhi.
prove Phi (pack_c_b_u_u_e_e X C f i j c d 0) (decode_c (pack_c_b_u_u_e_e X C f i j c d 1)) (decode_b (pack_c_b_u_u_e_e X C f i j c d 2)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 3)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 4)) (pack_c_b_u_u_e_e X C f i j c d 5) (pack_c_b_u_u_e_e X C f i j c d 6) = Phi X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_0_eq2 X C f i j c d.
prove Phi X (decode_c (pack_c_b_u_u_e_e X C f i j c d 1)) (decode_b (pack_c_b_u_u_e_e X C f i j c d 2)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 3)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 4)) (pack_c_b_u_u_e_e X C f i j c d 5) (pack_c_b_u_u_e_e X C f i j c d 6) = Phi X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_5_eq2 X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_6_eq2 X C f i j c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_e_e X C f i j c d 1) U.
  rewrite <- pack_c_b_u_u_e_e_1_eq2 X C f i j c d U HU.
  apply iff_refl.
- exact pack_c_b_u_u_e_e_2_eq2 X C f i j c d.
- exact pack_c_b_u_u_e_e_3_eq2 X C f i j c d.
- exact pack_c_b_u_u_e_e_4_eq2 X C f i j c d.
Qed.


Definition unpack_c_b_u_u_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (S 5) (S 6).

Theorem unpack_c_b_u_u_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) -> Phi X C' f' i' j' c d = Phi X C f i j c d)
  ->
  unpack_c_b_u_u_e_e_o (pack_c_b_u_u_e_e X C f i j c d) Phi = Phi X C f i j c d.
let Phi X C f i j c d.
assume HPhi.
prove Phi (pack_c_b_u_u_e_e X C f i j c d 0) (decode_c (pack_c_b_u_u_e_e X C f i j c d 1)) (decode_b (pack_c_b_u_u_e_e X C f i j c d 2)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 3)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 4)) (pack_c_b_u_u_e_e X C f i j c d 5) (pack_c_b_u_u_e_e X C f i j c d 6) = Phi X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_0_eq2 X C f i j c d.
prove Phi X (decode_c (pack_c_b_u_u_e_e X C f i j c d 1)) (decode_b (pack_c_b_u_u_e_e X C f i j c d 2)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 3)) (decode_u (pack_c_b_u_u_e_e X C f i j c d 4)) (pack_c_b_u_u_e_e X C f i j c d 5) (pack_c_b_u_u_e_e X C f i j c d 6) = Phi X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_5_eq2 X C f i j c d.
rewrite <- pack_c_b_u_u_e_e_6_eq2 X C f i j c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_u_e_e X C f i j c d 1) U.
  rewrite <- pack_c_b_u_u_e_e_1_eq2 X C f i j c d U HU.
  apply iff_refl.
- exact pack_c_b_u_u_e_e_2_eq2 X C f i j c d.
- exact pack_c_b_u_u_e_e_3_eq2 X C f i j c d.
- exact pack_c_b_u_u_e_e_4_eq2 X C f i j c d.
Qed.


Definition pack_c_b_u_r_r_p : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set := fun X C f i R T P => (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P).

Theorem pack_c_b_u_r_r_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> X = S 0.
let S X C f i R T P. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_r_r_p_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, X = pack_c_b_u_r_r_p X C f i R T P 0.
let X C f i R T P. apply pack_c_b_u_r_r_p_0_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i R T P. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_r_r_p_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_r_r_p X C f i R T P 1) U.
let X C f i R T P. apply pack_c_b_u_r_r_p_1_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_r_p_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_c_b_u_r_r_p X C f i R T P 2) x y.
let X C f i R T P. apply pack_c_b_u_r_r_p_2_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i R T P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_r_r_p_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x :e X, i x = decode_u (pack_c_b_u_r_r_p X C f i R T P 3) x.
let X C f i R T P. apply pack_c_b_u_r_r_p_3_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X C f i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_r_p_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, R x y = decode_r (pack_c_b_u_r_r_p X C f i R T P 4) x y.
let X C f i R T P. apply pack_c_b_u_r_r_p_4_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> forall x y :e X, T x y = decode_r (S 5) x y.
let S X C f i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_r_p_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, T x y = decode_r (pack_c_b_u_r_r_p X C f i R T P 5) x y.
let X C f i R T P. apply pack_c_b_u_r_r_p_5_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_c_b_u_r_r_p X C f i R T P -> forall x :e X, P x = decode_p (S 6) x.
let S X C f i R T P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_r_r_p_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x :e X, P x = decode_p (pack_c_b_u_r_r_p X C f i R T P 6) x.
let X C f i R T P. apply pack_c_b_u_r_r_p_6_eq (pack_c_b_u_r_r_p X C f i R T P) X C f i R T P. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_p_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, pack_c_b_u_r_r_p X C f i R T P = pack_c_b_u_r_r_p X' C' f' i' R' T' P' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x).
let X X' C C' f f' i i' R R' T T' P P'. assume H1.
claim L0: X' = pack_c_b_u_r_r_p X C f i R T P 0.
{ exact pack_c_b_u_r_r_p_0_eq (pack_c_b_u_r_r_p X C f i R T P) X' C' f' i' R' T' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_r_r_p_0_eq2 X C f i R T P. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_r_r_p_1_eq2 X C f i R T P U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_p_1_eq2 X' C' f' i' R' T' P' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_r_r_p_2_eq2 X C f i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_p_2_eq2 X' C' f' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_r_r_p_3_eq2 X C f i R T P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_p_3_eq2 X' C' f' i' R' T' P' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_r_r_p_4_eq2 X C f i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_p_4_eq2 X' C' f' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_b_u_r_r_p_5_eq2 X C f i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_p_5_eq2 X' C' f' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_r_r_p_6_eq2 X C f i R T P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_p_6_eq2 X' C' f' i' R' T' P' x Lx.
Qed.

Theorem pack_c_b_u_r_r_p_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_u_r_r_p X C f i R T P = pack_c_b_u_r_r_p X C' f' i' R' T' P'.
let X C C' f f' i i' R R' T T' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P) = (X,encode_c X C',encode_b X f',encode_u X i',encode_r X R',encode_r X T',encode_p X P').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_b_u_r_r_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, q (pack_c_b_u_r_r_p X C f i R T P)) -> q S.

Theorem pack_struct_c_b_u_r_r_p_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_c_b_u_r_r_p (pack_c_b_u_r_r_p X C f i R T P).
let X C f. assume Hf. let i. assume Hi. let R T P q. assume Hq.
exact Hq X C f Hf i Hi R T P.
Qed.

Theorem pack_struct_c_b_u_r_r_p_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_c_b_u_r_r_p (pack_c_b_u_r_r_p X C f i R T P) -> forall x y :e X, f x y :e X.
let X C f i R T P. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_p X C f i R T P -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'.
  assume Heq: pack_c_b_u_r_r_p X' C' f' i' R' T' P' = pack_c_b_u_r_r_p X C f i R T P.
  apply pack_c_b_u_r_r_p_inj X' X C' C f' f i' i R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_r_p_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_c_b_u_r_r_p (pack_c_b_u_r_r_p X C f i R T P) -> forall x :e X, i x :e X.
let X C f i R T P. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_p X C f i R T P -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'.
  assume Heq: pack_c_b_u_r_r_p X' C' f' i' R' T' P' = pack_c_b_u_r_r_p X C f i R T P.
  apply pack_c_b_u_r_r_p_inj X' X C' C f' f i' i R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_c_b_u_r_r_p_eta: forall S, struct_c_b_u_r_r_p S -> S = pack_c_b_u_r_r_p (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_p (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_r (z 5)) (decode_p (z 6))).
let X. let C. let f. assume _. let i. assume _. let R. let T. let P.
prove pack_c_b_u_r_r_p X C f i R T P = pack_c_b_u_r_r_p (pack_c_b_u_r_r_p X C f i R T P 0) (decode_c (pack_c_b_u_r_r_p X C f i R T P 1)) (decode_b (pack_c_b_u_r_r_p X C f i R T P 2)) (decode_u (pack_c_b_u_r_r_p X C f i R T P 3)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 4)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 5)) (decode_p (pack_c_b_u_r_r_p X C f i R T P 6)).
rewrite <- pack_c_b_u_r_r_p_0_eq2 X C f i R T P.
apply pack_c_b_u_r_r_p_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_r_r_p_1_eq2 X C f i R T P U HU.
  apply iff_refl.
- exact pack_c_b_u_r_r_p_2_eq2 X C f i R T P.
- exact pack_c_b_u_r_r_p_3_eq2 X C f i R T P.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_r_p_4_eq2 X C f i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_r_p_5_eq2 X C f i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_r_r_p_6_eq2 X C f i R T P x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_r_p_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_r_r_p_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' R' T' P' = Phi X C f i R T P)
  ->
  unpack_c_b_u_r_r_p_i (pack_c_b_u_r_r_p X C f i R T P) Phi = Phi X C f i R T P.
let Phi X C f i R T P.
assume HPhi.
prove Phi (pack_c_b_u_r_r_p X C f i R T P 0) (decode_c (pack_c_b_u_r_r_p X C f i R T P 1)) (decode_b (pack_c_b_u_r_r_p X C f i R T P 2)) (decode_u (pack_c_b_u_r_r_p X C f i R T P 3)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 4)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 5)) (decode_p (pack_c_b_u_r_r_p X C f i R T P 6)) = Phi X C f i R T P.
rewrite <- pack_c_b_u_r_r_p_0_eq2 X C f i R T P.
prove Phi X (decode_c (pack_c_b_u_r_r_p X C f i R T P 1)) (decode_b (pack_c_b_u_r_r_p X C f i R T P 2)) (decode_u (pack_c_b_u_r_r_p X C f i R T P 3)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 4)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 5)) (decode_p (pack_c_b_u_r_r_p X C f i R T P 6)) = Phi X C f i R T P.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_r_p X C f i R T P 1) U.
  rewrite <- pack_c_b_u_r_r_p_1_eq2 X C f i R T P U HU.
  apply iff_refl.
- exact pack_c_b_u_r_r_p_2_eq2 X C f i R T P.
- exact pack_c_b_u_r_r_p_3_eq2 X C f i R T P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_r_p X C f i R T P 4) x y.
  rewrite <- pack_c_b_u_r_r_p_4_eq2 X C f i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_u_r_r_p X C f i R T P 5) x y.
  rewrite <- pack_c_b_u_r_r_p_5_eq2 X C f i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_r_r_p X C f i R T P 6) x.
  rewrite <- pack_c_b_u_r_r_p_6_eq2 X C f i R T P x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_r_p_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_r_r_p_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' R' T' P' = Phi X C f i R T P)
  ->
  unpack_c_b_u_r_r_p_o (pack_c_b_u_r_r_p X C f i R T P) Phi = Phi X C f i R T P.
let Phi X C f i R T P.
assume HPhi.
prove Phi (pack_c_b_u_r_r_p X C f i R T P 0) (decode_c (pack_c_b_u_r_r_p X C f i R T P 1)) (decode_b (pack_c_b_u_r_r_p X C f i R T P 2)) (decode_u (pack_c_b_u_r_r_p X C f i R T P 3)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 4)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 5)) (decode_p (pack_c_b_u_r_r_p X C f i R T P 6)) = Phi X C f i R T P.
rewrite <- pack_c_b_u_r_r_p_0_eq2 X C f i R T P.
prove Phi X (decode_c (pack_c_b_u_r_r_p X C f i R T P 1)) (decode_b (pack_c_b_u_r_r_p X C f i R T P 2)) (decode_u (pack_c_b_u_r_r_p X C f i R T P 3)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 4)) (decode_r (pack_c_b_u_r_r_p X C f i R T P 5)) (decode_p (pack_c_b_u_r_r_p X C f i R T P 6)) = Phi X C f i R T P.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_r_p X C f i R T P 1) U.
  rewrite <- pack_c_b_u_r_r_p_1_eq2 X C f i R T P U HU.
  apply iff_refl.
- exact pack_c_b_u_r_r_p_2_eq2 X C f i R T P.
- exact pack_c_b_u_r_r_p_3_eq2 X C f i R T P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_r_p X C f i R T P 4) x y.
  rewrite <- pack_c_b_u_r_r_p_4_eq2 X C f i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_u_r_r_p X C f i R T P 5) x y.
  rewrite <- pack_c_b_u_r_r_p_5_eq2 X C f i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_r_r_p X C f i R T P 6) x.
  rewrite <- pack_c_b_u_r_r_p_6_eq2 X C f i R T P x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_r_r_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set := fun X C f i R T c => (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c).

Theorem pack_c_b_u_r_r_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> X = S 0.
let S X C f i R T c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_r_r_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, X = pack_c_b_u_r_r_e X C f i R T c 0.
let X C f i R T c. apply pack_c_b_u_r_r_e_0_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i R T c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_r_r_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_r_r_e X C f i R T c 1) U.
let X C f i R T c. apply pack_c_b_u_r_r_e_1_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_r_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_u_r_r_e X C f i R T c 2) x y.
let X C f i R T c. apply pack_c_b_u_r_r_e_2_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i R T c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_r_r_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_b_u_r_r_e X C f i R T c 3) x.
let X C f i R T c. apply pack_c_b_u_r_r_e_3_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X C f i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_r_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_b_u_r_r_e X C f i R T c 4) x y.
let X C f i R T c. apply pack_c_b_u_r_r_e_4_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> forall x y :e X, T x y = decode_r (S 5) x y.
let S X C f i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_r_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_c_b_u_r_r_e X C f i R T c 5) x y.
let X C f i R T c. apply pack_c_b_u_r_r_e_5_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_c_b_u_r_r_e X C f i R T c -> c = S 6.
let S X C f i R T c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_r_r_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c = pack_c_b_u_r_r_e X C f i R T c 6.
let X C f i R T c. apply pack_c_b_u_r_r_e_6_eq (pack_c_b_u_r_r_e X C f i R T c) X C f i R T c. reflexivity.
Qed.

Theorem pack_c_b_u_r_r_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, pack_c_b_u_r_r_e X C f i R T c = pack_c_b_u_r_r_e X' C' f' i' R' T' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c'.
let X X' C C' f f' i i' R R' T T' c c'. assume H1.
claim L0: X' = pack_c_b_u_r_r_e X C f i R T c 0.
{ exact pack_c_b_u_r_r_e_0_eq (pack_c_b_u_r_r_e X C f i R T c) X' C' f' i' R' T' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_r_r_e_0_eq2 X C f i R T c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_r_r_e_1_eq2 X C f i R T c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_e_1_eq2 X' C' f' i' R' T' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_r_r_e_2_eq2 X C f i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_e_2_eq2 X' C' f' i' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_r_r_e_3_eq2 X C f i R T c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_e_3_eq2 X' C' f' i' R' T' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_r_r_e_4_eq2 X C f i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_e_4_eq2 X' C' f' i' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_b_u_r_r_e_5_eq2 X C f i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_e_5_eq2 X' C' f' i' R' T' c' x Lx y Ly.
- prove c = c'.
  rewrite pack_c_b_u_r_r_e_6_eq2 X C f i R T c.
  rewrite H1. symmetry.
  exact pack_c_b_u_r_r_e_6_eq2 X' C' f' i' R' T' c'.
Qed.

Theorem pack_c_b_u_r_r_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_c_b_u_r_r_e X C f i R T c = pack_c_b_u_r_r_e X C' f' i' R' T' c.
let X C C' f f' i i' R R' T T' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c) = (X,encode_c X C',encode_b X f',encode_u X i',encode_r X R',encode_r X T',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_u_r_r_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> q (pack_c_b_u_r_r_e X C f i R T c)) -> q S.

Theorem pack_struct_c_b_u_r_r_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> struct_c_b_u_r_r_e (pack_c_b_u_r_r_e X C f i R T c).
let X C f. assume Hf. let i. assume Hi. let R T c. assume Hc. let q. assume Hq.
exact Hq X C f Hf i Hi R T c Hc.
Qed.

Theorem pack_struct_c_b_u_r_r_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_c_b_u_r_r_e (pack_c_b_u_r_r_e X C f i R T c) -> forall x y :e X, f x y :e X.
let X C f i R T c. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_e X C f i R T c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_r_r_e X' C' f' i' R' T' c' = pack_c_b_u_r_r_e X C f i R T c.
  apply pack_c_b_u_r_r_e_inj X' X C' C f' f i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_r_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_c_b_u_r_r_e (pack_c_b_u_r_r_e X C f i R T c) -> forall x :e X, i x :e X.
let X C f i R T c. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_e X C f i R T c -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_r_r_e X' C' f' i' R' T' c' = pack_c_b_u_r_r_e X C f i R T c.
  apply pack_c_b_u_r_r_e_inj X' X C' C f' f i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_r_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_c_b_u_r_r_e (pack_c_b_u_r_r_e X C f i R T c) -> c :e X.
let X C f i R T c. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_e X C f i R T c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_r_r_e X' C' f' i' R' T' c' = pack_c_b_u_r_r_e X C f i R T c.
  apply pack_c_b_u_r_r_e_inj X' X C' C f' f i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_u_r_r_e_eta: forall S, struct_c_b_u_r_r_e S -> S = pack_c_b_u_r_r_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_r_r_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_r (z 5)) (z 6)).
let X. let C. let f. assume _. let i. assume _. let R. let T. let c. assume _.
prove pack_c_b_u_r_r_e X C f i R T c = pack_c_b_u_r_r_e (pack_c_b_u_r_r_e X C f i R T c 0) (decode_c (pack_c_b_u_r_r_e X C f i R T c 1)) (decode_b (pack_c_b_u_r_r_e X C f i R T c 2)) (decode_u (pack_c_b_u_r_r_e X C f i R T c 3)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 4)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 5)) (pack_c_b_u_r_r_e X C f i R T c 6).
rewrite <- pack_c_b_u_r_r_e_0_eq2 X C f i R T c.
rewrite <- pack_c_b_u_r_r_e_6_eq2 X C f i R T c.
apply pack_c_b_u_r_r_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_r_r_e_1_eq2 X C f i R T c U HU.
  apply iff_refl.
- exact pack_c_b_u_r_r_e_2_eq2 X C f i R T c.
- exact pack_c_b_u_r_r_e_3_eq2 X C f i R T c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_r_e_4_eq2 X C f i R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_r_e_5_eq2 X C f i R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_r_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_c_b_u_r_r_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' f' i' R' T' c = Phi X C f i R T c)
  ->
  unpack_c_b_u_r_r_e_i (pack_c_b_u_r_r_e X C f i R T c) Phi = Phi X C f i R T c.
let Phi X C f i R T c.
assume HPhi.
prove Phi (pack_c_b_u_r_r_e X C f i R T c 0) (decode_c (pack_c_b_u_r_r_e X C f i R T c 1)) (decode_b (pack_c_b_u_r_r_e X C f i R T c 2)) (decode_u (pack_c_b_u_r_r_e X C f i R T c 3)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 4)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 5)) (pack_c_b_u_r_r_e X C f i R T c 6) = Phi X C f i R T c.
rewrite <- pack_c_b_u_r_r_e_0_eq2 X C f i R T c.
prove Phi X (decode_c (pack_c_b_u_r_r_e X C f i R T c 1)) (decode_b (pack_c_b_u_r_r_e X C f i R T c 2)) (decode_u (pack_c_b_u_r_r_e X C f i R T c 3)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 4)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 5)) (pack_c_b_u_r_r_e X C f i R T c 6) = Phi X C f i R T c.
rewrite <- pack_c_b_u_r_r_e_6_eq2 X C f i R T c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_r_e X C f i R T c 1) U.
  rewrite <- pack_c_b_u_r_r_e_1_eq2 X C f i R T c U HU.
  apply iff_refl.
- exact pack_c_b_u_r_r_e_2_eq2 X C f i R T c.
- exact pack_c_b_u_r_r_e_3_eq2 X C f i R T c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_r_e X C f i R T c 4) x y.
  rewrite <- pack_c_b_u_r_r_e_4_eq2 X C f i R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_u_r_r_e X C f i R T c 5) x y.
  rewrite <- pack_c_b_u_r_r_e_5_eq2 X C f i R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_r_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_c_b_u_r_r_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' f' i' R' T' c = Phi X C f i R T c)
  ->
  unpack_c_b_u_r_r_e_o (pack_c_b_u_r_r_e X C f i R T c) Phi = Phi X C f i R T c.
let Phi X C f i R T c.
assume HPhi.
prove Phi (pack_c_b_u_r_r_e X C f i R T c 0) (decode_c (pack_c_b_u_r_r_e X C f i R T c 1)) (decode_b (pack_c_b_u_r_r_e X C f i R T c 2)) (decode_u (pack_c_b_u_r_r_e X C f i R T c 3)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 4)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 5)) (pack_c_b_u_r_r_e X C f i R T c 6) = Phi X C f i R T c.
rewrite <- pack_c_b_u_r_r_e_0_eq2 X C f i R T c.
prove Phi X (decode_c (pack_c_b_u_r_r_e X C f i R T c 1)) (decode_b (pack_c_b_u_r_r_e X C f i R T c 2)) (decode_u (pack_c_b_u_r_r_e X C f i R T c 3)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 4)) (decode_r (pack_c_b_u_r_r_e X C f i R T c 5)) (pack_c_b_u_r_r_e X C f i R T c 6) = Phi X C f i R T c.
rewrite <- pack_c_b_u_r_r_e_6_eq2 X C f i R T c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_r_e X C f i R T c 1) U.
  rewrite <- pack_c_b_u_r_r_e_1_eq2 X C f i R T c U HU.
  apply iff_refl.
- exact pack_c_b_u_r_r_e_2_eq2 X C f i R T c.
- exact pack_c_b_u_r_r_e_3_eq2 X C f i R T c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_r_e X C f i R T c 4) x y.
  rewrite <- pack_c_b_u_r_r_e_4_eq2 X C f i R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_u_r_r_e X C f i R T c 5) x y.
  rewrite <- pack_c_b_u_r_r_e_5_eq2 X C f i R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_c_b_u_r_p_p : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X C f i R P Q => (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q).

Theorem pack_c_b_u_r_p_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> X = S 0.
let S X C f i R P Q. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_r_p_p_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_c_b_u_r_p_p X C f i R P Q 0.
let X C f i R P Q. apply pack_c_b_u_r_p_p_0_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i R P Q. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_r_p_p_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_r_p_p X C f i R P Q 1) U.
let X C f i R P Q. apply pack_c_b_u_r_p_p_1_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_p_p_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_c_b_u_r_p_p X C f i R P Q 2) x y.
let X C f i R P Q. apply pack_c_b_u_r_p_p_2_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_r_p_p_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_c_b_u_r_p_p X C f i R P Q 3) x.
let X C f i R P Q. apply pack_c_b_u_r_p_p_3_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X C f i R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_p_p_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_c_b_u_r_p_p X C f i R P Q 4) x y.
let X C f i R P Q. apply pack_c_b_u_r_p_p_4_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X C f i R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_r_p_p_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_c_b_u_r_p_p X C f i R P Q 5) x.
let X C f i R P Q. apply pack_c_b_u_r_p_p_5_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_u_r_p_p X C f i R P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X C f i R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_b_u_r_p_p_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_c_b_u_r_p_p X C f i R P Q 6) x.
let X C f i R P Q. apply pack_c_b_u_r_p_p_6_eq (pack_c_b_u_r_p_p X C f i R P Q) X C f i R P Q. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_p_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_c_b_u_r_p_p X C f i R P Q = pack_c_b_u_r_p_p X' C' f' i' R' P' Q' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' C C' f f' i i' R R' P P' Q Q'. assume H1.
claim L0: X' = pack_c_b_u_r_p_p X C f i R P Q 0.
{ exact pack_c_b_u_r_p_p_0_eq (pack_c_b_u_r_p_p X C f i R P Q) X' C' f' i' R' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_r_p_p_0_eq2 X C f i R P Q. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_r_p_p_1_eq2 X C f i R P Q U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_p_1_eq2 X' C' f' i' R' P' Q' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_r_p_p_2_eq2 X C f i R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_p_2_eq2 X' C' f' i' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_r_p_p_3_eq2 X C f i R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_p_3_eq2 X' C' f' i' R' P' Q' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_r_p_p_4_eq2 X C f i R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_p_4_eq2 X' C' f' i' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_r_p_p_5_eq2 X C f i R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_p_5_eq2 X' C' f' i' R' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_b_u_r_p_p_6_eq2 X C f i R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_p_6_eq2 X' C' f' i' R' P' Q' x Lx.
Qed.

Theorem pack_c_b_u_r_p_p_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_b_u_r_p_p X C f i R P Q = pack_c_b_u_r_p_p X C' f' i' R' P' Q'.
let X C C' f f' i i' R R' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) = (X,encode_c X C',encode_b X f',encode_u X i',encode_r X R',encode_p X P',encode_p X Q').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_b_u_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_c_b_u_r_p_p X C f i R P Q)) -> q S.

Theorem pack_struct_c_b_u_r_p_p_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_r_p_p (pack_c_b_u_r_p_p X C f i R P Q).
let X C f. assume Hf. let i. assume Hi. let R P Q q. assume Hq.
exact Hq X C f Hf i Hi R P Q.
Qed.

Theorem pack_struct_c_b_u_r_p_p_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_r_p_p (pack_c_b_u_r_p_p X C f i R P Q) -> forall x y :e X, f x y :e X.
let X C f i R P Q. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_p X C f i R P Q -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let Q'.
  assume Heq: pack_c_b_u_r_p_p X' C' f' i' R' P' Q' = pack_c_b_u_r_p_p X C f i R P Q.
  apply pack_c_b_u_r_p_p_inj X' X C' C f' f i' i R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_p_p_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_b_u_r_p_p (pack_c_b_u_r_p_p X C f i R P Q) -> forall x :e X, i x :e X.
let X C f i R P Q. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_p X C f i R P Q -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let Q'.
  assume Heq: pack_c_b_u_r_p_p X' C' f' i' R' P' Q' = pack_c_b_u_r_p_p X C f i R P Q.
  apply pack_c_b_u_r_p_p_inj X' X C' C f' f i' i R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_c_b_u_r_p_p_eta: forall S, struct_c_b_u_r_p_p S -> S = pack_c_b_u_r_p_p (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_p (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let C. let f. assume _. let i. assume _. let R. let P. let Q.
prove pack_c_b_u_r_p_p X C f i R P Q = pack_c_b_u_r_p_p (pack_c_b_u_r_p_p X C f i R P Q 0) (decode_c (pack_c_b_u_r_p_p X C f i R P Q 1)) (decode_b (pack_c_b_u_r_p_p X C f i R P Q 2)) (decode_u (pack_c_b_u_r_p_p X C f i R P Q 3)) (decode_r (pack_c_b_u_r_p_p X C f i R P Q 4)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 5)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 6)).
rewrite <- pack_c_b_u_r_p_p_0_eq2 X C f i R P Q.
apply pack_c_b_u_r_p_p_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_r_p_p_1_eq2 X C f i R P Q U HU.
  apply iff_refl.
- exact pack_c_b_u_r_p_p_2_eq2 X C f i R P Q.
- exact pack_c_b_u_r_p_p_3_eq2 X C f i R P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_p_p_4_eq2 X C f i R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_r_p_p_5_eq2 X C f i R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_r_p_p_6_eq2 X C f i R P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_p_p_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_r_p_p_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' i' R' P' Q' = Phi X C f i R P Q)
  ->
  unpack_c_b_u_r_p_p_i (pack_c_b_u_r_p_p X C f i R P Q) Phi = Phi X C f i R P Q.
let Phi X C f i R P Q.
assume HPhi.
prove Phi (pack_c_b_u_r_p_p X C f i R P Q 0) (decode_c (pack_c_b_u_r_p_p X C f i R P Q 1)) (decode_b (pack_c_b_u_r_p_p X C f i R P Q 2)) (decode_u (pack_c_b_u_r_p_p X C f i R P Q 3)) (decode_r (pack_c_b_u_r_p_p X C f i R P Q 4)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 5)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 6)) = Phi X C f i R P Q.
rewrite <- pack_c_b_u_r_p_p_0_eq2 X C f i R P Q.
prove Phi X (decode_c (pack_c_b_u_r_p_p X C f i R P Q 1)) (decode_b (pack_c_b_u_r_p_p X C f i R P Q 2)) (decode_u (pack_c_b_u_r_p_p X C f i R P Q 3)) (decode_r (pack_c_b_u_r_p_p X C f i R P Q 4)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 5)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 6)) = Phi X C f i R P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_p_p X C f i R P Q 1) U.
  rewrite <- pack_c_b_u_r_p_p_1_eq2 X C f i R P Q U HU.
  apply iff_refl.
- exact pack_c_b_u_r_p_p_2_eq2 X C f i R P Q.
- exact pack_c_b_u_r_p_p_3_eq2 X C f i R P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_p_p X C f i R P Q 4) x y.
  rewrite <- pack_c_b_u_r_p_p_4_eq2 X C f i R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_r_p_p X C f i R P Q 5) x.
  rewrite <- pack_c_b_u_r_p_p_5_eq2 X C f i R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_u_r_p_p X C f i R P Q 6) x.
  rewrite <- pack_c_b_u_r_p_p_6_eq2 X C f i R P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_p_p_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_u_r_p_p_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' i' R' P' Q' = Phi X C f i R P Q)
  ->
  unpack_c_b_u_r_p_p_o (pack_c_b_u_r_p_p X C f i R P Q) Phi = Phi X C f i R P Q.
let Phi X C f i R P Q.
assume HPhi.
prove Phi (pack_c_b_u_r_p_p X C f i R P Q 0) (decode_c (pack_c_b_u_r_p_p X C f i R P Q 1)) (decode_b (pack_c_b_u_r_p_p X C f i R P Q 2)) (decode_u (pack_c_b_u_r_p_p X C f i R P Q 3)) (decode_r (pack_c_b_u_r_p_p X C f i R P Q 4)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 5)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 6)) = Phi X C f i R P Q.
rewrite <- pack_c_b_u_r_p_p_0_eq2 X C f i R P Q.
prove Phi X (decode_c (pack_c_b_u_r_p_p X C f i R P Q 1)) (decode_b (pack_c_b_u_r_p_p X C f i R P Q 2)) (decode_u (pack_c_b_u_r_p_p X C f i R P Q 3)) (decode_r (pack_c_b_u_r_p_p X C f i R P Q 4)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 5)) (decode_p (pack_c_b_u_r_p_p X C f i R P Q 6)) = Phi X C f i R P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_p_p X C f i R P Q 1) U.
  rewrite <- pack_c_b_u_r_p_p_1_eq2 X C f i R P Q U HU.
  apply iff_refl.
- exact pack_c_b_u_r_p_p_2_eq2 X C f i R P Q.
- exact pack_c_b_u_r_p_p_3_eq2 X C f i R P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_p_p X C f i R P Q 4) x y.
  rewrite <- pack_c_b_u_r_p_p_4_eq2 X C f i R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_r_p_p X C f i R P Q 5) x.
  rewrite <- pack_c_b_u_r_p_p_5_eq2 X C f i R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_u_r_p_p X C f i R P Q 6) x.
  rewrite <- pack_c_b_u_r_p_p_6_eq2 X C f i R P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_r_p_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X C f i R P c => (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c).

Theorem pack_c_b_u_r_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> X = S 0.
let S X C f i R P c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_r_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_c_b_u_r_p_e X C f i R P c 0.
let X C f i R P c. apply pack_c_b_u_r_p_e_0_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i R P c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_r_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_r_p_e X C f i R P c 1) U.
let X C f i R P c. apply pack_c_b_u_r_p_e_1_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_u_r_p_e X C f i R P c 2) x y.
let X C f i R P c. apply pack_c_b_u_r_p_e_2_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i R P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_r_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_b_u_r_p_e X C f i R P c 3) x.
let X C f i R P c. apply pack_c_b_u_r_p_e_3_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X C f i R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_b_u_r_p_e X C f i R P c 4) x y.
let X C f i R P c. apply pack_c_b_u_r_p_e_4_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> forall x :e X, P x = decode_p (S 5) x.
let S X C f i R P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_r_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_b_u_r_p_e X C f i R P c 5) x.
let X C f i R P c. apply pack_c_b_u_r_p_e_5_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_u_r_p_e X C f i R P c -> c = S 6.
let S X C f i R P c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_r_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_c_b_u_r_p_e X C f i R P c 6.
let X C f i R P c. apply pack_c_b_u_r_p_e_6_eq (pack_c_b_u_r_p_e X C f i R P c) X C f i R P c. reflexivity.
Qed.

Theorem pack_c_b_u_r_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_c_b_u_r_p_e X C f i R P c = pack_c_b_u_r_p_e X' C' f' i' R' P' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' C C' f f' i i' R R' P P' c c'. assume H1.
claim L0: X' = pack_c_b_u_r_p_e X C f i R P c 0.
{ exact pack_c_b_u_r_p_e_0_eq (pack_c_b_u_r_p_e X C f i R P c) X' C' f' i' R' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_r_p_e_0_eq2 X C f i R P c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_r_p_e_1_eq2 X C f i R P c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_e_1_eq2 X' C' f' i' R' P' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_r_p_e_2_eq2 X C f i R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_e_2_eq2 X' C' f' i' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_r_p_e_3_eq2 X C f i R P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_e_3_eq2 X' C' f' i' R' P' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_r_p_e_4_eq2 X C f i R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_e_4_eq2 X' C' f' i' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_r_p_e_5_eq2 X C f i R P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_e_5_eq2 X' C' f' i' R' P' c' x Lx.
- prove c = c'.
  rewrite pack_c_b_u_r_p_e_6_eq2 X C f i R P c.
  rewrite H1. symmetry.
  exact pack_c_b_u_r_p_e_6_eq2 X' C' f' i' R' P' c'.
Qed.

Theorem pack_c_b_u_r_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_u_r_p_e X C f i R P c = pack_c_b_u_r_p_e X C' f' i' R' P' c.
let X C C' f f' i i' R R' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c) = (X,encode_c X C',encode_b X f',encode_u X i',encode_r X R',encode_p X P',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_u_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_c_b_u_r_p_e X C f i R P c)) -> q S.

Theorem pack_struct_c_b_u_r_p_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_c_b_u_r_p_e (pack_c_b_u_r_p_e X C f i R P c).
let X C f. assume Hf. let i. assume Hi. let R P c. assume Hc. let q. assume Hq.
exact Hq X C f Hf i Hi R P c Hc.
Qed.

Theorem pack_struct_c_b_u_r_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_b_u_r_p_e (pack_c_b_u_r_p_e X C f i R P c) -> forall x y :e X, f x y :e X.
let X C f i R P c. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_e X C f i R P c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_r_p_e X' C' f' i' R' P' c' = pack_c_b_u_r_p_e X C f i R P c.
  apply pack_c_b_u_r_p_e_inj X' X C' C f' f i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_p_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_b_u_r_p_e (pack_c_b_u_r_p_e X C f i R P c) -> forall x :e X, i x :e X.
let X C f i R P c. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_e X C f i R P c -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_r_p_e X' C' f' i' R' P' c' = pack_c_b_u_r_p_e X C f i R P c.
  apply pack_c_b_u_r_p_e_inj X' X C' C f' f i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_b_u_r_p_e (pack_c_b_u_r_p_e X C f i R P c) -> c :e X.
let X C f i R P c. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_e X C f i R P c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_r_p_e X' C' f' i' R' P' c' = pack_c_b_u_r_p_e X C f i R P c.
  apply pack_c_b_u_r_p_e_inj X' X C' C f' f i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_u_r_p_e_eta: forall S, struct_c_b_u_r_p_e S -> S = pack_c_b_u_r_p_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_r_p_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let f. assume _. let i. assume _. let R. let P. let c. assume _.
prove pack_c_b_u_r_p_e X C f i R P c = pack_c_b_u_r_p_e (pack_c_b_u_r_p_e X C f i R P c 0) (decode_c (pack_c_b_u_r_p_e X C f i R P c 1)) (decode_b (pack_c_b_u_r_p_e X C f i R P c 2)) (decode_u (pack_c_b_u_r_p_e X C f i R P c 3)) (decode_r (pack_c_b_u_r_p_e X C f i R P c 4)) (decode_p (pack_c_b_u_r_p_e X C f i R P c 5)) (pack_c_b_u_r_p_e X C f i R P c 6).
rewrite <- pack_c_b_u_r_p_e_0_eq2 X C f i R P c.
rewrite <- pack_c_b_u_r_p_e_6_eq2 X C f i R P c.
apply pack_c_b_u_r_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_r_p_e_1_eq2 X C f i R P c U HU.
  apply iff_refl.
- exact pack_c_b_u_r_p_e_2_eq2 X C f i R P c.
- exact pack_c_b_u_r_p_e_3_eq2 X C f i R P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_p_e_4_eq2 X C f i R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_r_p_e_5_eq2 X C f i R P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_u_r_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' R' P' c = Phi X C f i R P c)
  ->
  unpack_c_b_u_r_p_e_i (pack_c_b_u_r_p_e X C f i R P c) Phi = Phi X C f i R P c.
let Phi X C f i R P c.
assume HPhi.
prove Phi (pack_c_b_u_r_p_e X C f i R P c 0) (decode_c (pack_c_b_u_r_p_e X C f i R P c 1)) (decode_b (pack_c_b_u_r_p_e X C f i R P c 2)) (decode_u (pack_c_b_u_r_p_e X C f i R P c 3)) (decode_r (pack_c_b_u_r_p_e X C f i R P c 4)) (decode_p (pack_c_b_u_r_p_e X C f i R P c 5)) (pack_c_b_u_r_p_e X C f i R P c 6) = Phi X C f i R P c.
rewrite <- pack_c_b_u_r_p_e_0_eq2 X C f i R P c.
prove Phi X (decode_c (pack_c_b_u_r_p_e X C f i R P c 1)) (decode_b (pack_c_b_u_r_p_e X C f i R P c 2)) (decode_u (pack_c_b_u_r_p_e X C f i R P c 3)) (decode_r (pack_c_b_u_r_p_e X C f i R P c 4)) (decode_p (pack_c_b_u_r_p_e X C f i R P c 5)) (pack_c_b_u_r_p_e X C f i R P c 6) = Phi X C f i R P c.
rewrite <- pack_c_b_u_r_p_e_6_eq2 X C f i R P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_p_e X C f i R P c 1) U.
  rewrite <- pack_c_b_u_r_p_e_1_eq2 X C f i R P c U HU.
  apply iff_refl.
- exact pack_c_b_u_r_p_e_2_eq2 X C f i R P c.
- exact pack_c_b_u_r_p_e_3_eq2 X C f i R P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_p_e X C f i R P c 4) x y.
  rewrite <- pack_c_b_u_r_p_e_4_eq2 X C f i R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_r_p_e X C f i R P c 5) x.
  rewrite <- pack_c_b_u_r_p_e_5_eq2 X C f i R P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_u_r_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' R' P' c = Phi X C f i R P c)
  ->
  unpack_c_b_u_r_p_e_o (pack_c_b_u_r_p_e X C f i R P c) Phi = Phi X C f i R P c.
let Phi X C f i R P c.
assume HPhi.
prove Phi (pack_c_b_u_r_p_e X C f i R P c 0) (decode_c (pack_c_b_u_r_p_e X C f i R P c 1)) (decode_b (pack_c_b_u_r_p_e X C f i R P c 2)) (decode_u (pack_c_b_u_r_p_e X C f i R P c 3)) (decode_r (pack_c_b_u_r_p_e X C f i R P c 4)) (decode_p (pack_c_b_u_r_p_e X C f i R P c 5)) (pack_c_b_u_r_p_e X C f i R P c 6) = Phi X C f i R P c.
rewrite <- pack_c_b_u_r_p_e_0_eq2 X C f i R P c.
prove Phi X (decode_c (pack_c_b_u_r_p_e X C f i R P c 1)) (decode_b (pack_c_b_u_r_p_e X C f i R P c 2)) (decode_u (pack_c_b_u_r_p_e X C f i R P c 3)) (decode_r (pack_c_b_u_r_p_e X C f i R P c 4)) (decode_p (pack_c_b_u_r_p_e X C f i R P c 5)) (pack_c_b_u_r_p_e X C f i R P c 6) = Phi X C f i R P c.
rewrite <- pack_c_b_u_r_p_e_6_eq2 X C f i R P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_p_e X C f i R P c 1) U.
  rewrite <- pack_c_b_u_r_p_e_1_eq2 X C f i R P c U HU.
  apply iff_refl.
- exact pack_c_b_u_r_p_e_2_eq2 X C f i R P c.
- exact pack_c_b_u_r_p_e_3_eq2 X C f i R P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_p_e X C f i R P c 4) x y.
  rewrite <- pack_c_b_u_r_p_e_4_eq2 X C f i R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_r_p_e X C f i R P c 5) x.
  rewrite <- pack_c_b_u_r_p_e_5_eq2 X C f i R P c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_r_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> set := fun X C f i R c d => (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d).

Theorem pack_c_b_u_r_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> X = S 0.
let S X C f i R c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_r_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, X = pack_c_b_u_r_e_e X C f i R c d 0.
let X C f i R c d. apply pack_c_b_u_r_e_e_0_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i R c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_r_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_r_e_e X C f i R c d 1) U.
let X C f i R c d. apply pack_c_b_u_r_e_e_1_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_c_b_u_r_e_e X C f i R c d 2) x y.
let X C f i R c d. apply pack_c_b_u_r_e_e_2_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i R c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_r_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_c_b_u_r_e_e X C f i R c d 3) x.
let X C f i R c d. apply pack_c_b_u_r_e_e_3_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X C f i R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_u_r_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_c_b_u_r_e_e X C f i R c d 4) x y.
let X C f i R c d. apply pack_c_b_u_r_e_e_4_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> c = S 5.
let S X C f i R c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_b_u_r_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, c = pack_c_b_u_r_e_e X C f i R c d 5.
let X C f i R c d. apply pack_c_b_u_r_e_e_5_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_u_r_e_e X C f i R c d -> d = S 6.
let S X C f i R c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_r_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, d = pack_c_b_u_r_e_e X C f i R c d 6.
let X C f i R c d. apply pack_c_b_u_r_e_e_6_eq (pack_c_b_u_r_e_e X C f i R c d) X C f i R c d. reflexivity.
Qed.

Theorem pack_c_b_u_r_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall c c':set, forall d d':set, pack_c_b_u_r_e_e X C f i R c d = pack_c_b_u_r_e_e X' C' f' i' R' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ c = c' /\ d = d'.
let X X' C C' f f' i i' R R' c c' d d'. assume H1.
claim L0: X' = pack_c_b_u_r_e_e X C f i R c d 0.
{ exact pack_c_b_u_r_e_e_0_eq (pack_c_b_u_r_e_e X C f i R c d) X' C' f' i' R' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_r_e_e_0_eq2 X C f i R c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_r_e_e_1_eq2 X C f i R c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_e_e_1_eq2 X' C' f' i' R' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_r_e_e_2_eq2 X C f i R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_e_e_2_eq2 X' C' f' i' R' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_r_e_e_3_eq2 X C f i R c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_e_e_3_eq2 X' C' f' i' R' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_u_r_e_e_4_eq2 X C f i R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_r_e_e_4_eq2 X' C' f' i' R' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_c_b_u_r_e_e_5_eq2 X C f i R c d.
  rewrite H1. symmetry.
  exact pack_c_b_u_r_e_e_5_eq2 X' C' f' i' R' c' d'.
- prove d = d'.
  rewrite pack_c_b_u_r_e_e_6_eq2 X C f i R c d.
  rewrite H1. symmetry.
  exact pack_c_b_u_r_e_e_6_eq2 X' C' f' i' R' c' d'.
Qed.

Theorem pack_c_b_u_r_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_c_b_u_r_e_e X C f i R c d = pack_c_b_u_r_e_e X C' f' i' R' c d.
let X C C' f f' i i' R R' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_r X R,c,d) = (X,encode_c X C',encode_b X f',encode_u X i',encode_r X R',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_b_u_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_b_u_r_e_e X C f i R c d)) -> q S.

Theorem pack_struct_c_b_u_r_e_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_b_u_r_e_e (pack_c_b_u_r_e_e X C f i R c d).
let X C f. assume Hf. let i. assume Hi. let R c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C f Hf i Hi R c Hc d Hd.
Qed.

Theorem pack_struct_c_b_u_r_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_c_b_u_r_e_e (pack_c_b_u_r_e_e X C f i R c d) -> forall x y :e X, f x y :e X.
let X C f i R c d. assume H1. apply H1 (fun z => z = pack_c_b_u_r_e_e X C f i R c d -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_r_e_e X' C' f' i' R' c' d' = pack_c_b_u_r_e_e X C f i R c d.
  apply pack_c_b_u_r_e_e_inj X' X C' C f' f i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_e_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_c_b_u_r_e_e (pack_c_b_u_r_e_e X C f i R c d) -> forall x :e X, i x :e X.
let X C f i R c d. assume H1. apply H1 (fun z => z = pack_c_b_u_r_e_e X C f i R c d -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_r_e_e X' C' f' i' R' c' d' = pack_c_b_u_r_e_e X C f i R c d.
  apply pack_c_b_u_r_e_e_inj X' X C' C f' f i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_c_b_u_r_e_e (pack_c_b_u_r_e_e X C f i R c d) -> c :e X.
let X C f i R c d. assume H1. apply H1 (fun z => z = pack_c_b_u_r_e_e X C f i R c d -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_r_e_e X' C' f' i' R' c' d' = pack_c_b_u_r_e_e X C f i R c d.
  apply pack_c_b_u_r_e_e_inj X' X C' C f' f i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_r_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_c_b_u_r_e_e (pack_c_b_u_r_e_e X C f i R c d) -> d :e X.
let X C f i R c d. assume H1. apply H1 (fun z => z = pack_c_b_u_r_e_e X C f i R c d -> d :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_r_e_e X' C' f' i' R' c' d' = pack_c_b_u_r_e_e X C f i R c d.
  apply pack_c_b_u_r_e_e_inj X' X C' C f' f i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_b_u_r_e_e_eta: forall S, struct_c_b_u_r_e_e S -> S = pack_c_b_u_r_e_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_r_e_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let C. let f. assume _. let i. assume _. let R. let c. assume _. let d. assume _.
prove pack_c_b_u_r_e_e X C f i R c d = pack_c_b_u_r_e_e (pack_c_b_u_r_e_e X C f i R c d 0) (decode_c (pack_c_b_u_r_e_e X C f i R c d 1)) (decode_b (pack_c_b_u_r_e_e X C f i R c d 2)) (decode_u (pack_c_b_u_r_e_e X C f i R c d 3)) (decode_r (pack_c_b_u_r_e_e X C f i R c d 4)) (pack_c_b_u_r_e_e X C f i R c d 5) (pack_c_b_u_r_e_e X C f i R c d 6).
rewrite <- pack_c_b_u_r_e_e_0_eq2 X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_5_eq2 X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_6_eq2 X C f i R c d.
apply pack_c_b_u_r_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_r_e_e_1_eq2 X C f i R c d U HU.
  apply iff_refl.
- exact pack_c_b_u_r_e_e_2_eq2 X C f i R c d.
- exact pack_c_b_u_r_e_e_3_eq2 X C f i R c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_u_r_e_e_4_eq2 X C f i R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_c_b_u_r_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C' f' i' R' c d = Phi X C f i R c d)
  ->
  unpack_c_b_u_r_e_e_i (pack_c_b_u_r_e_e X C f i R c d) Phi = Phi X C f i R c d.
let Phi X C f i R c d.
assume HPhi.
prove Phi (pack_c_b_u_r_e_e X C f i R c d 0) (decode_c (pack_c_b_u_r_e_e X C f i R c d 1)) (decode_b (pack_c_b_u_r_e_e X C f i R c d 2)) (decode_u (pack_c_b_u_r_e_e X C f i R c d 3)) (decode_r (pack_c_b_u_r_e_e X C f i R c d 4)) (pack_c_b_u_r_e_e X C f i R c d 5) (pack_c_b_u_r_e_e X C f i R c d 6) = Phi X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_0_eq2 X C f i R c d.
prove Phi X (decode_c (pack_c_b_u_r_e_e X C f i R c d 1)) (decode_b (pack_c_b_u_r_e_e X C f i R c d 2)) (decode_u (pack_c_b_u_r_e_e X C f i R c d 3)) (decode_r (pack_c_b_u_r_e_e X C f i R c d 4)) (pack_c_b_u_r_e_e X C f i R c d 5) (pack_c_b_u_r_e_e X C f i R c d 6) = Phi X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_5_eq2 X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_6_eq2 X C f i R c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_e_e X C f i R c d 1) U.
  rewrite <- pack_c_b_u_r_e_e_1_eq2 X C f i R c d U HU.
  apply iff_refl.
- exact pack_c_b_u_r_e_e_2_eq2 X C f i R c d.
- exact pack_c_b_u_r_e_e_3_eq2 X C f i R c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_e_e X C f i R c d 4) x y.
  rewrite <- pack_c_b_u_r_e_e_4_eq2 X C f i R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_r_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_c_b_u_r_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C' f' i' R' c d = Phi X C f i R c d)
  ->
  unpack_c_b_u_r_e_e_o (pack_c_b_u_r_e_e X C f i R c d) Phi = Phi X C f i R c d.
let Phi X C f i R c d.
assume HPhi.
prove Phi (pack_c_b_u_r_e_e X C f i R c d 0) (decode_c (pack_c_b_u_r_e_e X C f i R c d 1)) (decode_b (pack_c_b_u_r_e_e X C f i R c d 2)) (decode_u (pack_c_b_u_r_e_e X C f i R c d 3)) (decode_r (pack_c_b_u_r_e_e X C f i R c d 4)) (pack_c_b_u_r_e_e X C f i R c d 5) (pack_c_b_u_r_e_e X C f i R c d 6) = Phi X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_0_eq2 X C f i R c d.
prove Phi X (decode_c (pack_c_b_u_r_e_e X C f i R c d 1)) (decode_b (pack_c_b_u_r_e_e X C f i R c d 2)) (decode_u (pack_c_b_u_r_e_e X C f i R c d 3)) (decode_r (pack_c_b_u_r_e_e X C f i R c d 4)) (pack_c_b_u_r_e_e X C f i R c d 5) (pack_c_b_u_r_e_e X C f i R c d 6) = Phi X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_5_eq2 X C f i R c d.
rewrite <- pack_c_b_u_r_e_e_6_eq2 X C f i R c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_r_e_e X C f i R c d 1) U.
  rewrite <- pack_c_b_u_r_e_e_1_eq2 X C f i R c d U HU.
  apply iff_refl.
- exact pack_c_b_u_r_e_e_2_eq2 X C f i R c d.
- exact pack_c_b_u_r_e_e_3_eq2 X C f i R c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_u_r_e_e X C f i R c d 4) x y.
  rewrite <- pack_c_b_u_r_e_e_4_eq2 X C f i R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_c_b_u_p_p_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set := fun X C f i P Q c => (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c).

Theorem pack_c_b_u_p_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> X = S 0.
let S X C f i P Q c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_p_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_c_b_u_p_p_e X C f i P Q c 0.
let X C f i P Q c. apply pack_c_b_u_p_p_e_0_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i P Q c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_p_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_p_p_e X C f i P Q c 1) U.
let X C f i P Q c. apply pack_c_b_u_p_p_e_1_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_p_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_u_p_p_e X C f i P Q c 2) x y.
let X C f i P Q c. apply pack_c_b_u_p_p_e_2_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_p_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_b_u_p_p_e X C f i P Q c 3) x.
let X C f i P Q c. apply pack_c_b_u_p_p_e_3_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X C f i P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_p_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_b_u_p_p_e X C f i P Q c 4) x.
let X C f i P Q c. apply pack_c_b_u_p_p_e_4_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X C f i P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_b_u_p_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_c_b_u_p_p_e X C f i P Q c 5) x.
let X C f i P Q c. apply pack_c_b_u_p_p_e_5_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_u_p_p_e X C f i P Q c -> c = S 6.
let S X C f i P Q c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_p_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_c_b_u_p_p_e X C f i P Q c 6.
let X C f i P Q c. apply pack_c_b_u_p_p_e_6_eq (pack_c_b_u_p_p_e X C f i P Q c) X C f i P Q c. reflexivity.
Qed.

Theorem pack_c_b_u_p_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_c_b_u_p_p_e X C f i P Q c = pack_c_b_u_p_p_e X' C' f' i' P' Q' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' C C' f f' i i' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_c_b_u_p_p_e X C f i P Q c 0.
{ exact pack_c_b_u_p_p_e_0_eq (pack_c_b_u_p_p_e X C f i P Q c) X' C' f' i' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_p_p_e_0_eq2 X C f i P Q c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_p_p_e_1_eq2 X C f i P Q c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_p_e_1_eq2 X' C' f' i' P' Q' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_p_p_e_2_eq2 X C f i P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_p_e_2_eq2 X' C' f' i' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_p_p_e_3_eq2 X C f i P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_p_e_3_eq2 X' C' f' i' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_p_p_e_4_eq2 X C f i P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_p_e_4_eq2 X' C' f' i' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_b_u_p_p_e_5_eq2 X C f i P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_p_e_5_eq2 X' C' f' i' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_c_b_u_p_p_e_6_eq2 X C f i P Q c.
  rewrite H1. symmetry.
  exact pack_c_b_u_p_p_e_6_eq2 X' C' f' i' P' Q' c'.
Qed.

Theorem pack_c_b_u_p_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_b_u_p_p_e X C f i P Q c = pack_c_b_u_p_p_e X C' f' i' P' Q' c.
let X C C' f f' i i' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c) = (X,encode_c X C',encode_b X f',encode_u X i',encode_p X P',encode_p X Q',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_u_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_c_b_u_p_p_e X C f i P Q c)) -> q S.

Theorem pack_struct_c_b_u_p_p_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_c_b_u_p_p_e (pack_c_b_u_p_p_e X C f i P Q c).
let X C f. assume Hf. let i. assume Hi. let P Q c. assume Hc. let q. assume Hq.
exact Hq X C f Hf i Hi P Q c Hc.
Qed.

Theorem pack_struct_c_b_u_p_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_b_u_p_p_e (pack_c_b_u_p_p_e X C f i P Q c) -> forall x y :e X, f x y :e X.
let X C f i P Q c. assume H1. apply H1 (fun z => z = pack_c_b_u_p_p_e X C f i P Q c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_p_p_e X' C' f' i' P' Q' c' = pack_c_b_u_p_p_e X C f i P Q c.
  apply pack_c_b_u_p_p_e_inj X' X C' C f' f i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_p_p_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_b_u_p_p_e (pack_c_b_u_p_p_e X C f i P Q c) -> forall x :e X, i x :e X.
let X C f i P Q c. assume H1. apply H1 (fun z => z = pack_c_b_u_p_p_e X C f i P Q c -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_p_p_e X' C' f' i' P' Q' c' = pack_c_b_u_p_p_e X C f i P Q c.
  apply pack_c_b_u_p_p_e_inj X' X C' C f' f i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_p_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_b_u_p_p_e (pack_c_b_u_p_p_e X C f i P Q c) -> c :e X.
let X C f i P Q c. assume H1. apply H1 (fun z => z = pack_c_b_u_p_p_e X C f i P Q c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_b_u_p_p_e X' C' f' i' P' Q' c' = pack_c_b_u_p_p_e X C f i P Q c.
  apply pack_c_b_u_p_p_e_inj X' X C' C f' f i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_u_p_p_e_eta: forall S, struct_c_b_u_p_p_e S -> S = pack_c_b_u_p_p_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_p_p_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let f. assume _. let i. assume _. let P. let Q. let c. assume _.
prove pack_c_b_u_p_p_e X C f i P Q c = pack_c_b_u_p_p_e (pack_c_b_u_p_p_e X C f i P Q c 0) (decode_c (pack_c_b_u_p_p_e X C f i P Q c 1)) (decode_b (pack_c_b_u_p_p_e X C f i P Q c 2)) (decode_u (pack_c_b_u_p_p_e X C f i P Q c 3)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 4)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 5)) (pack_c_b_u_p_p_e X C f i P Q c 6).
rewrite <- pack_c_b_u_p_p_e_0_eq2 X C f i P Q c.
rewrite <- pack_c_b_u_p_p_e_6_eq2 X C f i P Q c.
apply pack_c_b_u_p_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_p_p_e_1_eq2 X C f i P Q c U HU.
  apply iff_refl.
- exact pack_c_b_u_p_p_e_2_eq2 X C f i P Q c.
- exact pack_c_b_u_p_p_e_3_eq2 X C f i P Q c.
- let x. assume Hx.
  rewrite <- pack_c_b_u_p_p_e_4_eq2 X C f i P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_u_p_p_e_5_eq2 X C f i P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_p_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_u_p_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' i' P' Q' c = Phi X C f i P Q c)
  ->
  unpack_c_b_u_p_p_e_i (pack_c_b_u_p_p_e X C f i P Q c) Phi = Phi X C f i P Q c.
let Phi X C f i P Q c.
assume HPhi.
prove Phi (pack_c_b_u_p_p_e X C f i P Q c 0) (decode_c (pack_c_b_u_p_p_e X C f i P Q c 1)) (decode_b (pack_c_b_u_p_p_e X C f i P Q c 2)) (decode_u (pack_c_b_u_p_p_e X C f i P Q c 3)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 4)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 5)) (pack_c_b_u_p_p_e X C f i P Q c 6) = Phi X C f i P Q c.
rewrite <- pack_c_b_u_p_p_e_0_eq2 X C f i P Q c.
prove Phi X (decode_c (pack_c_b_u_p_p_e X C f i P Q c 1)) (decode_b (pack_c_b_u_p_p_e X C f i P Q c 2)) (decode_u (pack_c_b_u_p_p_e X C f i P Q c 3)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 4)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 5)) (pack_c_b_u_p_p_e X C f i P Q c 6) = Phi X C f i P Q c.
rewrite <- pack_c_b_u_p_p_e_6_eq2 X C f i P Q c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_p_p_e X C f i P Q c 1) U.
  rewrite <- pack_c_b_u_p_p_e_1_eq2 X C f i P Q c U HU.
  apply iff_refl.
- exact pack_c_b_u_p_p_e_2_eq2 X C f i P Q c.
- exact pack_c_b_u_p_p_e_3_eq2 X C f i P Q c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_p_p_e X C f i P Q c 4) x.
  rewrite <- pack_c_b_u_p_p_e_4_eq2 X C f i P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_u_p_p_e X C f i P Q c 5) x.
  rewrite <- pack_c_b_u_p_p_e_5_eq2 X C f i P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_p_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_u_p_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' i' P' Q' c = Phi X C f i P Q c)
  ->
  unpack_c_b_u_p_p_e_o (pack_c_b_u_p_p_e X C f i P Q c) Phi = Phi X C f i P Q c.
let Phi X C f i P Q c.
assume HPhi.
prove Phi (pack_c_b_u_p_p_e X C f i P Q c 0) (decode_c (pack_c_b_u_p_p_e X C f i P Q c 1)) (decode_b (pack_c_b_u_p_p_e X C f i P Q c 2)) (decode_u (pack_c_b_u_p_p_e X C f i P Q c 3)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 4)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 5)) (pack_c_b_u_p_p_e X C f i P Q c 6) = Phi X C f i P Q c.
rewrite <- pack_c_b_u_p_p_e_0_eq2 X C f i P Q c.
prove Phi X (decode_c (pack_c_b_u_p_p_e X C f i P Q c 1)) (decode_b (pack_c_b_u_p_p_e X C f i P Q c 2)) (decode_u (pack_c_b_u_p_p_e X C f i P Q c 3)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 4)) (decode_p (pack_c_b_u_p_p_e X C f i P Q c 5)) (pack_c_b_u_p_p_e X C f i P Q c 6) = Phi X C f i P Q c.
rewrite <- pack_c_b_u_p_p_e_6_eq2 X C f i P Q c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_p_p_e X C f i P Q c 1) U.
  rewrite <- pack_c_b_u_p_p_e_1_eq2 X C f i P Q c U HU.
  apply iff_refl.
- exact pack_c_b_u_p_p_e_2_eq2 X C f i P Q c.
- exact pack_c_b_u_p_p_e_3_eq2 X C f i P Q c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_p_p_e X C f i P Q c 4) x.
  rewrite <- pack_c_b_u_p_p_e_4_eq2 X C f i P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_u_p_p_e X C f i P Q c 5) x.
  rewrite <- pack_c_b_u_p_p_e_5_eq2 X C f i P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_u_p_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> set := fun X C f i P c d => (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d).

Theorem pack_c_b_u_p_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> X = S 0.
let S X C f i P c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_u_p_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, X = pack_c_b_u_p_e_e X C f i P c d 0.
let X C f i P c d. apply pack_c_b_u_p_e_e_0_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i P c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_u_p_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_u_p_e_e X C f i P c d 1) U.
let X C f i P c d. apply pack_c_b_u_p_e_e_1_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_u_p_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_c_b_u_p_e_e X C f i P c d 2) x y.
let X C f i P c d. apply pack_c_b_u_p_e_e_2_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i P c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_b_u_p_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_c_b_u_p_e_e X C f i P c d 3) x.
let X C f i P c d. apply pack_c_b_u_p_e_e_3_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X C f i P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_u_p_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_c_b_u_p_e_e X C f i P c d 4) x.
let X C f i P c d. apply pack_c_b_u_p_e_e_4_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> c = S 5.
let S X C f i P c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_b_u_p_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, c = pack_c_b_u_p_e_e X C f i P c d 5.
let X C f i P c d. apply pack_c_b_u_p_e_e_5_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_u_p_e_e X C f i P c d -> d = S 6.
let S X C f i P c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_u_p_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, d = pack_c_b_u_p_e_e X C f i P c d 6.
let X C f i P c d. apply pack_c_b_u_p_e_e_6_eq (pack_c_b_u_p_e_e X C f i P c d) X C f i P c d. reflexivity.
Qed.

Theorem pack_c_b_u_p_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall c c':set, forall d d':set, pack_c_b_u_p_e_e X C f i P c d = pack_c_b_u_p_e_e X' C' f' i' P' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' C C' f f' i i' P P' c c' d d'. assume H1.
claim L0: X' = pack_c_b_u_p_e_e X C f i P c d 0.
{ exact pack_c_b_u_p_e_e_0_eq (pack_c_b_u_p_e_e X C f i P c d) X' C' f' i' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_u_p_e_e_0_eq2 X C f i P c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_u_p_e_e_1_eq2 X C f i P c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_e_e_1_eq2 X' C' f' i' P' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_u_p_e_e_2_eq2 X C f i P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_e_e_2_eq2 X' C' f' i' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_b_u_p_e_e_3_eq2 X C f i P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_e_e_3_eq2 X' C' f' i' P' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_u_p_e_e_4_eq2 X C f i P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_u_p_e_e_4_eq2 X' C' f' i' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_b_u_p_e_e_5_eq2 X C f i P c d.
  rewrite H1. symmetry.
  exact pack_c_b_u_p_e_e_5_eq2 X' C' f' i' P' c' d'.
- prove d = d'.
  rewrite pack_c_b_u_p_e_e_6_eq2 X C f i P c d.
  rewrite H1. symmetry.
  exact pack_c_b_u_p_e_e_6_eq2 X' C' f' i' P' c' d'.
Qed.

Theorem pack_c_b_u_p_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_u_p_e_e X C f i P c d = pack_c_b_u_p_e_e X C' f' i' P' c d.
let X C C' f f' i i' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_b X f,encode_u X i,encode_p X P,c,d) = (X,encode_c X C',encode_b X f',encode_u X i',encode_p X P',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_b_u_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_b_u_p_e_e X C f i P c d)) -> q S.

Theorem pack_struct_c_b_u_p_e_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_b_u_p_e_e (pack_c_b_u_p_e_e X C f i P c d).
let X C f. assume Hf. let i. assume Hi. let P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C f Hf i Hi P c Hc d Hd.
Qed.

Theorem pack_struct_c_b_u_p_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_u_p_e_e (pack_c_b_u_p_e_e X C f i P c d) -> forall x y :e X, f x y :e X.
let X C f i P c d. assume H1. apply H1 (fun z => z = pack_c_b_u_p_e_e X C f i P c d -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_p_e_e X' C' f' i' P' c' d' = pack_c_b_u_p_e_e X C f i P c d.
  apply pack_c_b_u_p_e_e_inj X' X C' C f' f i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_p_e_e_E3: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_u_p_e_e (pack_c_b_u_p_e_e X C f i P c d) -> forall x :e X, i x :e X.
let X C f i P c d. assume H1. apply H1 (fun z => z = pack_c_b_u_p_e_e X C f i P c d -> forall x :e X, i x :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_p_e_e X' C' f' i' P' c' d' = pack_c_b_u_p_e_e X C f i P c d.
  apply pack_c_b_u_p_e_e_inj X' X C' C f' f i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_p_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_u_p_e_e (pack_c_b_u_p_e_e X C f i P c d) -> c :e X.
let X C f i P c d. assume H1. apply H1 (fun z => z = pack_c_b_u_p_e_e X C f i P c d -> c :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_p_e_e X' C' f' i' P' c' d' = pack_c_b_u_p_e_e X C f i P c d.
  apply pack_c_b_u_p_e_e_inj X' X C' C f' f i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_b_u_p_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_u_p_e_e (pack_c_b_u_p_e_e X C f i P c d) -> d :e X.
let X C f i P c d. assume H1. apply H1 (fun z => z = pack_c_b_u_p_e_e X C f i P c d -> d :e X).
- let X'. let C'. let f'. assume Hf'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_u_p_e_e X' C' f' i' P' c' d' = pack_c_b_u_p_e_e X C f i P c d.
  apply pack_c_b_u_p_e_e_inj X' X C' C f' f i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_b_u_p_e_e_eta: forall S, struct_c_b_u_p_e_e S -> S = pack_c_b_u_p_e_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_u_p_e_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let C. let f. assume _. let i. assume _. let P. let c. assume _. let d. assume _.
prove pack_c_b_u_p_e_e X C f i P c d = pack_c_b_u_p_e_e (pack_c_b_u_p_e_e X C f i P c d 0) (decode_c (pack_c_b_u_p_e_e X C f i P c d 1)) (decode_b (pack_c_b_u_p_e_e X C f i P c d 2)) (decode_u (pack_c_b_u_p_e_e X C f i P c d 3)) (decode_p (pack_c_b_u_p_e_e X C f i P c d 4)) (pack_c_b_u_p_e_e X C f i P c d 5) (pack_c_b_u_p_e_e X C f i P c d 6).
rewrite <- pack_c_b_u_p_e_e_0_eq2 X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_5_eq2 X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_6_eq2 X C f i P c d.
apply pack_c_b_u_p_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_u_p_e_e_1_eq2 X C f i P c d U HU.
  apply iff_refl.
- exact pack_c_b_u_p_e_e_2_eq2 X C f i P c d.
- exact pack_c_b_u_p_e_e_3_eq2 X C f i P c d.
- let x. assume Hx.
  rewrite <- pack_c_b_u_p_e_e_4_eq2 X C f i P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_p_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_b_u_p_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' P' c d = Phi X C f i P c d)
  ->
  unpack_c_b_u_p_e_e_i (pack_c_b_u_p_e_e X C f i P c d) Phi = Phi X C f i P c d.
let Phi X C f i P c d.
assume HPhi.
prove Phi (pack_c_b_u_p_e_e X C f i P c d 0) (decode_c (pack_c_b_u_p_e_e X C f i P c d 1)) (decode_b (pack_c_b_u_p_e_e X C f i P c d 2)) (decode_u (pack_c_b_u_p_e_e X C f i P c d 3)) (decode_p (pack_c_b_u_p_e_e X C f i P c d 4)) (pack_c_b_u_p_e_e X C f i P c d 5) (pack_c_b_u_p_e_e X C f i P c d 6) = Phi X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_0_eq2 X C f i P c d.
prove Phi X (decode_c (pack_c_b_u_p_e_e X C f i P c d 1)) (decode_b (pack_c_b_u_p_e_e X C f i P c d 2)) (decode_u (pack_c_b_u_p_e_e X C f i P c d 3)) (decode_p (pack_c_b_u_p_e_e X C f i P c d 4)) (pack_c_b_u_p_e_e X C f i P c d 5) (pack_c_b_u_p_e_e X C f i P c d 6) = Phi X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_5_eq2 X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_6_eq2 X C f i P c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_p_e_e X C f i P c d 1) U.
  rewrite <- pack_c_b_u_p_e_e_1_eq2 X C f i P c d U HU.
  apply iff_refl.
- exact pack_c_b_u_p_e_e_2_eq2 X C f i P c d.
- exact pack_c_b_u_p_e_e_3_eq2 X C f i P c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_p_e_e X C f i P c d 4) x.
  rewrite <- pack_c_b_u_p_e_e_4_eq2 X C f i P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_u_p_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_b_u_p_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' i' P' c d = Phi X C f i P c d)
  ->
  unpack_c_b_u_p_e_e_o (pack_c_b_u_p_e_e X C f i P c d) Phi = Phi X C f i P c d.
let Phi X C f i P c d.
assume HPhi.
prove Phi (pack_c_b_u_p_e_e X C f i P c d 0) (decode_c (pack_c_b_u_p_e_e X C f i P c d 1)) (decode_b (pack_c_b_u_p_e_e X C f i P c d 2)) (decode_u (pack_c_b_u_p_e_e X C f i P c d 3)) (decode_p (pack_c_b_u_p_e_e X C f i P c d 4)) (pack_c_b_u_p_e_e X C f i P c d 5) (pack_c_b_u_p_e_e X C f i P c d 6) = Phi X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_0_eq2 X C f i P c d.
prove Phi X (decode_c (pack_c_b_u_p_e_e X C f i P c d 1)) (decode_b (pack_c_b_u_p_e_e X C f i P c d 2)) (decode_u (pack_c_b_u_p_e_e X C f i P c d 3)) (decode_p (pack_c_b_u_p_e_e X C f i P c d 4)) (pack_c_b_u_p_e_e X C f i P c d 5) (pack_c_b_u_p_e_e X C f i P c d 6) = Phi X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_5_eq2 X C f i P c d.
rewrite <- pack_c_b_u_p_e_e_6_eq2 X C f i P c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_u_p_e_e X C f i P c d 1) U.
  rewrite <- pack_c_b_u_p_e_e_1_eq2 X C f i P c d U HU.
  apply iff_refl.
- exact pack_c_b_u_p_e_e_2_eq2 X C f i P c d.
- exact pack_c_b_u_p_e_e_3_eq2 X C f i P c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_u_p_e_e X C f i P c d 4) x.
  rewrite <- pack_c_b_u_p_e_e_4_eq2 X C f i P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_r_r_p_p : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X C f R T P Q => (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q).

Theorem pack_c_b_r_r_p_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> X = S 0.
let S X C f R T P Q. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_r_r_p_p_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_c_b_r_r_p_p X C f R T P Q 0.
let X C f R T P Q. apply pack_c_b_r_r_p_p_0_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f R T P Q. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_r_r_p_p_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_r_r_p_p X C f R T P Q 1) U.
let X C f R T P Q. apply pack_c_b_r_r_p_p_1_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_p_p_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_c_b_r_r_p_p X C f R T P Q 2) x y.
let X C f R T P Q. apply pack_c_b_r_r_p_p_2_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C f R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_p_p_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_c_b_r_r_p_p X C f R T P Q 3) x y.
let X C f R T P Q. apply pack_c_b_r_r_p_p_3_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X C f R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_p_p_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, T x y = decode_r (pack_c_b_r_r_p_p X C f R T P Q 4) x y.
let X C f R T P Q. apply pack_c_b_r_r_p_p_4_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X C f R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_r_r_p_p_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_c_b_r_r_p_p X C f R T P Q 5) x.
let X C f R T P Q. apply pack_c_b_r_r_p_p_5_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_b_r_r_p_p X C f R T P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X C f R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_b_r_r_p_p_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_c_b_r_r_p_p X C f R T P Q 6) x.
let X C f R T P Q. apply pack_c_b_r_r_p_p_6_eq (pack_c_b_r_r_p_p X C f R T P Q) X C f R T P Q. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_p_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_c_b_r_r_p_p X C f R T P Q = pack_c_b_r_r_p_p X' C' f' R' T' P' Q' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' C C' f f' R R' T T' P P' Q Q'. assume H1.
claim L0: X' = pack_c_b_r_r_p_p X C f R T P Q 0.
{ exact pack_c_b_r_r_p_p_0_eq (pack_c_b_r_r_p_p X C f R T P Q) X' C' f' R' T' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_r_r_p_p_0_eq2 X C f R T P Q. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_r_r_p_p_1_eq2 X C f R T P Q U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_p_1_eq2 X' C' f' R' T' P' Q' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_r_r_p_p_2_eq2 X C f R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_p_2_eq2 X' C' f' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_r_r_p_p_3_eq2 X C f R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_p_3_eq2 X' C' f' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_b_r_r_p_p_4_eq2 X C f R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_p_4_eq2 X' C' f' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_r_r_p_p_5_eq2 X C f R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_p_5_eq2 X' C' f' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_b_r_r_p_p_6_eq2 X C f R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_p_6_eq2 X' C' f' R' T' P' Q' x Lx.
Qed.

Theorem pack_c_b_r_r_p_p_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_b_r_r_p_p X C f R T P Q = pack_c_b_r_r_p_p X C' f' R' T' P' Q'.
let X C C' f f' R R' T T' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) = (X,encode_c X C',encode_b X f',encode_r X R',encode_r X T',encode_p X P',encode_p X Q').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_b_r_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_c_b_r_r_p_p X C f R T P Q)) -> q S.

Theorem pack_struct_c_b_r_r_p_p_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_b_r_r_p_p (pack_c_b_r_r_p_p X C f R T P Q).
let X C f. assume Hf. let R T P Q q. assume Hq.
exact Hq X C f Hf R T P Q.
Qed.

Theorem pack_struct_c_b_r_r_p_p_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_b_r_r_p_p (pack_c_b_r_r_p_p X C f R T P Q) -> forall x y :e X, f x y :e X.
let X C f R T P Q. assume H1. apply H1 (fun z => z = pack_c_b_r_r_p_p X C f R T P Q -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_c_b_r_r_p_p X' C' f' R' T' P' Q' = pack_c_b_r_r_p_p X C f R T P Q.
  apply pack_c_b_r_r_p_p_inj X' X C' C f' f R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem struct_c_b_r_r_p_p_eta: forall S, struct_c_b_r_r_p_p S -> S = pack_c_b_r_r_p_p (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_b_r_r_p_p (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let C. let f. assume _. let R. let T. let P. let Q.
prove pack_c_b_r_r_p_p X C f R T P Q = pack_c_b_r_r_p_p (pack_c_b_r_r_p_p X C f R T P Q 0) (decode_c (pack_c_b_r_r_p_p X C f R T P Q 1)) (decode_b (pack_c_b_r_r_p_p X C f R T P Q 2)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 3)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 4)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 5)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 6)).
rewrite <- pack_c_b_r_r_p_p_0_eq2 X C f R T P Q.
apply pack_c_b_r_r_p_p_ext.
- let U. assume HU.
  rewrite <- pack_c_b_r_r_p_p_1_eq2 X C f R T P Q U HU.
  apply iff_refl.
- exact pack_c_b_r_r_p_p_2_eq2 X C f R T P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_r_p_p_3_eq2 X C f R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_r_p_p_4_eq2 X C f R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_r_r_p_p_5_eq2 X C f R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_r_r_p_p_6_eq2 X C f R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_r_p_p_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_r_r_p_p_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' R' T' P' Q' = Phi X C f R T P Q)
  ->
  unpack_c_b_r_r_p_p_i (pack_c_b_r_r_p_p X C f R T P Q) Phi = Phi X C f R T P Q.
let Phi X C f R T P Q.
assume HPhi.
prove Phi (pack_c_b_r_r_p_p X C f R T P Q 0) (decode_c (pack_c_b_r_r_p_p X C f R T P Q 1)) (decode_b (pack_c_b_r_r_p_p X C f R T P Q 2)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 3)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 4)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 5)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 6)) = Phi X C f R T P Q.
rewrite <- pack_c_b_r_r_p_p_0_eq2 X C f R T P Q.
prove Phi X (decode_c (pack_c_b_r_r_p_p X C f R T P Q 1)) (decode_b (pack_c_b_r_r_p_p X C f R T P Q 2)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 3)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 4)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 5)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 6)) = Phi X C f R T P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_r_p_p X C f R T P Q 1) U.
  rewrite <- pack_c_b_r_r_p_p_1_eq2 X C f R T P Q U HU.
  apply iff_refl.
- exact pack_c_b_r_r_p_p_2_eq2 X C f R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_r_p_p X C f R T P Q 3) x y.
  rewrite <- pack_c_b_r_r_p_p_3_eq2 X C f R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_r_r_p_p X C f R T P Q 4) x y.
  rewrite <- pack_c_b_r_r_p_p_4_eq2 X C f R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_r_p_p X C f R T P Q 5) x.
  rewrite <- pack_c_b_r_r_p_p_5_eq2 X C f R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_r_r_p_p X C f R T P Q 6) x.
  rewrite <- pack_c_b_r_r_p_p_6_eq2 X C f R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_r_p_p_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_b_r_r_p_p_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' R' T' P' Q' = Phi X C f R T P Q)
  ->
  unpack_c_b_r_r_p_p_o (pack_c_b_r_r_p_p X C f R T P Q) Phi = Phi X C f R T P Q.
let Phi X C f R T P Q.
assume HPhi.
prove Phi (pack_c_b_r_r_p_p X C f R T P Q 0) (decode_c (pack_c_b_r_r_p_p X C f R T P Q 1)) (decode_b (pack_c_b_r_r_p_p X C f R T P Q 2)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 3)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 4)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 5)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 6)) = Phi X C f R T P Q.
rewrite <- pack_c_b_r_r_p_p_0_eq2 X C f R T P Q.
prove Phi X (decode_c (pack_c_b_r_r_p_p X C f R T P Q 1)) (decode_b (pack_c_b_r_r_p_p X C f R T P Q 2)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 3)) (decode_r (pack_c_b_r_r_p_p X C f R T P Q 4)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 5)) (decode_p (pack_c_b_r_r_p_p X C f R T P Q 6)) = Phi X C f R T P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_r_p_p X C f R T P Q 1) U.
  rewrite <- pack_c_b_r_r_p_p_1_eq2 X C f R T P Q U HU.
  apply iff_refl.
- exact pack_c_b_r_r_p_p_2_eq2 X C f R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_r_p_p X C f R T P Q 3) x y.
  rewrite <- pack_c_b_r_r_p_p_3_eq2 X C f R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_r_r_p_p X C f R T P Q 4) x y.
  rewrite <- pack_c_b_r_r_p_p_4_eq2 X C f R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_r_p_p X C f R T P Q 5) x.
  rewrite <- pack_c_b_r_r_p_p_5_eq2 X C f R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_r_r_p_p X C f R T P Q 6) x.
  rewrite <- pack_c_b_r_r_p_p_6_eq2 X C f R T P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_r_r_p_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X C f R T P c => (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c).

Theorem pack_c_b_r_r_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> X = S 0.
let S X C f R T P c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_r_r_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_c_b_r_r_p_e X C f R T P c 0.
let X C f R T P c. apply pack_c_b_r_r_p_e_0_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f R T P c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_r_r_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_r_r_p_e X C f R T P c 1) U.
let X C f R T P c. apply pack_c_b_r_r_p_e_1_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_r_r_p_e X C f R T P c 2) x y.
let X C f R T P c. apply pack_c_b_r_r_p_e_2_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C f R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_b_r_r_p_e X C f R T P c 3) x y.
let X C f R T P c. apply pack_c_b_r_r_p_e_3_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X C f R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_c_b_r_r_p_e X C f R T P c 4) x y.
let X C f R T P c. apply pack_c_b_r_r_p_e_4_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> forall x :e X, P x = decode_p (S 5) x.
let S X C f R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_r_r_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_b_r_r_p_e X C f R T P c 5) x.
let X C f R T P c. apply pack_c_b_r_r_p_e_5_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_b_r_r_p_e X C f R T P c -> c = S 6.
let S X C f R T P c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_r_r_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_c_b_r_r_p_e X C f R T P c 6.
let X C f R T P c. apply pack_c_b_r_r_p_e_6_eq (pack_c_b_r_r_p_e X C f R T P c) X C f R T P c. reflexivity.
Qed.

Theorem pack_c_b_r_r_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_c_b_r_r_p_e X C f R T P c = pack_c_b_r_r_p_e X' C' f' R' T' P' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' C C' f f' R R' T T' P P' c c'. assume H1.
claim L0: X' = pack_c_b_r_r_p_e X C f R T P c 0.
{ exact pack_c_b_r_r_p_e_0_eq (pack_c_b_r_r_p_e X C f R T P c) X' C' f' R' T' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_r_r_p_e_0_eq2 X C f R T P c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_r_r_p_e_1_eq2 X C f R T P c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_e_1_eq2 X' C' f' R' T' P' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_r_r_p_e_2_eq2 X C f R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_e_2_eq2 X' C' f' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_r_r_p_e_3_eq2 X C f R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_e_3_eq2 X' C' f' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_b_r_r_p_e_4_eq2 X C f R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_e_4_eq2 X' C' f' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_r_r_p_e_5_eq2 X C f R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_e_5_eq2 X' C' f' R' T' P' c' x Lx.
- prove c = c'.
  rewrite pack_c_b_r_r_p_e_6_eq2 X C f R T P c.
  rewrite H1. symmetry.
  exact pack_c_b_r_r_p_e_6_eq2 X' C' f' R' T' P' c'.
Qed.

Theorem pack_c_b_r_r_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_r_r_p_e X C f R T P c = pack_c_b_r_r_p_e X C' f' R' T' P' c.
let X C C' f f' R R' T T' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,encode_p X P,c) = (X,encode_c X C',encode_b X f',encode_r X R',encode_r X T',encode_p X P',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_r_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_c_b_r_r_p_e X C f R T P c)) -> q S.

Theorem pack_struct_c_b_r_r_p_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_c_b_r_r_p_e (pack_c_b_r_r_p_e X C f R T P c).
let X C f. assume Hf. let R T P c. assume Hc. let q. assume Hq.
exact Hq X C f Hf R T P c Hc.
Qed.

Theorem pack_struct_c_b_r_r_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_b_r_r_p_e (pack_c_b_r_r_p_e X C f R T P c) -> forall x y :e X, f x y :e X.
let X C f R T P c. assume H1. apply H1 (fun z => z = pack_c_b_r_r_p_e X C f R T P c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_r_r_p_e X' C' f' R' T' P' c' = pack_c_b_r_r_p_e X C f R T P c.
  apply pack_c_b_r_r_p_e_inj X' X C' C f' f R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_r_r_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_b_r_r_p_e (pack_c_b_r_r_p_e X C f R T P c) -> c :e X.
let X C f R T P c. assume H1. apply H1 (fun z => z = pack_c_b_r_r_p_e X C f R T P c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_b_r_r_p_e X' C' f' R' T' P' c' = pack_c_b_r_r_p_e X C f R T P c.
  apply pack_c_b_r_r_p_e_inj X' X C' C f' f R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_r_r_p_e_eta: forall S, struct_c_b_r_r_p_e S -> S = pack_c_b_r_r_p_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_r_r_p_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let f. assume _. let R. let T. let P. let c. assume _.
prove pack_c_b_r_r_p_e X C f R T P c = pack_c_b_r_r_p_e (pack_c_b_r_r_p_e X C f R T P c 0) (decode_c (pack_c_b_r_r_p_e X C f R T P c 1)) (decode_b (pack_c_b_r_r_p_e X C f R T P c 2)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 3)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 4)) (decode_p (pack_c_b_r_r_p_e X C f R T P c 5)) (pack_c_b_r_r_p_e X C f R T P c 6).
rewrite <- pack_c_b_r_r_p_e_0_eq2 X C f R T P c.
rewrite <- pack_c_b_r_r_p_e_6_eq2 X C f R T P c.
apply pack_c_b_r_r_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_r_r_p_e_1_eq2 X C f R T P c U HU.
  apply iff_refl.
- exact pack_c_b_r_r_p_e_2_eq2 X C f R T P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_r_p_e_3_eq2 X C f R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_r_p_e_4_eq2 X C f R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_r_r_p_e_5_eq2 X C f R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_r_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_r_r_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' R' T' P' c = Phi X C f R T P c)
  ->
  unpack_c_b_r_r_p_e_i (pack_c_b_r_r_p_e X C f R T P c) Phi = Phi X C f R T P c.
let Phi X C f R T P c.
assume HPhi.
prove Phi (pack_c_b_r_r_p_e X C f R T P c 0) (decode_c (pack_c_b_r_r_p_e X C f R T P c 1)) (decode_b (pack_c_b_r_r_p_e X C f R T P c 2)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 3)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 4)) (decode_p (pack_c_b_r_r_p_e X C f R T P c 5)) (pack_c_b_r_r_p_e X C f R T P c 6) = Phi X C f R T P c.
rewrite <- pack_c_b_r_r_p_e_0_eq2 X C f R T P c.
prove Phi X (decode_c (pack_c_b_r_r_p_e X C f R T P c 1)) (decode_b (pack_c_b_r_r_p_e X C f R T P c 2)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 3)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 4)) (decode_p (pack_c_b_r_r_p_e X C f R T P c 5)) (pack_c_b_r_r_p_e X C f R T P c 6) = Phi X C f R T P c.
rewrite <- pack_c_b_r_r_p_e_6_eq2 X C f R T P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_r_p_e X C f R T P c 1) U.
  rewrite <- pack_c_b_r_r_p_e_1_eq2 X C f R T P c U HU.
  apply iff_refl.
- exact pack_c_b_r_r_p_e_2_eq2 X C f R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_r_p_e X C f R T P c 3) x y.
  rewrite <- pack_c_b_r_r_p_e_3_eq2 X C f R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_r_r_p_e X C f R T P c 4) x y.
  rewrite <- pack_c_b_r_r_p_e_4_eq2 X C f R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_r_p_e X C f R T P c 5) x.
  rewrite <- pack_c_b_r_r_p_e_5_eq2 X C f R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_r_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_r_r_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' R' T' P' c = Phi X C f R T P c)
  ->
  unpack_c_b_r_r_p_e_o (pack_c_b_r_r_p_e X C f R T P c) Phi = Phi X C f R T P c.
let Phi X C f R T P c.
assume HPhi.
prove Phi (pack_c_b_r_r_p_e X C f R T P c 0) (decode_c (pack_c_b_r_r_p_e X C f R T P c 1)) (decode_b (pack_c_b_r_r_p_e X C f R T P c 2)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 3)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 4)) (decode_p (pack_c_b_r_r_p_e X C f R T P c 5)) (pack_c_b_r_r_p_e X C f R T P c 6) = Phi X C f R T P c.
rewrite <- pack_c_b_r_r_p_e_0_eq2 X C f R T P c.
prove Phi X (decode_c (pack_c_b_r_r_p_e X C f R T P c 1)) (decode_b (pack_c_b_r_r_p_e X C f R T P c 2)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 3)) (decode_r (pack_c_b_r_r_p_e X C f R T P c 4)) (decode_p (pack_c_b_r_r_p_e X C f R T P c 5)) (pack_c_b_r_r_p_e X C f R T P c 6) = Phi X C f R T P c.
rewrite <- pack_c_b_r_r_p_e_6_eq2 X C f R T P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_r_p_e X C f R T P c 1) U.
  rewrite <- pack_c_b_r_r_p_e_1_eq2 X C f R T P c U HU.
  apply iff_refl.
- exact pack_c_b_r_r_p_e_2_eq2 X C f R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_r_p_e X C f R T P c 3) x y.
  rewrite <- pack_c_b_r_r_p_e_3_eq2 X C f R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_r_r_p_e X C f R T P c 4) x y.
  rewrite <- pack_c_b_r_r_p_e_4_eq2 X C f R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_r_p_e X C f R T P c 5) x.
  rewrite <- pack_c_b_r_r_p_e_5_eq2 X C f R T P c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_r_r_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set := fun X C f R T c d => (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d).

Theorem pack_c_b_r_r_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> X = S 0.
let S X C f R T c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_r_r_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, X = pack_c_b_r_r_e_e X C f R T c d 0.
let X C f R T c d. apply pack_c_b_r_r_e_e_0_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f R T c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_r_r_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_r_r_e_e X C f R T c d 1) U.
let X C f R T c d. apply pack_c_b_r_r_e_e_1_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_c_b_r_r_e_e X C f R T c d 2) x y.
let X C f R T c d. apply pack_c_b_r_r_e_e_2_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C f R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_c_b_r_r_e_e X C f R T c d 3) x y.
let X C f R T c d. apply pack_c_b_r_r_e_e_3_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X C f R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_b_r_r_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, T x y = decode_r (pack_c_b_r_r_e_e X C f R T c d 4) x y.
let X C f R T c d. apply pack_c_b_r_r_e_e_4_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> c = S 5.
let S X C f R T c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_b_r_r_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, c = pack_c_b_r_r_e_e X C f R T c d 5.
let X C f R T c d. apply pack_c_b_r_r_e_e_5_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_b_r_r_e_e X C f R T c d -> d = S 6.
let S X C f R T c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_r_r_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, d = pack_c_b_r_r_e_e X C f R T c d 6.
let X C f R T c d. apply pack_c_b_r_r_e_e_6_eq (pack_c_b_r_r_e_e X C f R T c d) X C f R T c d. reflexivity.
Qed.

Theorem pack_c_b_r_r_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, forall d d':set, pack_c_b_r_r_e_e X C f R T c d = pack_c_b_r_r_e_e X' C' f' R' T' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c' /\ d = d'.
let X X' C C' f f' R R' T T' c c' d d'. assume H1.
claim L0: X' = pack_c_b_r_r_e_e X C f R T c d 0.
{ exact pack_c_b_r_r_e_e_0_eq (pack_c_b_r_r_e_e X C f R T c d) X' C' f' R' T' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_r_r_e_e_0_eq2 X C f R T c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_r_r_e_e_1_eq2 X C f R T c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_e_e_1_eq2 X' C' f' R' T' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_r_r_e_e_2_eq2 X C f R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_e_e_2_eq2 X' C' f' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_r_r_e_e_3_eq2 X C f R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_e_e_3_eq2 X' C' f' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_b_r_r_e_e_4_eq2 X C f R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_r_e_e_4_eq2 X' C' f' R' T' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_c_b_r_r_e_e_5_eq2 X C f R T c d.
  rewrite H1. symmetry.
  exact pack_c_b_r_r_e_e_5_eq2 X' C' f' R' T' c' d'.
- prove d = d'.
  rewrite pack_c_b_r_r_e_e_6_eq2 X C f R T c d.
  rewrite H1. symmetry.
  exact pack_c_b_r_r_e_e_6_eq2 X' C' f' R' T' c' d'.
Qed.

Theorem pack_c_b_r_r_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_c_b_r_r_e_e X C f R T c d = pack_c_b_r_r_e_e X C' f' R' T' c d.
let X C C' f f' R R' T T' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_b X f,encode_r X R,encode_r X T,c,d) = (X,encode_c X C',encode_b X f',encode_r X R',encode_r X T',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_b_r_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_b_r_r_e_e X C f R T c d)) -> q S.

Theorem pack_struct_c_b_r_r_e_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_b_r_r_e_e (pack_c_b_r_r_e_e X C f R T c d).
let X C f. assume Hf. let R T c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C f Hf R T c Hc d Hd.
Qed.

Theorem pack_struct_c_b_r_r_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_c_b_r_r_e_e (pack_c_b_r_r_e_e X C f R T c d) -> forall x y :e X, f x y :e X.
let X C f R T c d. assume H1. apply H1 (fun z => z = pack_c_b_r_r_e_e X C f R T c d -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_r_r_e_e X' C' f' R' T' c' d' = pack_c_b_r_r_e_e X C f R T c d.
  apply pack_c_b_r_r_e_e_inj X' X C' C f' f R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_r_r_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_c_b_r_r_e_e (pack_c_b_r_r_e_e X C f R T c d) -> c :e X.
let X C f R T c d. assume H1. apply H1 (fun z => z = pack_c_b_r_r_e_e X C f R T c d -> c :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_r_r_e_e X' C' f' R' T' c' d' = pack_c_b_r_r_e_e X C f R T c d.
  apply pack_c_b_r_r_e_e_inj X' X C' C f' f R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_b_r_r_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_c_b_r_r_e_e (pack_c_b_r_r_e_e X C f R T c d) -> d :e X.
let X C f R T c d. assume H1. apply H1 (fun z => z = pack_c_b_r_r_e_e X C f R T c d -> d :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_r_r_e_e X' C' f' R' T' c' d' = pack_c_b_r_r_e_e X C f R T c d.
  apply pack_c_b_r_r_e_e_inj X' X C' C f' f R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_b_r_r_e_e_eta: forall S, struct_c_b_r_r_e_e S -> S = pack_c_b_r_r_e_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_r_r_e_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let C. let f. assume _. let R. let T. let c. assume _. let d. assume _.
prove pack_c_b_r_r_e_e X C f R T c d = pack_c_b_r_r_e_e (pack_c_b_r_r_e_e X C f R T c d 0) (decode_c (pack_c_b_r_r_e_e X C f R T c d 1)) (decode_b (pack_c_b_r_r_e_e X C f R T c d 2)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 3)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 4)) (pack_c_b_r_r_e_e X C f R T c d 5) (pack_c_b_r_r_e_e X C f R T c d 6).
rewrite <- pack_c_b_r_r_e_e_0_eq2 X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_5_eq2 X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_6_eq2 X C f R T c d.
apply pack_c_b_r_r_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_r_r_e_e_1_eq2 X C f R T c d U HU.
  apply iff_refl.
- exact pack_c_b_r_r_e_e_2_eq2 X C f R T c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_r_e_e_3_eq2 X C f R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_r_e_e_4_eq2 X C f R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_r_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_c_b_r_r_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' f' R' T' c d = Phi X C f R T c d)
  ->
  unpack_c_b_r_r_e_e_i (pack_c_b_r_r_e_e X C f R T c d) Phi = Phi X C f R T c d.
let Phi X C f R T c d.
assume HPhi.
prove Phi (pack_c_b_r_r_e_e X C f R T c d 0) (decode_c (pack_c_b_r_r_e_e X C f R T c d 1)) (decode_b (pack_c_b_r_r_e_e X C f R T c d 2)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 3)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 4)) (pack_c_b_r_r_e_e X C f R T c d 5) (pack_c_b_r_r_e_e X C f R T c d 6) = Phi X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_0_eq2 X C f R T c d.
prove Phi X (decode_c (pack_c_b_r_r_e_e X C f R T c d 1)) (decode_b (pack_c_b_r_r_e_e X C f R T c d 2)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 3)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 4)) (pack_c_b_r_r_e_e X C f R T c d 5) (pack_c_b_r_r_e_e X C f R T c d 6) = Phi X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_5_eq2 X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_6_eq2 X C f R T c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_r_e_e X C f R T c d 1) U.
  rewrite <- pack_c_b_r_r_e_e_1_eq2 X C f R T c d U HU.
  apply iff_refl.
- exact pack_c_b_r_r_e_e_2_eq2 X C f R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_r_e_e X C f R T c d 3) x y.
  rewrite <- pack_c_b_r_r_e_e_3_eq2 X C f R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_r_r_e_e X C f R T c d 4) x y.
  rewrite <- pack_c_b_r_r_e_e_4_eq2 X C f R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_r_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_c_b_r_r_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' f' R' T' c d = Phi X C f R T c d)
  ->
  unpack_c_b_r_r_e_e_o (pack_c_b_r_r_e_e X C f R T c d) Phi = Phi X C f R T c d.
let Phi X C f R T c d.
assume HPhi.
prove Phi (pack_c_b_r_r_e_e X C f R T c d 0) (decode_c (pack_c_b_r_r_e_e X C f R T c d 1)) (decode_b (pack_c_b_r_r_e_e X C f R T c d 2)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 3)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 4)) (pack_c_b_r_r_e_e X C f R T c d 5) (pack_c_b_r_r_e_e X C f R T c d 6) = Phi X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_0_eq2 X C f R T c d.
prove Phi X (decode_c (pack_c_b_r_r_e_e X C f R T c d 1)) (decode_b (pack_c_b_r_r_e_e X C f R T c d 2)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 3)) (decode_r (pack_c_b_r_r_e_e X C f R T c d 4)) (pack_c_b_r_r_e_e X C f R T c d 5) (pack_c_b_r_r_e_e X C f R T c d 6) = Phi X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_5_eq2 X C f R T c d.
rewrite <- pack_c_b_r_r_e_e_6_eq2 X C f R T c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_r_e_e X C f R T c d 1) U.
  rewrite <- pack_c_b_r_r_e_e_1_eq2 X C f R T c d U HU.
  apply iff_refl.
- exact pack_c_b_r_r_e_e_2_eq2 X C f R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_r_e_e X C f R T c d 3) x y.
  rewrite <- pack_c_b_r_r_e_e_3_eq2 X C f R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_b_r_r_e_e X C f R T c d 4) x y.
  rewrite <- pack_c_b_r_r_e_e_4_eq2 X C f R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_c_b_r_p_p_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set := fun X C f R P Q c => (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c).

Theorem pack_c_b_r_p_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> X = S 0.
let S X C f R P Q c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_r_p_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_c_b_r_p_p_e X C f R P Q c 0.
let X C f R P Q c. apply pack_c_b_r_p_p_e_0_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f R P Q c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_r_p_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_r_p_p_e X C f R P Q c 1) U.
let X C f R P Q c. apply pack_c_b_r_p_p_e_1_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_r_p_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_c_b_r_p_p_e X C f R P Q c 2) x y.
let X C f R P Q c. apply pack_c_b_r_p_p_e_2_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C f R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_r_p_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_b_r_p_p_e X C f R P Q c 3) x y.
let X C f R P Q c. apply pack_c_b_r_p_p_e_3_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X C f R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_r_p_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_b_r_p_p_e X C f R P Q c 4) x.
let X C f R P Q c. apply pack_c_b_r_p_p_e_4_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X C f R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_b_r_p_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_c_b_r_p_p_e X C f R P Q c 5) x.
let X C f R P Q c. apply pack_c_b_r_p_p_e_5_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_b_r_p_p_e X C f R P Q c -> c = S 6.
let S X C f R P Q c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_r_p_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_c_b_r_p_p_e X C f R P Q c 6.
let X C f R P Q c. apply pack_c_b_r_p_p_e_6_eq (pack_c_b_r_p_p_e X C f R P Q c) X C f R P Q c. reflexivity.
Qed.

Theorem pack_c_b_r_p_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_c_b_r_p_p_e X C f R P Q c = pack_c_b_r_p_p_e X' C' f' R' P' Q' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' C C' f f' R R' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_c_b_r_p_p_e X C f R P Q c 0.
{ exact pack_c_b_r_p_p_e_0_eq (pack_c_b_r_p_p_e X C f R P Q c) X' C' f' R' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_r_p_p_e_0_eq2 X C f R P Q c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_r_p_p_e_1_eq2 X C f R P Q c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_p_e_1_eq2 X' C' f' R' P' Q' c' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_r_p_p_e_2_eq2 X C f R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_p_e_2_eq2 X' C' f' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_r_p_p_e_3_eq2 X C f R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_p_e_3_eq2 X' C' f' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_r_p_p_e_4_eq2 X C f R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_p_e_4_eq2 X' C' f' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_b_r_p_p_e_5_eq2 X C f R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_p_e_5_eq2 X' C' f' R' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_c_b_r_p_p_e_6_eq2 X C f R P Q c.
  rewrite H1. symmetry.
  exact pack_c_b_r_p_p_e_6_eq2 X' C' f' R' P' Q' c'.
Qed.

Theorem pack_c_b_r_p_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_b_r_p_p_e X C f R P Q c = pack_c_b_r_p_p_e X C' f' R' P' Q' c.
let X C C' f f' R R' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c) = (X,encode_c X C',encode_b X f',encode_r X R',encode_p X P',encode_p X Q',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_b_r_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_c_b_r_p_p_e X C f R P Q c)) -> q S.

Theorem pack_struct_c_b_r_p_p_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_c_b_r_p_p_e (pack_c_b_r_p_p_e X C f R P Q c).
let X C f. assume Hf. let R P Q c. assume Hc. let q. assume Hq.
exact Hq X C f Hf R P Q c Hc.
Qed.

Theorem pack_struct_c_b_r_p_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_b_r_p_p_e (pack_c_b_r_p_p_e X C f R P Q c) -> forall x y :e X, f x y :e X.
let X C f R P Q c. assume H1. apply H1 (fun z => z = pack_c_b_r_p_p_e X C f R P Q c -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_b_r_p_p_e X' C' f' R' P' Q' c' = pack_c_b_r_p_p_e X C f R P Q c.
  apply pack_c_b_r_p_p_e_inj X' X C' C f' f R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_r_p_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_b_r_p_p_e (pack_c_b_r_p_p_e X C f R P Q c) -> c :e X.
let X C f R P Q c. assume H1. apply H1 (fun z => z = pack_c_b_r_p_p_e X C f R P Q c -> c :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_b_r_p_p_e X' C' f' R' P' Q' c' = pack_c_b_r_p_p_e X C f R P Q c.
  apply pack_c_b_r_p_p_e_inj X' X C' C f' f R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_b_r_p_p_e_eta: forall S, struct_c_b_r_p_p_e S -> S = pack_c_b_r_p_p_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_r_p_p_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let f. assume _. let R. let P. let Q. let c. assume _.
prove pack_c_b_r_p_p_e X C f R P Q c = pack_c_b_r_p_p_e (pack_c_b_r_p_p_e X C f R P Q c 0) (decode_c (pack_c_b_r_p_p_e X C f R P Q c 1)) (decode_b (pack_c_b_r_p_p_e X C f R P Q c 2)) (decode_r (pack_c_b_r_p_p_e X C f R P Q c 3)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 4)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 5)) (pack_c_b_r_p_p_e X C f R P Q c 6).
rewrite <- pack_c_b_r_p_p_e_0_eq2 X C f R P Q c.
rewrite <- pack_c_b_r_p_p_e_6_eq2 X C f R P Q c.
apply pack_c_b_r_p_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_r_p_p_e_1_eq2 X C f R P Q c U HU.
  apply iff_refl.
- exact pack_c_b_r_p_p_e_2_eq2 X C f R P Q c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_p_p_e_3_eq2 X C f R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_r_p_p_e_4_eq2 X C f R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_r_p_p_e_5_eq2 X C f R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_p_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_r_p_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' R' P' Q' c = Phi X C f R P Q c)
  ->
  unpack_c_b_r_p_p_e_i (pack_c_b_r_p_p_e X C f R P Q c) Phi = Phi X C f R P Q c.
let Phi X C f R P Q c.
assume HPhi.
prove Phi (pack_c_b_r_p_p_e X C f R P Q c 0) (decode_c (pack_c_b_r_p_p_e X C f R P Q c 1)) (decode_b (pack_c_b_r_p_p_e X C f R P Q c 2)) (decode_r (pack_c_b_r_p_p_e X C f R P Q c 3)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 4)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 5)) (pack_c_b_r_p_p_e X C f R P Q c 6) = Phi X C f R P Q c.
rewrite <- pack_c_b_r_p_p_e_0_eq2 X C f R P Q c.
prove Phi X (decode_c (pack_c_b_r_p_p_e X C f R P Q c 1)) (decode_b (pack_c_b_r_p_p_e X C f R P Q c 2)) (decode_r (pack_c_b_r_p_p_e X C f R P Q c 3)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 4)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 5)) (pack_c_b_r_p_p_e X C f R P Q c 6) = Phi X C f R P Q c.
rewrite <- pack_c_b_r_p_p_e_6_eq2 X C f R P Q c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_p_p_e X C f R P Q c 1) U.
  rewrite <- pack_c_b_r_p_p_e_1_eq2 X C f R P Q c U HU.
  apply iff_refl.
- exact pack_c_b_r_p_p_e_2_eq2 X C f R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_p_p_e X C f R P Q c 3) x y.
  rewrite <- pack_c_b_r_p_p_e_3_eq2 X C f R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_p_p_e X C f R P Q c 4) x.
  rewrite <- pack_c_b_r_p_p_e_4_eq2 X C f R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_r_p_p_e X C f R P Q c 5) x.
  rewrite <- pack_c_b_r_p_p_e_5_eq2 X C f R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_p_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_b_r_p_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' R' P' Q' c = Phi X C f R P Q c)
  ->
  unpack_c_b_r_p_p_e_o (pack_c_b_r_p_p_e X C f R P Q c) Phi = Phi X C f R P Q c.
let Phi X C f R P Q c.
assume HPhi.
prove Phi (pack_c_b_r_p_p_e X C f R P Q c 0) (decode_c (pack_c_b_r_p_p_e X C f R P Q c 1)) (decode_b (pack_c_b_r_p_p_e X C f R P Q c 2)) (decode_r (pack_c_b_r_p_p_e X C f R P Q c 3)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 4)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 5)) (pack_c_b_r_p_p_e X C f R P Q c 6) = Phi X C f R P Q c.
rewrite <- pack_c_b_r_p_p_e_0_eq2 X C f R P Q c.
prove Phi X (decode_c (pack_c_b_r_p_p_e X C f R P Q c 1)) (decode_b (pack_c_b_r_p_p_e X C f R P Q c 2)) (decode_r (pack_c_b_r_p_p_e X C f R P Q c 3)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 4)) (decode_p (pack_c_b_r_p_p_e X C f R P Q c 5)) (pack_c_b_r_p_p_e X C f R P Q c 6) = Phi X C f R P Q c.
rewrite <- pack_c_b_r_p_p_e_6_eq2 X C f R P Q c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_p_p_e X C f R P Q c 1) U.
  rewrite <- pack_c_b_r_p_p_e_1_eq2 X C f R P Q c U HU.
  apply iff_refl.
- exact pack_c_b_r_p_p_e_2_eq2 X C f R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_p_p_e X C f R P Q c 3) x y.
  rewrite <- pack_c_b_r_p_p_e_3_eq2 X C f R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_p_p_e X C f R P Q c 4) x.
  rewrite <- pack_c_b_r_p_p_e_4_eq2 X C f R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_r_p_p_e X C f R P Q c 5) x.
  rewrite <- pack_c_b_r_p_p_e_5_eq2 X C f R P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_r_p_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set := fun X C f R P c d => (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d).

Theorem pack_c_b_r_p_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> X = S 0.
let S X C f R P c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_r_p_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, X = pack_c_b_r_p_e_e X C f R P c d 0.
let X C f R P c d. apply pack_c_b_r_p_e_e_0_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f R P c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_r_p_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_r_p_e_e X C f R P c d 1) U.
let X C f R P c d. apply pack_c_b_r_p_e_e_1_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_r_p_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_c_b_r_p_e_e X C f R P c d 2) x y.
let X C f R P c d. apply pack_c_b_r_p_e_e_2_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C f R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_b_r_p_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_c_b_r_p_e_e X C f R P c d 3) x y.
let X C f R P c d. apply pack_c_b_r_p_e_e_3_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X C f R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_r_p_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_c_b_r_p_e_e X C f R P c d 4) x.
let X C f R P c d. apply pack_c_b_r_p_e_e_4_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> c = S 5.
let S X C f R P c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_b_r_p_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, c = pack_c_b_r_p_e_e X C f R P c d 5.
let X C f R P c d. apply pack_c_b_r_p_e_e_5_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_b_r_p_e_e X C f R P c d -> d = S 6.
let S X C f R P c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_r_p_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, d = pack_c_b_r_p_e_e X C f R P c d 6.
let X C f R P c d. apply pack_c_b_r_p_e_e_6_eq (pack_c_b_r_p_e_e X C f R P c d) X C f R P c d. reflexivity.
Qed.

Theorem pack_c_b_r_p_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, forall d d':set, pack_c_b_r_p_e_e X C f R P c d = pack_c_b_r_p_e_e X' C' f' R' P' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' C C' f f' R R' P P' c c' d d'. assume H1.
claim L0: X' = pack_c_b_r_p_e_e X C f R P c d 0.
{ exact pack_c_b_r_p_e_e_0_eq (pack_c_b_r_p_e_e X C f R P c d) X' C' f' R' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_r_p_e_e_0_eq2 X C f R P c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_r_p_e_e_1_eq2 X C f R P c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_e_e_1_eq2 X' C' f' R' P' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_r_p_e_e_2_eq2 X C f R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_e_e_2_eq2 X' C' f' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_b_r_p_e_e_3_eq2 X C f R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_e_e_3_eq2 X' C' f' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_r_p_e_e_4_eq2 X C f R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_r_p_e_e_4_eq2 X' C' f' R' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_b_r_p_e_e_5_eq2 X C f R P c d.
  rewrite H1. symmetry.
  exact pack_c_b_r_p_e_e_5_eq2 X' C' f' R' P' c' d'.
- prove d = d'.
  rewrite pack_c_b_r_p_e_e_6_eq2 X C f R P c d.
  rewrite H1. symmetry.
  exact pack_c_b_r_p_e_e_6_eq2 X' C' f' R' P' c' d'.
Qed.

Theorem pack_c_b_r_p_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_r_p_e_e X C f R P c d = pack_c_b_r_p_e_e X C' f' R' P' c d.
let X C C' f f' R R' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_b X f,encode_r X R,encode_p X P,c,d) = (X,encode_c X C',encode_b X f',encode_r X R',encode_p X P',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_b_r_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_b_r_p_e_e X C f R P c d)) -> q S.

Theorem pack_struct_c_b_r_p_e_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_b_r_p_e_e (pack_c_b_r_p_e_e X C f R P c d).
let X C f. assume Hf. let R P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C f Hf R P c Hc d Hd.
Qed.

Theorem pack_struct_c_b_r_p_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_r_p_e_e (pack_c_b_r_p_e_e X C f R P c d) -> forall x y :e X, f x y :e X.
let X C f R P c d. assume H1. apply H1 (fun z => z = pack_c_b_r_p_e_e X C f R P c d -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_r_p_e_e X' C' f' R' P' c' d' = pack_c_b_r_p_e_e X C f R P c d.
  apply pack_c_b_r_p_e_e_inj X' X C' C f' f R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_r_p_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_r_p_e_e (pack_c_b_r_p_e_e X C f R P c d) -> c :e X.
let X C f R P c d. assume H1. apply H1 (fun z => z = pack_c_b_r_p_e_e X C f R P c d -> c :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_r_p_e_e X' C' f' R' P' c' d' = pack_c_b_r_p_e_e X C f R P c d.
  apply pack_c_b_r_p_e_e_inj X' X C' C f' f R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_b_r_p_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_c_b_r_p_e_e (pack_c_b_r_p_e_e X C f R P c d) -> d :e X.
let X C f R P c d. assume H1. apply H1 (fun z => z = pack_c_b_r_p_e_e X C f R P c d -> d :e X).
- let X'. let C'. let f'. assume Hf'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_r_p_e_e X' C' f' R' P' c' d' = pack_c_b_r_p_e_e X C f R P c d.
  apply pack_c_b_r_p_e_e_inj X' X C' C f' f R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_b_r_p_e_e_eta: forall S, struct_c_b_r_p_e_e S -> S = pack_c_b_r_p_e_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_r_p_e_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let C. let f. assume _. let R. let P. let c. assume _. let d. assume _.
prove pack_c_b_r_p_e_e X C f R P c d = pack_c_b_r_p_e_e (pack_c_b_r_p_e_e X C f R P c d 0) (decode_c (pack_c_b_r_p_e_e X C f R P c d 1)) (decode_b (pack_c_b_r_p_e_e X C f R P c d 2)) (decode_r (pack_c_b_r_p_e_e X C f R P c d 3)) (decode_p (pack_c_b_r_p_e_e X C f R P c d 4)) (pack_c_b_r_p_e_e X C f R P c d 5) (pack_c_b_r_p_e_e X C f R P c d 6).
rewrite <- pack_c_b_r_p_e_e_0_eq2 X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_5_eq2 X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_6_eq2 X C f R P c d.
apply pack_c_b_r_p_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_r_p_e_e_1_eq2 X C f R P c d U HU.
  apply iff_refl.
- exact pack_c_b_r_p_e_e_2_eq2 X C f R P c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_b_r_p_e_e_3_eq2 X C f R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_r_p_e_e_4_eq2 X C f R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_p_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_b_r_p_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' R' P' c d = Phi X C f R P c d)
  ->
  unpack_c_b_r_p_e_e_i (pack_c_b_r_p_e_e X C f R P c d) Phi = Phi X C f R P c d.
let Phi X C f R P c d.
assume HPhi.
prove Phi (pack_c_b_r_p_e_e X C f R P c d 0) (decode_c (pack_c_b_r_p_e_e X C f R P c d 1)) (decode_b (pack_c_b_r_p_e_e X C f R P c d 2)) (decode_r (pack_c_b_r_p_e_e X C f R P c d 3)) (decode_p (pack_c_b_r_p_e_e X C f R P c d 4)) (pack_c_b_r_p_e_e X C f R P c d 5) (pack_c_b_r_p_e_e X C f R P c d 6) = Phi X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_0_eq2 X C f R P c d.
prove Phi X (decode_c (pack_c_b_r_p_e_e X C f R P c d 1)) (decode_b (pack_c_b_r_p_e_e X C f R P c d 2)) (decode_r (pack_c_b_r_p_e_e X C f R P c d 3)) (decode_p (pack_c_b_r_p_e_e X C f R P c d 4)) (pack_c_b_r_p_e_e X C f R P c d 5) (pack_c_b_r_p_e_e X C f R P c d 6) = Phi X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_5_eq2 X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_6_eq2 X C f R P c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_p_e_e X C f R P c d 1) U.
  rewrite <- pack_c_b_r_p_e_e_1_eq2 X C f R P c d U HU.
  apply iff_refl.
- exact pack_c_b_r_p_e_e_2_eq2 X C f R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_p_e_e X C f R P c d 3) x y.
  rewrite <- pack_c_b_r_p_e_e_3_eq2 X C f R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_p_e_e X C f R P c d 4) x.
  rewrite <- pack_c_b_r_p_e_e_4_eq2 X C f R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_r_p_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_b_r_p_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' f' R' P' c d = Phi X C f R P c d)
  ->
  unpack_c_b_r_p_e_e_o (pack_c_b_r_p_e_e X C f R P c d) Phi = Phi X C f R P c d.
let Phi X C f R P c d.
assume HPhi.
prove Phi (pack_c_b_r_p_e_e X C f R P c d 0) (decode_c (pack_c_b_r_p_e_e X C f R P c d 1)) (decode_b (pack_c_b_r_p_e_e X C f R P c d 2)) (decode_r (pack_c_b_r_p_e_e X C f R P c d 3)) (decode_p (pack_c_b_r_p_e_e X C f R P c d 4)) (pack_c_b_r_p_e_e X C f R P c d 5) (pack_c_b_r_p_e_e X C f R P c d 6) = Phi X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_0_eq2 X C f R P c d.
prove Phi X (decode_c (pack_c_b_r_p_e_e X C f R P c d 1)) (decode_b (pack_c_b_r_p_e_e X C f R P c d 2)) (decode_r (pack_c_b_r_p_e_e X C f R P c d 3)) (decode_p (pack_c_b_r_p_e_e X C f R P c d 4)) (pack_c_b_r_p_e_e X C f R P c d 5) (pack_c_b_r_p_e_e X C f R P c d 6) = Phi X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_5_eq2 X C f R P c d.
rewrite <- pack_c_b_r_p_e_e_6_eq2 X C f R P c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_r_p_e_e X C f R P c d 1) U.
  rewrite <- pack_c_b_r_p_e_e_1_eq2 X C f R P c d U HU.
  apply iff_refl.
- exact pack_c_b_r_p_e_e_2_eq2 X C f R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_b_r_p_e_e X C f R P c d 3) x y.
  rewrite <- pack_c_b_r_p_e_e_3_eq2 X C f R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_r_p_e_e X C f R P c d 4) x.
  rewrite <- pack_c_b_r_p_e_e_4_eq2 X C f R P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_c_b_p_p_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X C f P Q c d => (X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d).

Theorem pack_c_b_p_p_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> X = S 0.
let S X C f P Q c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_b_p_p_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_c_b_p_p_e_e X C f P Q c d 0.
let X C f P Q c d. apply pack_c_b_p_p_e_e_0_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f P Q c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_b_p_p_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_b_p_p_e_e X C f P Q c d 1) U.
let X C f P Q c d. apply pack_c_b_p_p_e_e_1_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_c_b_p_p_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_c_b_p_p_e_e X C f P Q c d 2) x y.
let X C f P Q c d. apply pack_c_b_p_p_e_e_2_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X C f P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_b_p_p_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_c_b_p_p_e_e X C f P Q c d 3) x.
let X C f P Q c d. apply pack_c_b_p_p_e_e_3_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X C f P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_b_p_p_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_c_b_p_p_e_e X C f P Q c d 4) x.
let X C f P Q c d. apply pack_c_b_p_p_e_e_4_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> c = S 5.
let S X C f P Q c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_b_p_p_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_c_b_p_p_e_e X C f P Q c d 5.
let X C f P Q c d. apply pack_c_b_p_p_e_e_5_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_b_p_p_e_e X C f P Q c d -> d = S 6.
let S X C f P Q c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_b_p_p_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_c_b_p_p_e_e X C f P Q c d 6.
let X C f P Q c d. apply pack_c_b_p_p_e_e_6_eq (pack_c_b_p_p_e_e X C f P Q c d) X C f P Q c d. reflexivity.
Qed.

Theorem pack_c_b_p_p_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_c_b_p_p_e_e X C f P Q c d = pack_c_b_p_p_e_e X' C' f' P' Q' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' C C' f f' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_c_b_p_p_e_e X C f P Q c d 0.
{ exact pack_c_b_p_p_e_e_0_eq (pack_c_b_p_p_e_e X C f P Q c d) X' C' f' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_b_p_p_e_e_0_eq2 X C f P Q c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_b_p_p_e_e_1_eq2 X C f P Q c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_b_p_p_e_e_1_eq2 X' C' f' P' Q' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_c_b_p_p_e_e_2_eq2 X C f P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_b_p_p_e_e_2_eq2 X' C' f' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_b_p_p_e_e_3_eq2 X C f P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_p_p_e_e_3_eq2 X' C' f' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_b_p_p_e_e_4_eq2 X C f P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_b_p_p_e_e_4_eq2 X' C' f' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_b_p_p_e_e_5_eq2 X C f P Q c d.
  rewrite H1. symmetry.
  exact pack_c_b_p_p_e_e_5_eq2 X' C' f' P' Q' c' d'.
- prove d = d'.
  rewrite pack_c_b_p_p_e_e_6_eq2 X C f P Q c d.
  rewrite H1. symmetry.
  exact pack_c_b_p_p_e_e_6_eq2 X' C' f' P' Q' c' d'.
Qed.

Theorem pack_c_b_p_p_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_b_p_p_e_e X C f P Q c d = pack_c_b_p_p_e_e X C' f' P' Q' c d.
let X C C' f f' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_b X f,encode_p X P,encode_p X Q,c,d) = (X,encode_c X C',encode_b X f',encode_p X P',encode_p X Q',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_b_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_b_p_p_e_e X C f P Q c d)) -> q S.

Theorem pack_struct_c_b_p_p_e_e_I: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_b_p_p_e_e (pack_c_b_p_p_e_e X C f P Q c d).
let X C f. assume Hf. let P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C f Hf P Q c Hc d Hd.
Qed.

Theorem pack_struct_c_b_p_p_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_b_p_p_e_e (pack_c_b_p_p_e_e X C f P Q c d) -> forall x y :e X, f x y :e X.
let X C f P Q c d. assume H1. apply H1 (fun z => z = pack_c_b_p_p_e_e X C f P Q c d -> forall x y :e X, f x y :e X).
- let X'. let C'. let f'. assume Hf'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_p_p_e_e X' C' f' P' Q' c' d' = pack_c_b_p_p_e_e X C f P Q c d.
  apply pack_c_b_p_p_e_e_inj X' X C' C f' f P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_c_b_p_p_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_b_p_p_e_e (pack_c_b_p_p_e_e X C f P Q c d) -> c :e X.
let X C f P Q c d. assume H1. apply H1 (fun z => z = pack_c_b_p_p_e_e X C f P Q c d -> c :e X).
- let X'. let C'. let f'. assume Hf'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_p_p_e_e X' C' f' P' Q' c' d' = pack_c_b_p_p_e_e X C f P Q c d.
  apply pack_c_b_p_p_e_e_inj X' X C' C f' f P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_b_p_p_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_b_p_p_e_e (pack_c_b_p_p_e_e X C f P Q c d) -> d :e X.
let X C f P Q c d. assume H1. apply H1 (fun z => z = pack_c_b_p_p_e_e X C f P Q c d -> d :e X).
- let X'. let C'. let f'. assume Hf'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_b_p_p_e_e X' C' f' P' Q' c' d' = pack_c_b_p_p_e_e X C f P Q c d.
  apply pack_c_b_p_p_e_e_inj X' X C' C f' f P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hf'f HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_b_p_p_e_e_eta: forall S, struct_c_b_p_p_e_e S -> S = pack_c_b_p_p_e_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_b_p_p_e_e (z 0) (decode_c (z 1)) (decode_b (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let C. let f. assume _. let P. let Q. let c. assume _. let d. assume _.
prove pack_c_b_p_p_e_e X C f P Q c d = pack_c_b_p_p_e_e (pack_c_b_p_p_e_e X C f P Q c d 0) (decode_c (pack_c_b_p_p_e_e X C f P Q c d 1)) (decode_b (pack_c_b_p_p_e_e X C f P Q c d 2)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 3)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 4)) (pack_c_b_p_p_e_e X C f P Q c d 5) (pack_c_b_p_p_e_e X C f P Q c d 6).
rewrite <- pack_c_b_p_p_e_e_0_eq2 X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_5_eq2 X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_6_eq2 X C f P Q c d.
apply pack_c_b_p_p_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_b_p_p_e_e_1_eq2 X C f P Q c d U HU.
  apply iff_refl.
- exact pack_c_b_p_p_e_e_2_eq2 X C f P Q c d.
- let x. assume Hx.
  rewrite <- pack_c_b_p_p_e_e_3_eq2 X C f P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_b_p_p_e_e_4_eq2 X C f P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_p_p_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_b_p_p_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' P' Q' c d = Phi X C f P Q c d)
  ->
  unpack_c_b_p_p_e_e_i (pack_c_b_p_p_e_e X C f P Q c d) Phi = Phi X C f P Q c d.
let Phi X C f P Q c d.
assume HPhi.
prove Phi (pack_c_b_p_p_e_e X C f P Q c d 0) (decode_c (pack_c_b_p_p_e_e X C f P Q c d 1)) (decode_b (pack_c_b_p_p_e_e X C f P Q c d 2)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 3)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 4)) (pack_c_b_p_p_e_e X C f P Q c d 5) (pack_c_b_p_p_e_e X C f P Q c d 6) = Phi X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_0_eq2 X C f P Q c d.
prove Phi X (decode_c (pack_c_b_p_p_e_e X C f P Q c d 1)) (decode_b (pack_c_b_p_p_e_e X C f P Q c d 2)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 3)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 4)) (pack_c_b_p_p_e_e X C f P Q c d 5) (pack_c_b_p_p_e_e X C f P Q c d 6) = Phi X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_5_eq2 X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_6_eq2 X C f P Q c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_p_p_e_e X C f P Q c d 1) U.
  rewrite <- pack_c_b_p_p_e_e_1_eq2 X C f P Q c d U HU.
  apply iff_refl.
- exact pack_c_b_p_p_e_e_2_eq2 X C f P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_p_p_e_e X C f P Q c d 3) x.
  rewrite <- pack_c_b_p_p_e_e_3_eq2 X C f P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_p_p_e_e X C f P Q c d 4) x.
  rewrite <- pack_c_b_p_p_e_e_4_eq2 X C f P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_b_p_p_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_b_p_p_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' f' P' Q' c d = Phi X C f P Q c d)
  ->
  unpack_c_b_p_p_e_e_o (pack_c_b_p_p_e_e X C f P Q c d) Phi = Phi X C f P Q c d.
let Phi X C f P Q c d.
assume HPhi.
prove Phi (pack_c_b_p_p_e_e X C f P Q c d 0) (decode_c (pack_c_b_p_p_e_e X C f P Q c d 1)) (decode_b (pack_c_b_p_p_e_e X C f P Q c d 2)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 3)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 4)) (pack_c_b_p_p_e_e X C f P Q c d 5) (pack_c_b_p_p_e_e X C f P Q c d 6) = Phi X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_0_eq2 X C f P Q c d.
prove Phi X (decode_c (pack_c_b_p_p_e_e X C f P Q c d 1)) (decode_b (pack_c_b_p_p_e_e X C f P Q c d 2)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 3)) (decode_p (pack_c_b_p_p_e_e X C f P Q c d 4)) (pack_c_b_p_p_e_e X C f P Q c d 5) (pack_c_b_p_p_e_e X C f P Q c d 6) = Phi X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_5_eq2 X C f P Q c d.
rewrite <- pack_c_b_p_p_e_e_6_eq2 X C f P Q c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_b_p_p_e_e X C f P Q c d 1) U.
  rewrite <- pack_c_b_p_p_e_e_1_eq2 X C f P Q c d U HU.
  apply iff_refl.
- exact pack_c_b_p_p_e_e_2_eq2 X C f P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_b_p_p_e_e X C f P Q c d 3) x.
  rewrite <- pack_c_b_p_p_e_e_3_eq2 X C f P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_b_p_p_e_e X C f P Q c d 4) x.
  rewrite <- pack_c_b_p_p_e_e_4_eq2 X C f P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_c_u_r_r_p_p : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X C i R T P Q => (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q).

Theorem pack_c_u_r_r_p_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> X = S 0.
let S X C i R T P Q. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_u_r_r_p_p_0_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_c_u_r_r_p_p X C i R T P Q 0.
let X C i R T P Q. apply pack_c_u_r_r_p_p_0_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i R T P Q. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_u_r_r_p_p_1_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_u_r_r_p_p X C i R T P Q 1) U.
let X C i R T P Q. apply pack_c_u_r_r_p_p_1_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> forall x :e X, i x = decode_u (S 2) x.
let S X C i R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_u_r_r_p_p_2_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_c_u_r_r_p_p X C i R T P Q 2) x.
let X C i R T P Q. apply pack_c_u_r_r_p_p_2_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C i R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_u_r_r_p_p_3_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_c_u_r_r_p_p X C i R T P Q 3) x y.
let X C i R T P Q. apply pack_c_u_r_r_p_p_3_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_4_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X C i R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_u_r_r_p_p_4_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, T x y = decode_r (pack_c_u_r_r_p_p X C i R T P Q 4) x y.
let X C i R T P Q. apply pack_c_u_r_r_p_p_4_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_5_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X C i R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_u_r_r_p_p_5_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_c_u_r_r_p_p X C i R T P Q 5) x.
let X C i R T P Q. apply pack_c_u_r_r_p_p_5_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_6_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_c_u_r_r_p_p X C i R T P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X C i R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_u_r_r_p_p_6_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_c_u_r_r_p_p X C i R T P Q 6) x.
let X C i R T P Q. apply pack_c_u_r_r_p_p_6_eq (pack_c_u_r_r_p_p X C i R T P Q) X C i R T P Q. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_p_inj : forall X X', forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_c_u_r_r_p_p X C i R T P Q = pack_c_u_r_r_p_p X' C' i' R' T' P' Q' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' C C' i i' R R' T T' P P' Q Q'. assume H1.
claim L0: X' = pack_c_u_r_r_p_p X C i R T P Q 0.
{ exact pack_c_u_r_r_p_p_0_eq (pack_c_u_r_r_p_p X C i R T P Q) X' C' i' R' T' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_u_r_r_p_p_0_eq2 X C i R T P Q. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_u_r_r_p_p_1_eq2 X C i R T P Q U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_p_1_eq2 X' C' i' R' T' P' Q' U LU.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_u_r_r_p_p_2_eq2 X C i R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_p_2_eq2 X' C' i' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_u_r_r_p_p_3_eq2 X C i R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_p_3_eq2 X' C' i' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_u_r_r_p_p_4_eq2 X C i R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_p_4_eq2 X' C' i' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_u_r_r_p_p_5_eq2 X C i R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_p_5_eq2 X' C' i' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_u_r_r_p_p_6_eq2 X C i R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_p_6_eq2 X' C' i' R' T' P' Q' x Lx.
Qed.

Theorem pack_c_u_r_r_p_p_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_u_r_r_p_p X C i R T P Q = pack_c_u_r_r_p_p X C' i' R' T' P' Q'.
let X C C' i i' R R' T T' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) = (X,encode_c X C',encode_u X i',encode_r X R',encode_r X T',encode_p X P',encode_p X Q').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_c_u_r_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_c_u_r_r_p_p X C i R T P Q)) -> q S.

Theorem pack_struct_c_u_r_r_p_p_I: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_u_r_r_p_p (pack_c_u_r_r_p_p X C i R T P Q).
let X C i. assume Hi. let R T P Q q. assume Hq.
exact Hq X C i Hi R T P Q.
Qed.

Theorem pack_struct_c_u_r_r_p_p_E2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_c_u_r_r_p_p (pack_c_u_r_r_p_p X C i R T P Q) -> forall x :e X, i x :e X.
let X C i R T P Q. assume H1. apply H1 (fun z => z = pack_c_u_r_r_p_p X C i R T P Q -> forall x :e X, i x :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_c_u_r_r_p_p X' C' i' R' T' P' Q' = pack_c_u_r_r_p_p X C i R T P Q.
  apply pack_c_u_r_r_p_p_inj X' X C' C i' i R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_c_u_r_r_p_p_eta: forall S, struct_c_u_r_r_p_p S -> S = pack_c_u_r_r_p_p (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_c_u_r_r_p_p (z 0) (decode_c (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let C. let i. assume _. let R. let T. let P. let Q.
prove pack_c_u_r_r_p_p X C i R T P Q = pack_c_u_r_r_p_p (pack_c_u_r_r_p_p X C i R T P Q 0) (decode_c (pack_c_u_r_r_p_p X C i R T P Q 1)) (decode_u (pack_c_u_r_r_p_p X C i R T P Q 2)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 3)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 4)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 5)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 6)).
rewrite <- pack_c_u_r_r_p_p_0_eq2 X C i R T P Q.
apply pack_c_u_r_r_p_p_ext.
- let U. assume HU.
  rewrite <- pack_c_u_r_r_p_p_1_eq2 X C i R T P Q U HU.
  apply iff_refl.
- exact pack_c_u_r_r_p_p_2_eq2 X C i R T P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_r_p_p_3_eq2 X C i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_r_p_p_4_eq2 X C i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_r_r_p_p_5_eq2 X C i R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_r_r_p_p_6_eq2 X C i R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_r_p_p_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_u_r_r_p_p_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' i' R' T' P' Q' = Phi X C i R T P Q)
  ->
  unpack_c_u_r_r_p_p_i (pack_c_u_r_r_p_p X C i R T P Q) Phi = Phi X C i R T P Q.
let Phi X C i R T P Q.
assume HPhi.
prove Phi (pack_c_u_r_r_p_p X C i R T P Q 0) (decode_c (pack_c_u_r_r_p_p X C i R T P Q 1)) (decode_u (pack_c_u_r_r_p_p X C i R T P Q 2)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 3)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 4)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 5)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 6)) = Phi X C i R T P Q.
rewrite <- pack_c_u_r_r_p_p_0_eq2 X C i R T P Q.
prove Phi X (decode_c (pack_c_u_r_r_p_p X C i R T P Q 1)) (decode_u (pack_c_u_r_r_p_p X C i R T P Q 2)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 3)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 4)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 5)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 6)) = Phi X C i R T P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_r_p_p X C i R T P Q 1) U.
  rewrite <- pack_c_u_r_r_p_p_1_eq2 X C i R T P Q U HU.
  apply iff_refl.
- exact pack_c_u_r_r_p_p_2_eq2 X C i R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_r_p_p X C i R T P Q 3) x y.
  rewrite <- pack_c_u_r_r_p_p_3_eq2 X C i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_u_r_r_p_p X C i R T P Q 4) x y.
  rewrite <- pack_c_u_r_r_p_p_4_eq2 X C i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_r_p_p X C i R T P Q 5) x.
  rewrite <- pack_c_u_r_r_p_p_5_eq2 X C i R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_u_r_r_p_p X C i R T P Q 6) x.
  rewrite <- pack_c_u_r_r_p_p_6_eq2 X C i R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_r_p_p_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_c_u_r_r_p_p_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' i' R' T' P' Q' = Phi X C i R T P Q)
  ->
  unpack_c_u_r_r_p_p_o (pack_c_u_r_r_p_p X C i R T P Q) Phi = Phi X C i R T P Q.
let Phi X C i R T P Q.
assume HPhi.
prove Phi (pack_c_u_r_r_p_p X C i R T P Q 0) (decode_c (pack_c_u_r_r_p_p X C i R T P Q 1)) (decode_u (pack_c_u_r_r_p_p X C i R T P Q 2)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 3)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 4)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 5)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 6)) = Phi X C i R T P Q.
rewrite <- pack_c_u_r_r_p_p_0_eq2 X C i R T P Q.
prove Phi X (decode_c (pack_c_u_r_r_p_p X C i R T P Q 1)) (decode_u (pack_c_u_r_r_p_p X C i R T P Q 2)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 3)) (decode_r (pack_c_u_r_r_p_p X C i R T P Q 4)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 5)) (decode_p (pack_c_u_r_r_p_p X C i R T P Q 6)) = Phi X C i R T P Q.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_r_p_p X C i R T P Q 1) U.
  rewrite <- pack_c_u_r_r_p_p_1_eq2 X C i R T P Q U HU.
  apply iff_refl.
- exact pack_c_u_r_r_p_p_2_eq2 X C i R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_r_p_p X C i R T P Q 3) x y.
  rewrite <- pack_c_u_r_r_p_p_3_eq2 X C i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_u_r_r_p_p X C i R T P Q 4) x y.
  rewrite <- pack_c_u_r_r_p_p_4_eq2 X C i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_r_p_p X C i R T P Q 5) x.
  rewrite <- pack_c_u_r_r_p_p_5_eq2 X C i R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_u_r_r_p_p X C i R T P Q 6) x.
  rewrite <- pack_c_u_r_r_p_p_6_eq2 X C i R T P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_c_u_r_r_p_e : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X C i R T P c => (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c).

Theorem pack_c_u_r_r_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> X = S 0.
let S X C i R T P c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_u_r_r_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_c_u_r_r_p_e X C i R T P c 0.
let X C i R T P c. apply pack_c_u_r_r_p_e_0_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i R T P c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_u_r_r_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_u_r_r_p_e X C i R T P c 1) U.
let X C i R T P c. apply pack_c_u_r_r_p_e_1_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> forall x :e X, i x = decode_u (S 2) x.
let S X C i R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_u_r_r_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_u_r_r_p_e X C i R T P c 2) x.
let X C i R T P c. apply pack_c_u_r_r_p_e_2_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C i R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_u_r_r_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_u_r_r_p_e X C i R T P c 3) x y.
let X C i R T P c. apply pack_c_u_r_r_p_e_3_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X C i R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_u_r_r_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_c_u_r_r_p_e X C i R T P c 4) x y.
let X C i R T P c. apply pack_c_u_r_r_p_e_4_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> forall x :e X, P x = decode_p (S 5) x.
let S X C i R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_u_r_r_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_u_r_r_p_e X C i R T P c 5) x.
let X C i R T P c. apply pack_c_u_r_r_p_e_5_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_c_u_r_r_p_e X C i R T P c -> c = S 6.
let S X C i R T P c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_u_r_r_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_c_u_r_r_p_e X C i R T P c 6.
let X C i R T P c. apply pack_c_u_r_r_p_e_6_eq (pack_c_u_r_r_p_e X C i R T P c) X C i R T P c. reflexivity.
Qed.

Theorem pack_c_u_r_r_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_c_u_r_r_p_e X C i R T P c = pack_c_u_r_r_p_e X' C' i' R' T' P' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' C C' i i' R R' T T' P P' c c'. assume H1.
claim L0: X' = pack_c_u_r_r_p_e X C i R T P c 0.
{ exact pack_c_u_r_r_p_e_0_eq (pack_c_u_r_r_p_e X C i R T P c) X' C' i' R' T' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_u_r_r_p_e_0_eq2 X C i R T P c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_u_r_r_p_e_1_eq2 X C i R T P c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_e_1_eq2 X' C' i' R' T' P' c' U LU.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_u_r_r_p_e_2_eq2 X C i R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_e_2_eq2 X' C' i' R' T' P' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_u_r_r_p_e_3_eq2 X C i R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_e_3_eq2 X' C' i' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_u_r_r_p_e_4_eq2 X C i R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_e_4_eq2 X' C' i' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_u_r_r_p_e_5_eq2 X C i R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_e_5_eq2 X' C' i' R' T' P' c' x Lx.
- prove c = c'.
  rewrite pack_c_u_r_r_p_e_6_eq2 X C i R T P c.
  rewrite H1. symmetry.
  exact pack_c_u_r_r_p_e_6_eq2 X' C' i' R' T' P' c'.
Qed.

Theorem pack_c_u_r_r_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_u_r_r_p_e X C i R T P c = pack_c_u_r_r_p_e X C' i' R' T' P' c.
let X C C' i i' R R' T T' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) = (X,encode_c X C',encode_u X i',encode_r X R',encode_r X T',encode_p X P',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_u_r_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_c_u_r_r_p_e X C i R T P c)) -> q S.

Theorem pack_struct_c_u_r_r_p_e_I: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_c_u_r_r_p_e (pack_c_u_r_r_p_e X C i R T P c).
let X C i. assume Hi. let R T P c. assume Hc. let q. assume Hq.
exact Hq X C i Hi R T P c Hc.
Qed.

Theorem pack_struct_c_u_r_r_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_u_r_r_p_e (pack_c_u_r_r_p_e X C i R T P c) -> forall x :e X, i x :e X.
let X C i R T P c. assume H1. apply H1 (fun z => z = pack_c_u_r_r_p_e X C i R T P c -> forall x :e X, i x :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_u_r_r_p_e X' C' i' R' T' P' c' = pack_c_u_r_r_p_e X C i R T P c.
  apply pack_c_u_r_r_p_e_inj X' X C' C i' i R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_u_r_r_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_c_u_r_r_p_e (pack_c_u_r_r_p_e X C i R T P c) -> c :e X.
let X C i R T P c. assume H1. apply H1 (fun z => z = pack_c_u_r_r_p_e X C i R T P c -> c :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_c_u_r_r_p_e X' C' i' R' T' P' c' = pack_c_u_r_r_p_e X C i R T P c.
  apply pack_c_u_r_r_p_e_inj X' X C' C i' i R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_u_r_r_p_e_eta: forall S, struct_c_u_r_r_p_e S -> S = pack_c_u_r_r_p_e (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_u_r_r_p_e (z 0) (decode_c (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let i. assume _. let R. let T. let P. let c. assume _.
prove pack_c_u_r_r_p_e X C i R T P c = pack_c_u_r_r_p_e (pack_c_u_r_r_p_e X C i R T P c 0) (decode_c (pack_c_u_r_r_p_e X C i R T P c 1)) (decode_u (pack_c_u_r_r_p_e X C i R T P c 2)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 3)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 4)) (decode_p (pack_c_u_r_r_p_e X C i R T P c 5)) (pack_c_u_r_r_p_e X C i R T P c 6).
rewrite <- pack_c_u_r_r_p_e_0_eq2 X C i R T P c.
rewrite <- pack_c_u_r_r_p_e_6_eq2 X C i R T P c.
apply pack_c_u_r_r_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_u_r_r_p_e_1_eq2 X C i R T P c U HU.
  apply iff_refl.
- exact pack_c_u_r_r_p_e_2_eq2 X C i R T P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_r_p_e_3_eq2 X C i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_r_p_e_4_eq2 X C i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_r_r_p_e_5_eq2 X C i R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_r_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_u_r_r_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' i' R' T' P' c = Phi X C i R T P c)
  ->
  unpack_c_u_r_r_p_e_i (pack_c_u_r_r_p_e X C i R T P c) Phi = Phi X C i R T P c.
let Phi X C i R T P c.
assume HPhi.
prove Phi (pack_c_u_r_r_p_e X C i R T P c 0) (decode_c (pack_c_u_r_r_p_e X C i R T P c 1)) (decode_u (pack_c_u_r_r_p_e X C i R T P c 2)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 3)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 4)) (decode_p (pack_c_u_r_r_p_e X C i R T P c 5)) (pack_c_u_r_r_p_e X C i R T P c 6) = Phi X C i R T P c.
rewrite <- pack_c_u_r_r_p_e_0_eq2 X C i R T P c.
prove Phi X (decode_c (pack_c_u_r_r_p_e X C i R T P c 1)) (decode_u (pack_c_u_r_r_p_e X C i R T P c 2)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 3)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 4)) (decode_p (pack_c_u_r_r_p_e X C i R T P c 5)) (pack_c_u_r_r_p_e X C i R T P c 6) = Phi X C i R T P c.
rewrite <- pack_c_u_r_r_p_e_6_eq2 X C i R T P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_r_p_e X C i R T P c 1) U.
  rewrite <- pack_c_u_r_r_p_e_1_eq2 X C i R T P c U HU.
  apply iff_refl.
- exact pack_c_u_r_r_p_e_2_eq2 X C i R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_r_p_e X C i R T P c 3) x y.
  rewrite <- pack_c_u_r_r_p_e_3_eq2 X C i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_u_r_r_p_e X C i R T P c 4) x y.
  rewrite <- pack_c_u_r_r_p_e_4_eq2 X C i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_r_p_e X C i R T P c 5) x.
  rewrite <- pack_c_u_r_r_p_e_5_eq2 X C i R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_r_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_u_r_r_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' i' R' T' P' c = Phi X C i R T P c)
  ->
  unpack_c_u_r_r_p_e_o (pack_c_u_r_r_p_e X C i R T P c) Phi = Phi X C i R T P c.
let Phi X C i R T P c.
assume HPhi.
prove Phi (pack_c_u_r_r_p_e X C i R T P c 0) (decode_c (pack_c_u_r_r_p_e X C i R T P c 1)) (decode_u (pack_c_u_r_r_p_e X C i R T P c 2)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 3)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 4)) (decode_p (pack_c_u_r_r_p_e X C i R T P c 5)) (pack_c_u_r_r_p_e X C i R T P c 6) = Phi X C i R T P c.
rewrite <- pack_c_u_r_r_p_e_0_eq2 X C i R T P c.
prove Phi X (decode_c (pack_c_u_r_r_p_e X C i R T P c 1)) (decode_u (pack_c_u_r_r_p_e X C i R T P c 2)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 3)) (decode_r (pack_c_u_r_r_p_e X C i R T P c 4)) (decode_p (pack_c_u_r_r_p_e X C i R T P c 5)) (pack_c_u_r_r_p_e X C i R T P c 6) = Phi X C i R T P c.
rewrite <- pack_c_u_r_r_p_e_6_eq2 X C i R T P c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_r_p_e X C i R T P c 1) U.
  rewrite <- pack_c_u_r_r_p_e_1_eq2 X C i R T P c U HU.
  apply iff_refl.
- exact pack_c_u_r_r_p_e_2_eq2 X C i R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_r_p_e X C i R T P c 3) x y.
  rewrite <- pack_c_u_r_r_p_e_3_eq2 X C i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_u_r_r_p_e X C i R T P c 4) x y.
  rewrite <- pack_c_u_r_r_p_e_4_eq2 X C i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_r_p_e X C i R T P c 5) x.
  rewrite <- pack_c_u_r_r_p_e_5_eq2 X C i R T P c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_u_r_r_e_e : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set := fun X C i R T c d => (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d).

Theorem pack_c_u_r_r_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> X = S 0.
let S X C i R T c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_u_r_r_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, X = pack_c_u_r_r_e_e X C i R T c d 0.
let X C i R T c d. apply pack_c_u_r_r_e_e_0_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i R T c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_u_r_r_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_u_r_r_e_e X C i R T c d 1) U.
let X C i R T c d. apply pack_c_u_r_r_e_e_1_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> forall x :e X, i x = decode_u (S 2) x.
let S X C i R T c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_u_r_r_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_c_u_r_r_e_e X C i R T c d 2) x.
let X C i R T c d. apply pack_c_u_r_r_e_e_2_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C i R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_u_r_r_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_c_u_r_r_e_e X C i R T c d 3) x y.
let X C i R T c d. apply pack_c_u_r_r_e_e_3_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X C i R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_c_u_r_r_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, T x y = decode_r (pack_c_u_r_r_e_e X C i R T c d 4) x y.
let X C i R T c d. apply pack_c_u_r_r_e_e_4_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> c = S 5.
let S X C i R T c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_u_r_r_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, c = pack_c_u_r_r_e_e X C i R T c d 5.
let X C i R T c d. apply pack_c_u_r_r_e_e_5_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_c_u_r_r_e_e X C i R T c d -> d = S 6.
let S X C i R T c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_u_r_r_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, d = pack_c_u_r_r_e_e X C i R T c d 6.
let X C i R T c d. apply pack_c_u_r_r_e_e_6_eq (pack_c_u_r_r_e_e X C i R T c d) X C i R T c d. reflexivity.
Qed.

Theorem pack_c_u_r_r_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, forall d d':set, pack_c_u_r_r_e_e X C i R T c d = pack_c_u_r_r_e_e X' C' i' R' T' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c' /\ d = d'.
let X X' C C' i i' R R' T T' c c' d d'. assume H1.
claim L0: X' = pack_c_u_r_r_e_e X C i R T c d 0.
{ exact pack_c_u_r_r_e_e_0_eq (pack_c_u_r_r_e_e X C i R T c d) X' C' i' R' T' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_u_r_r_e_e_0_eq2 X C i R T c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_u_r_r_e_e_1_eq2 X C i R T c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_e_e_1_eq2 X' C' i' R' T' c' d' U LU.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_u_r_r_e_e_2_eq2 X C i R T c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_e_e_2_eq2 X' C' i' R' T' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_u_r_r_e_e_3_eq2 X C i R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_e_e_3_eq2 X' C' i' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_c_u_r_r_e_e_4_eq2 X C i R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_r_e_e_4_eq2 X' C' i' R' T' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_c_u_r_r_e_e_5_eq2 X C i R T c d.
  rewrite H1. symmetry.
  exact pack_c_u_r_r_e_e_5_eq2 X' C' i' R' T' c' d'.
- prove d = d'.
  rewrite pack_c_u_r_r_e_e_6_eq2 X C i R T c d.
  rewrite H1. symmetry.
  exact pack_c_u_r_r_e_e_6_eq2 X' C' i' R' T' c' d'.
Qed.

Theorem pack_c_u_r_r_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_c_u_r_r_e_e X C i R T c d = pack_c_u_r_r_e_e X C' i' R' T' c d.
let X C C' i i' R R' T T' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_u X i,encode_r X R,encode_r X T,c,d) = (X,encode_c X C',encode_u X i',encode_r X R',encode_r X T',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_u_r_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_u_r_r_e_e X C i R T c d)) -> q S.

Theorem pack_struct_c_u_r_r_e_e_I: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_u_r_r_e_e (pack_c_u_r_r_e_e X C i R T c d).
let X C i. assume Hi. let R T c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C i Hi R T c Hc d Hd.
Qed.

Theorem pack_struct_c_u_r_r_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_c_u_r_r_e_e (pack_c_u_r_r_e_e X C i R T c d) -> forall x :e X, i x :e X.
let X C i R T c d. assume H1. apply H1 (fun z => z = pack_c_u_r_r_e_e X C i R T c d -> forall x :e X, i x :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_r_r_e_e X' C' i' R' T' c' d' = pack_c_u_r_r_e_e X C i R T c d.
  apply pack_c_u_r_r_e_e_inj X' X C' C i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_u_r_r_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_c_u_r_r_e_e (pack_c_u_r_r_e_e X C i R T c d) -> c :e X.
let X C i R T c d. assume H1. apply H1 (fun z => z = pack_c_u_r_r_e_e X C i R T c d -> c :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_r_r_e_e X' C' i' R' T' c' d' = pack_c_u_r_r_e_e X C i R T c d.
  apply pack_c_u_r_r_e_e_inj X' X C' C i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_u_r_r_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_c_u_r_r_e_e (pack_c_u_r_r_e_e X C i R T c d) -> d :e X.
let X C i R T c d. assume H1. apply H1 (fun z => z = pack_c_u_r_r_e_e X C i R T c d -> d :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_r_r_e_e X' C' i' R' T' c' d' = pack_c_u_r_r_e_e X C i R T c d.
  apply pack_c_u_r_r_e_e_inj X' X C' C i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_u_r_r_e_e_eta: forall S, struct_c_u_r_r_e_e S -> S = pack_c_u_r_r_e_e (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_u_r_r_e_e (z 0) (decode_c (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let C. let i. assume _. let R. let T. let c. assume _. let d. assume _.
prove pack_c_u_r_r_e_e X C i R T c d = pack_c_u_r_r_e_e (pack_c_u_r_r_e_e X C i R T c d 0) (decode_c (pack_c_u_r_r_e_e X C i R T c d 1)) (decode_u (pack_c_u_r_r_e_e X C i R T c d 2)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 3)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 4)) (pack_c_u_r_r_e_e X C i R T c d 5) (pack_c_u_r_r_e_e X C i R T c d 6).
rewrite <- pack_c_u_r_r_e_e_0_eq2 X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_5_eq2 X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_6_eq2 X C i R T c d.
apply pack_c_u_r_r_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_u_r_r_e_e_1_eq2 X C i R T c d U HU.
  apply iff_refl.
- exact pack_c_u_r_r_e_e_2_eq2 X C i R T c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_r_e_e_3_eq2 X C i R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_r_e_e_4_eq2 X C i R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_r_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_c_u_r_r_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' i' R' T' c d = Phi X C i R T c d)
  ->
  unpack_c_u_r_r_e_e_i (pack_c_u_r_r_e_e X C i R T c d) Phi = Phi X C i R T c d.
let Phi X C i R T c d.
assume HPhi.
prove Phi (pack_c_u_r_r_e_e X C i R T c d 0) (decode_c (pack_c_u_r_r_e_e X C i R T c d 1)) (decode_u (pack_c_u_r_r_e_e X C i R T c d 2)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 3)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 4)) (pack_c_u_r_r_e_e X C i R T c d 5) (pack_c_u_r_r_e_e X C i R T c d 6) = Phi X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_0_eq2 X C i R T c d.
prove Phi X (decode_c (pack_c_u_r_r_e_e X C i R T c d 1)) (decode_u (pack_c_u_r_r_e_e X C i R T c d 2)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 3)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 4)) (pack_c_u_r_r_e_e X C i R T c d 5) (pack_c_u_r_r_e_e X C i R T c d 6) = Phi X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_5_eq2 X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_6_eq2 X C i R T c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_r_e_e X C i R T c d 1) U.
  rewrite <- pack_c_u_r_r_e_e_1_eq2 X C i R T c d U HU.
  apply iff_refl.
- exact pack_c_u_r_r_e_e_2_eq2 X C i R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_r_e_e X C i R T c d 3) x y.
  rewrite <- pack_c_u_r_r_e_e_3_eq2 X C i R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_u_r_r_e_e X C i R T c d 4) x y.
  rewrite <- pack_c_u_r_r_e_e_4_eq2 X C i R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_r_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_c_u_r_r_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X C' i' R' T' c d = Phi X C i R T c d)
  ->
  unpack_c_u_r_r_e_e_o (pack_c_u_r_r_e_e X C i R T c d) Phi = Phi X C i R T c d.
let Phi X C i R T c d.
assume HPhi.
prove Phi (pack_c_u_r_r_e_e X C i R T c d 0) (decode_c (pack_c_u_r_r_e_e X C i R T c d 1)) (decode_u (pack_c_u_r_r_e_e X C i R T c d 2)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 3)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 4)) (pack_c_u_r_r_e_e X C i R T c d 5) (pack_c_u_r_r_e_e X C i R T c d 6) = Phi X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_0_eq2 X C i R T c d.
prove Phi X (decode_c (pack_c_u_r_r_e_e X C i R T c d 1)) (decode_u (pack_c_u_r_r_e_e X C i R T c d 2)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 3)) (decode_r (pack_c_u_r_r_e_e X C i R T c d 4)) (pack_c_u_r_r_e_e X C i R T c d 5) (pack_c_u_r_r_e_e X C i R T c d 6) = Phi X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_5_eq2 X C i R T c d.
rewrite <- pack_c_u_r_r_e_e_6_eq2 X C i R T c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_r_e_e X C i R T c d 1) U.
  rewrite <- pack_c_u_r_r_e_e_1_eq2 X C i R T c d U HU.
  apply iff_refl.
- exact pack_c_u_r_r_e_e_2_eq2 X C i R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_r_e_e X C i R T c d 3) x y.
  rewrite <- pack_c_u_r_r_e_e_3_eq2 X C i R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_c_u_r_r_e_e X C i R T c d 4) x y.
  rewrite <- pack_c_u_r_r_e_e_4_eq2 X C i R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_c_u_r_p_p_e : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set := fun X C i R P Q c => (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c).

Theorem pack_c_u_r_p_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> X = S 0.
let S X C i R P Q c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_u_r_p_p_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_c_u_r_p_p_e X C i R P Q c 0.
let X C i R P Q c. apply pack_c_u_r_p_p_e_0_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i R P Q c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_u_r_p_p_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_u_r_p_p_e X C i R P Q c 1) U.
let X C i R P Q c. apply pack_c_u_r_p_p_e_1_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> forall x :e X, i x = decode_u (S 2) x.
let S X C i R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_u_r_p_p_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_c_u_r_p_p_e X C i R P Q c 2) x.
let X C i R P Q c. apply pack_c_u_r_p_p_e_2_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C i R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_u_r_p_p_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_c_u_r_p_p_e X C i R P Q c 3) x y.
let X C i R P Q c. apply pack_c_u_r_p_p_e_3_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X C i R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_u_r_p_p_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_c_u_r_p_p_e X C i R P Q c 4) x.
let X C i R P Q c. apply pack_c_u_r_p_p_e_4_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X C i R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_u_r_p_p_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_c_u_r_p_p_e X C i R P Q c 5) x.
let X C i R P Q c. apply pack_c_u_r_p_p_e_5_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_c_u_r_p_p_e X C i R P Q c -> c = S 6.
let S X C i R P Q c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_u_r_p_p_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_c_u_r_p_p_e X C i R P Q c 6.
let X C i R P Q c. apply pack_c_u_r_p_p_e_6_eq (pack_c_u_r_p_p_e X C i R P Q c) X C i R P Q c. reflexivity.
Qed.

Theorem pack_c_u_r_p_p_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_c_u_r_p_p_e X C i R P Q c = pack_c_u_r_p_p_e X' C' i' R' P' Q' c' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' C C' i i' R R' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_c_u_r_p_p_e X C i R P Q c 0.
{ exact pack_c_u_r_p_p_e_0_eq (pack_c_u_r_p_p_e X C i R P Q c) X' C' i' R' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_u_r_p_p_e_0_eq2 X C i R P Q c. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_u_r_p_p_e_1_eq2 X C i R P Q c U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_p_e_1_eq2 X' C' i' R' P' Q' c' U LU.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_u_r_p_p_e_2_eq2 X C i R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_p_e_2_eq2 X' C' i' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_u_r_p_p_e_3_eq2 X C i R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_p_e_3_eq2 X' C' i' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_u_r_p_p_e_4_eq2 X C i R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_p_e_4_eq2 X' C' i' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_u_r_p_p_e_5_eq2 X C i R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_p_e_5_eq2 X' C' i' R' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_c_u_r_p_p_e_6_eq2 X C i R P Q c.
  rewrite H1. symmetry.
  exact pack_c_u_r_p_p_e_6_eq2 X' C' i' R' P' Q' c'.
Qed.

Theorem pack_c_u_r_p_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_u_r_p_p_e X C i R P Q c = pack_c_u_r_p_p_e X C' i' R' P' Q' c.
let X C C' i i' R R' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) = (X,encode_c X C',encode_u X i',encode_r X R',encode_p X P',encode_p X Q',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_c_u_r_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_c_u_r_p_p_e X C i R P Q c)) -> q S.

Theorem pack_struct_c_u_r_p_p_e_I: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_c_u_r_p_p_e (pack_c_u_r_p_p_e X C i R P Q c).
let X C i. assume Hi. let R P Q c. assume Hc. let q. assume Hq.
exact Hq X C i Hi R P Q c Hc.
Qed.

Theorem pack_struct_c_u_r_p_p_e_E2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_u_r_p_p_e (pack_c_u_r_p_p_e X C i R P Q c) -> forall x :e X, i x :e X.
let X C i R P Q c. assume H1. apply H1 (fun z => z = pack_c_u_r_p_p_e X C i R P Q c -> forall x :e X, i x :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_u_r_p_p_e X' C' i' R' P' Q' c' = pack_c_u_r_p_p_e X C i R P Q c.
  apply pack_c_u_r_p_p_e_inj X' X C' C i' i R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_u_r_p_p_e_E6: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_c_u_r_p_p_e (pack_c_u_r_p_p_e X C i R P Q c) -> c :e X.
let X C i R P Q c. assume H1. apply H1 (fun z => z = pack_c_u_r_p_p_e X C i R P Q c -> c :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_c_u_r_p_p_e X' C' i' R' P' Q' c' = pack_c_u_r_p_p_e X C i R P Q c.
  apply pack_c_u_r_p_p_e_inj X' X C' C i' i R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_c_u_r_p_p_e_eta: forall S, struct_c_u_r_p_p_e S -> S = pack_c_u_r_p_p_e (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_u_r_p_p_e (z 0) (decode_c (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let C. let i. assume _. let R. let P. let Q. let c. assume _.
prove pack_c_u_r_p_p_e X C i R P Q c = pack_c_u_r_p_p_e (pack_c_u_r_p_p_e X C i R P Q c 0) (decode_c (pack_c_u_r_p_p_e X C i R P Q c 1)) (decode_u (pack_c_u_r_p_p_e X C i R P Q c 2)) (decode_r (pack_c_u_r_p_p_e X C i R P Q c 3)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 4)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 5)) (pack_c_u_r_p_p_e X C i R P Q c 6).
rewrite <- pack_c_u_r_p_p_e_0_eq2 X C i R P Q c.
rewrite <- pack_c_u_r_p_p_e_6_eq2 X C i R P Q c.
apply pack_c_u_r_p_p_e_ext.
- let U. assume HU.
  rewrite <- pack_c_u_r_p_p_e_1_eq2 X C i R P Q c U HU.
  apply iff_refl.
- exact pack_c_u_r_p_p_e_2_eq2 X C i R P Q c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_p_p_e_3_eq2 X C i R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_r_p_p_e_4_eq2 X C i R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_r_p_p_e_5_eq2 X C i R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_p_p_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_u_r_p_p_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' i' R' P' Q' c = Phi X C i R P Q c)
  ->
  unpack_c_u_r_p_p_e_i (pack_c_u_r_p_p_e X C i R P Q c) Phi = Phi X C i R P Q c.
let Phi X C i R P Q c.
assume HPhi.
prove Phi (pack_c_u_r_p_p_e X C i R P Q c 0) (decode_c (pack_c_u_r_p_p_e X C i R P Q c 1)) (decode_u (pack_c_u_r_p_p_e X C i R P Q c 2)) (decode_r (pack_c_u_r_p_p_e X C i R P Q c 3)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 4)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 5)) (pack_c_u_r_p_p_e X C i R P Q c 6) = Phi X C i R P Q c.
rewrite <- pack_c_u_r_p_p_e_0_eq2 X C i R P Q c.
prove Phi X (decode_c (pack_c_u_r_p_p_e X C i R P Q c 1)) (decode_u (pack_c_u_r_p_p_e X C i R P Q c 2)) (decode_r (pack_c_u_r_p_p_e X C i R P Q c 3)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 4)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 5)) (pack_c_u_r_p_p_e X C i R P Q c 6) = Phi X C i R P Q c.
rewrite <- pack_c_u_r_p_p_e_6_eq2 X C i R P Q c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_p_p_e X C i R P Q c 1) U.
  rewrite <- pack_c_u_r_p_p_e_1_eq2 X C i R P Q c U HU.
  apply iff_refl.
- exact pack_c_u_r_p_p_e_2_eq2 X C i R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_p_p_e X C i R P Q c 3) x y.
  rewrite <- pack_c_u_r_p_p_e_3_eq2 X C i R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_p_p_e X C i R P Q c 4) x.
  rewrite <- pack_c_u_r_p_p_e_4_eq2 X C i R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_u_r_p_p_e X C i R P Q c 5) x.
  rewrite <- pack_c_u_r_p_p_e_5_eq2 X C i R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_p_p_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_c_u_r_p_p_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' i' R' P' Q' c = Phi X C i R P Q c)
  ->
  unpack_c_u_r_p_p_e_o (pack_c_u_r_p_p_e X C i R P Q c) Phi = Phi X C i R P Q c.
let Phi X C i R P Q c.
assume HPhi.
prove Phi (pack_c_u_r_p_p_e X C i R P Q c 0) (decode_c (pack_c_u_r_p_p_e X C i R P Q c 1)) (decode_u (pack_c_u_r_p_p_e X C i R P Q c 2)) (decode_r (pack_c_u_r_p_p_e X C i R P Q c 3)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 4)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 5)) (pack_c_u_r_p_p_e X C i R P Q c 6) = Phi X C i R P Q c.
rewrite <- pack_c_u_r_p_p_e_0_eq2 X C i R P Q c.
prove Phi X (decode_c (pack_c_u_r_p_p_e X C i R P Q c 1)) (decode_u (pack_c_u_r_p_p_e X C i R P Q c 2)) (decode_r (pack_c_u_r_p_p_e X C i R P Q c 3)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 4)) (decode_p (pack_c_u_r_p_p_e X C i R P Q c 5)) (pack_c_u_r_p_p_e X C i R P Q c 6) = Phi X C i R P Q c.
rewrite <- pack_c_u_r_p_p_e_6_eq2 X C i R P Q c.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_p_p_e X C i R P Q c 1) U.
  rewrite <- pack_c_u_r_p_p_e_1_eq2 X C i R P Q c U HU.
  apply iff_refl.
- exact pack_c_u_r_p_p_e_2_eq2 X C i R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_p_p_e X C i R P Q c 3) x y.
  rewrite <- pack_c_u_r_p_p_e_3_eq2 X C i R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_p_p_e X C i R P Q c 4) x.
  rewrite <- pack_c_u_r_p_p_e_4_eq2 X C i R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_u_r_p_p_e X C i R P Q c 5) x.
  rewrite <- pack_c_u_r_p_p_e_5_eq2 X C i R P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_c_u_r_p_e_e : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set := fun X C i R P c d => (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d).

Theorem pack_c_u_r_p_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> X = S 0.
let S X C i R P c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_u_r_p_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, X = pack_c_u_r_p_e_e X C i R P c d 0.
let X C i R P c d. apply pack_c_u_r_p_e_e_0_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i R P c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_u_r_p_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_u_r_p_e_e X C i R P c d 1) U.
let X C i R P c d. apply pack_c_u_r_p_e_e_1_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> forall x :e X, i x = decode_u (S 2) x.
let S X C i R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_u_r_p_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_c_u_r_p_e_e X C i R P c d 2) x.
let X C i R P c d. apply pack_c_u_r_p_e_e_2_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C i R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_u_r_p_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_c_u_r_p_e_e X C i R P c d 3) x y.
let X C i R P c d. apply pack_c_u_r_p_e_e_3_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X C i R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_u_r_p_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_c_u_r_p_e_e X C i R P c d 4) x.
let X C i R P c d. apply pack_c_u_r_p_e_e_4_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> c = S 5.
let S X C i R P c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_u_r_p_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, c = pack_c_u_r_p_e_e X C i R P c d 5.
let X C i R P c d. apply pack_c_u_r_p_e_e_5_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_c_u_r_p_e_e X C i R P c d -> d = S 6.
let S X C i R P c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_u_r_p_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, d = pack_c_u_r_p_e_e X C i R P c d 6.
let X C i R P c d. apply pack_c_u_r_p_e_e_6_eq (pack_c_u_r_p_e_e X C i R P c d) X C i R P c d. reflexivity.
Qed.

Theorem pack_c_u_r_p_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, forall d d':set, pack_c_u_r_p_e_e X C i R P c d = pack_c_u_r_p_e_e X' C' i' R' P' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' C C' i i' R R' P P' c c' d d'. assume H1.
claim L0: X' = pack_c_u_r_p_e_e X C i R P c d 0.
{ exact pack_c_u_r_p_e_e_0_eq (pack_c_u_r_p_e_e X C i R P c d) X' C' i' R' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_u_r_p_e_e_0_eq2 X C i R P c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_u_r_p_e_e_1_eq2 X C i R P c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_e_e_1_eq2 X' C' i' R' P' c' d' U LU.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_u_r_p_e_e_2_eq2 X C i R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_e_e_2_eq2 X' C' i' R' P' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_u_r_p_e_e_3_eq2 X C i R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_e_e_3_eq2 X' C' i' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_u_r_p_e_e_4_eq2 X C i R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_r_p_e_e_4_eq2 X' C' i' R' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_u_r_p_e_e_5_eq2 X C i R P c d.
  rewrite H1. symmetry.
  exact pack_c_u_r_p_e_e_5_eq2 X' C' i' R' P' c' d'.
- prove d = d'.
  rewrite pack_c_u_r_p_e_e_6_eq2 X C i R P c d.
  rewrite H1. symmetry.
  exact pack_c_u_r_p_e_e_6_eq2 X' C' i' R' P' c' d'.
Qed.

Theorem pack_c_u_r_p_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_u_r_p_e_e X C i R P c d = pack_c_u_r_p_e_e X C' i' R' P' c d.
let X C C' i i' R R' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_u X i,encode_r X R,encode_p X P,c,d) = (X,encode_c X C',encode_u X i',encode_r X R',encode_p X P',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_u_r_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_u_r_p_e_e X C i R P c d)) -> q S.

Theorem pack_struct_c_u_r_p_e_e_I: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_u_r_p_e_e (pack_c_u_r_p_e_e X C i R P c d).
let X C i. assume Hi. let R P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C i Hi R P c Hc d Hd.
Qed.

Theorem pack_struct_c_u_r_p_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_c_u_r_p_e_e (pack_c_u_r_p_e_e X C i R P c d) -> forall x :e X, i x :e X.
let X C i R P c d. assume H1. apply H1 (fun z => z = pack_c_u_r_p_e_e X C i R P c d -> forall x :e X, i x :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_r_p_e_e X' C' i' R' P' c' d' = pack_c_u_r_p_e_e X C i R P c d.
  apply pack_c_u_r_p_e_e_inj X' X C' C i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_u_r_p_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_c_u_r_p_e_e (pack_c_u_r_p_e_e X C i R P c d) -> c :e X.
let X C i R P c d. assume H1. apply H1 (fun z => z = pack_c_u_r_p_e_e X C i R P c d -> c :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_r_p_e_e X' C' i' R' P' c' d' = pack_c_u_r_p_e_e X C i R P c d.
  apply pack_c_u_r_p_e_e_inj X' X C' C i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_u_r_p_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_c_u_r_p_e_e (pack_c_u_r_p_e_e X C i R P c d) -> d :e X.
let X C i R P c d. assume H1. apply H1 (fun z => z = pack_c_u_r_p_e_e X C i R P c d -> d :e X).
- let X'. let C'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_r_p_e_e X' C' i' R' P' c' d' = pack_c_u_r_p_e_e X C i R P c d.
  apply pack_c_u_r_p_e_e_inj X' X C' C i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_u_r_p_e_e_eta: forall S, struct_c_u_r_p_e_e S -> S = pack_c_u_r_p_e_e (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_u_r_p_e_e (z 0) (decode_c (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let C. let i. assume _. let R. let P. let c. assume _. let d. assume _.
prove pack_c_u_r_p_e_e X C i R P c d = pack_c_u_r_p_e_e (pack_c_u_r_p_e_e X C i R P c d 0) (decode_c (pack_c_u_r_p_e_e X C i R P c d 1)) (decode_u (pack_c_u_r_p_e_e X C i R P c d 2)) (decode_r (pack_c_u_r_p_e_e X C i R P c d 3)) (decode_p (pack_c_u_r_p_e_e X C i R P c d 4)) (pack_c_u_r_p_e_e X C i R P c d 5) (pack_c_u_r_p_e_e X C i R P c d 6).
rewrite <- pack_c_u_r_p_e_e_0_eq2 X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_5_eq2 X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_6_eq2 X C i R P c d.
apply pack_c_u_r_p_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_u_r_p_e_e_1_eq2 X C i R P c d U HU.
  apply iff_refl.
- exact pack_c_u_r_p_e_e_2_eq2 X C i R P c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_u_r_p_e_e_3_eq2 X C i R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_r_p_e_e_4_eq2 X C i R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_p_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_u_r_p_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' i' R' P' c d = Phi X C i R P c d)
  ->
  unpack_c_u_r_p_e_e_i (pack_c_u_r_p_e_e X C i R P c d) Phi = Phi X C i R P c d.
let Phi X C i R P c d.
assume HPhi.
prove Phi (pack_c_u_r_p_e_e X C i R P c d 0) (decode_c (pack_c_u_r_p_e_e X C i R P c d 1)) (decode_u (pack_c_u_r_p_e_e X C i R P c d 2)) (decode_r (pack_c_u_r_p_e_e X C i R P c d 3)) (decode_p (pack_c_u_r_p_e_e X C i R P c d 4)) (pack_c_u_r_p_e_e X C i R P c d 5) (pack_c_u_r_p_e_e X C i R P c d 6) = Phi X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_0_eq2 X C i R P c d.
prove Phi X (decode_c (pack_c_u_r_p_e_e X C i R P c d 1)) (decode_u (pack_c_u_r_p_e_e X C i R P c d 2)) (decode_r (pack_c_u_r_p_e_e X C i R P c d 3)) (decode_p (pack_c_u_r_p_e_e X C i R P c d 4)) (pack_c_u_r_p_e_e X C i R P c d 5) (pack_c_u_r_p_e_e X C i R P c d 6) = Phi X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_5_eq2 X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_6_eq2 X C i R P c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_p_e_e X C i R P c d 1) U.
  rewrite <- pack_c_u_r_p_e_e_1_eq2 X C i R P c d U HU.
  apply iff_refl.
- exact pack_c_u_r_p_e_e_2_eq2 X C i R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_p_e_e X C i R P c d 3) x y.
  rewrite <- pack_c_u_r_p_e_e_3_eq2 X C i R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_p_e_e X C i R P c d 4) x.
  rewrite <- pack_c_u_r_p_e_e_4_eq2 X C i R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_r_p_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_u_r_p_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C' i' R' P' c d = Phi X C i R P c d)
  ->
  unpack_c_u_r_p_e_e_o (pack_c_u_r_p_e_e X C i R P c d) Phi = Phi X C i R P c d.
let Phi X C i R P c d.
assume HPhi.
prove Phi (pack_c_u_r_p_e_e X C i R P c d 0) (decode_c (pack_c_u_r_p_e_e X C i R P c d 1)) (decode_u (pack_c_u_r_p_e_e X C i R P c d 2)) (decode_r (pack_c_u_r_p_e_e X C i R P c d 3)) (decode_p (pack_c_u_r_p_e_e X C i R P c d 4)) (pack_c_u_r_p_e_e X C i R P c d 5) (pack_c_u_r_p_e_e X C i R P c d 6) = Phi X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_0_eq2 X C i R P c d.
prove Phi X (decode_c (pack_c_u_r_p_e_e X C i R P c d 1)) (decode_u (pack_c_u_r_p_e_e X C i R P c d 2)) (decode_r (pack_c_u_r_p_e_e X C i R P c d 3)) (decode_p (pack_c_u_r_p_e_e X C i R P c d 4)) (pack_c_u_r_p_e_e X C i R P c d 5) (pack_c_u_r_p_e_e X C i R P c d 6) = Phi X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_5_eq2 X C i R P c d.
rewrite <- pack_c_u_r_p_e_e_6_eq2 X C i R P c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_r_p_e_e X C i R P c d 1) U.
  rewrite <- pack_c_u_r_p_e_e_1_eq2 X C i R P c d U HU.
  apply iff_refl.
- exact pack_c_u_r_p_e_e_2_eq2 X C i R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_u_r_p_e_e X C i R P c d 3) x y.
  rewrite <- pack_c_u_r_p_e_e_3_eq2 X C i R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_r_p_e_e X C i R P c d 4) x.
  rewrite <- pack_c_u_r_p_e_e_4_eq2 X C i R P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_c_u_p_p_e_e : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X C i P Q c d => (X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d).

Theorem pack_c_u_p_p_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> X = S 0.
let S X C i P Q c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_u_p_p_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_c_u_p_p_e_e X C i P Q c d 0.
let X C i P Q c d. apply pack_c_u_p_p_e_e_0_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i P Q c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_u_p_p_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_u_p_p_e_e X C i P Q c d 1) U.
let X C i P Q c d. apply pack_c_u_p_p_e_e_1_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> forall x :e X, i x = decode_u (S 2) x.
let S X C i P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_c_u_p_p_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_c_u_p_p_e_e X C i P Q c d 2) x.
let X C i P Q c d. apply pack_c_u_p_p_e_e_2_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X C i P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_u_p_p_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_c_u_p_p_e_e X C i P Q c d 3) x.
let X C i P Q c d. apply pack_c_u_p_p_e_e_3_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X C i P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_u_p_p_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_c_u_p_p_e_e X C i P Q c d 4) x.
let X C i P Q c d. apply pack_c_u_p_p_e_e_4_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> c = S 5.
let S X C i P Q c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_u_p_p_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_c_u_p_p_e_e X C i P Q c d 5.
let X C i P Q c d. apply pack_c_u_p_p_e_e_5_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_u_p_p_e_e X C i P Q c d -> d = S 6.
let S X C i P Q c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_u_p_p_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_c_u_p_p_e_e X C i P Q c d 6.
let X C i P Q c d. apply pack_c_u_p_p_e_e_6_eq (pack_c_u_p_p_e_e X C i P Q c d) X C i P Q c d. reflexivity.
Qed.

Theorem pack_c_u_p_p_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_c_u_p_p_e_e X C i P Q c d = pack_c_u_p_p_e_e X' C' i' P' Q' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' C C' i i' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_c_u_p_p_e_e X C i P Q c d 0.
{ exact pack_c_u_p_p_e_e_0_eq (pack_c_u_p_p_e_e X C i P Q c d) X' C' i' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_u_p_p_e_e_0_eq2 X C i P Q c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_u_p_p_e_e_1_eq2 X C i P Q c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_u_p_p_e_e_1_eq2 X' C' i' P' Q' c' d' U LU.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_c_u_p_p_e_e_2_eq2 X C i P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_p_p_e_e_2_eq2 X' C' i' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_u_p_p_e_e_3_eq2 X C i P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_p_p_e_e_3_eq2 X' C' i' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_u_p_p_e_e_4_eq2 X C i P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_u_p_p_e_e_4_eq2 X' C' i' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_u_p_p_e_e_5_eq2 X C i P Q c d.
  rewrite H1. symmetry.
  exact pack_c_u_p_p_e_e_5_eq2 X' C' i' P' Q' c' d'.
- prove d = d'.
  rewrite pack_c_u_p_p_e_e_6_eq2 X C i P Q c d.
  rewrite H1. symmetry.
  exact pack_c_u_p_p_e_e_6_eq2 X' C' i' P' Q' c' d'.
Qed.

Theorem pack_c_u_p_p_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_u_p_p_e_e X C i P Q c d = pack_c_u_p_p_e_e X C' i' P' Q' c d.
let X C C' i i' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_u X i,encode_p X P,encode_p X Q,c,d) = (X,encode_c X C',encode_u X i',encode_p X P',encode_p X Q',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_u_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_u_p_p_e_e X C i P Q c d)) -> q S.

Theorem pack_struct_c_u_p_p_e_e_I: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_u_p_p_e_e (pack_c_u_p_p_e_e X C i P Q c d).
let X C i. assume Hi. let P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C i Hi P Q c Hc d Hd.
Qed.

Theorem pack_struct_c_u_p_p_e_e_E2: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_u_p_p_e_e (pack_c_u_p_p_e_e X C i P Q c d) -> forall x :e X, i x :e X.
let X C i P Q c d. assume H1. apply H1 (fun z => z = pack_c_u_p_p_e_e X C i P Q c d -> forall x :e X, i x :e X).
- let X'. let C'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_p_p_e_e X' C' i' P' Q' c' d' = pack_c_u_p_p_e_e X C i P Q c d.
  apply pack_c_u_p_p_e_e_inj X' X C' C i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_c_u_p_p_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_u_p_p_e_e (pack_c_u_p_p_e_e X C i P Q c d) -> c :e X.
let X C i P Q c d. assume H1. apply H1 (fun z => z = pack_c_u_p_p_e_e X C i P Q c d -> c :e X).
- let X'. let C'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_p_p_e_e X' C' i' P' Q' c' d' = pack_c_u_p_p_e_e X C i P Q c d.
  apply pack_c_u_p_p_e_e_inj X' X C' C i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_u_p_p_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_u_p_p_e_e (pack_c_u_p_p_e_e X C i P Q c d) -> d :e X.
let X C i P Q c d. assume H1. apply H1 (fun z => z = pack_c_u_p_p_e_e X C i P Q c d -> d :e X).
- let X'. let C'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_u_p_p_e_e X' C' i' P' Q' c' d' = pack_c_u_p_p_e_e X C i P Q c d.
  apply pack_c_u_p_p_e_e_inj X' X C' C i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_u_p_p_e_e_eta: forall S, struct_c_u_p_p_e_e S -> S = pack_c_u_p_p_e_e (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_u_p_p_e_e (z 0) (decode_c (z 1)) (decode_u (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let C. let i. assume _. let P. let Q. let c. assume _. let d. assume _.
prove pack_c_u_p_p_e_e X C i P Q c d = pack_c_u_p_p_e_e (pack_c_u_p_p_e_e X C i P Q c d 0) (decode_c (pack_c_u_p_p_e_e X C i P Q c d 1)) (decode_u (pack_c_u_p_p_e_e X C i P Q c d 2)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 3)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 4)) (pack_c_u_p_p_e_e X C i P Q c d 5) (pack_c_u_p_p_e_e X C i P Q c d 6).
rewrite <- pack_c_u_p_p_e_e_0_eq2 X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_5_eq2 X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_6_eq2 X C i P Q c d.
apply pack_c_u_p_p_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_u_p_p_e_e_1_eq2 X C i P Q c d U HU.
  apply iff_refl.
- exact pack_c_u_p_p_e_e_2_eq2 X C i P Q c d.
- let x. assume Hx.
  rewrite <- pack_c_u_p_p_e_e_3_eq2 X C i P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_u_p_p_e_e_4_eq2 X C i P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_p_p_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_u_p_p_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' i' P' Q' c d = Phi X C i P Q c d)
  ->
  unpack_c_u_p_p_e_e_i (pack_c_u_p_p_e_e X C i P Q c d) Phi = Phi X C i P Q c d.
let Phi X C i P Q c d.
assume HPhi.
prove Phi (pack_c_u_p_p_e_e X C i P Q c d 0) (decode_c (pack_c_u_p_p_e_e X C i P Q c d 1)) (decode_u (pack_c_u_p_p_e_e X C i P Q c d 2)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 3)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 4)) (pack_c_u_p_p_e_e X C i P Q c d 5) (pack_c_u_p_p_e_e X C i P Q c d 6) = Phi X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_0_eq2 X C i P Q c d.
prove Phi X (decode_c (pack_c_u_p_p_e_e X C i P Q c d 1)) (decode_u (pack_c_u_p_p_e_e X C i P Q c d 2)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 3)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 4)) (pack_c_u_p_p_e_e X C i P Q c d 5) (pack_c_u_p_p_e_e X C i P Q c d 6) = Phi X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_5_eq2 X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_6_eq2 X C i P Q c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_p_p_e_e X C i P Q c d 1) U.
  rewrite <- pack_c_u_p_p_e_e_1_eq2 X C i P Q c d U HU.
  apply iff_refl.
- exact pack_c_u_p_p_e_e_2_eq2 X C i P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_p_p_e_e X C i P Q c d 3) x.
  rewrite <- pack_c_u_p_p_e_e_3_eq2 X C i P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_u_p_p_e_e X C i P Q c d 4) x.
  rewrite <- pack_c_u_p_p_e_e_4_eq2 X C i P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_u_p_p_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_u_p_p_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' i' P' Q' c d = Phi X C i P Q c d)
  ->
  unpack_c_u_p_p_e_e_o (pack_c_u_p_p_e_e X C i P Q c d) Phi = Phi X C i P Q c d.
let Phi X C i P Q c d.
assume HPhi.
prove Phi (pack_c_u_p_p_e_e X C i P Q c d 0) (decode_c (pack_c_u_p_p_e_e X C i P Q c d 1)) (decode_u (pack_c_u_p_p_e_e X C i P Q c d 2)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 3)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 4)) (pack_c_u_p_p_e_e X C i P Q c d 5) (pack_c_u_p_p_e_e X C i P Q c d 6) = Phi X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_0_eq2 X C i P Q c d.
prove Phi X (decode_c (pack_c_u_p_p_e_e X C i P Q c d 1)) (decode_u (pack_c_u_p_p_e_e X C i P Q c d 2)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 3)) (decode_p (pack_c_u_p_p_e_e X C i P Q c d 4)) (pack_c_u_p_p_e_e X C i P Q c d 5) (pack_c_u_p_p_e_e X C i P Q c d 6) = Phi X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_5_eq2 X C i P Q c d.
rewrite <- pack_c_u_p_p_e_e_6_eq2 X C i P Q c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_u_p_p_e_e X C i P Q c d 1) U.
  rewrite <- pack_c_u_p_p_e_e_1_eq2 X C i P Q c d U HU.
  apply iff_refl.
- exact pack_c_u_p_p_e_e_2_eq2 X C i P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_u_p_p_e_e X C i P Q c d 3) x.
  rewrite <- pack_c_u_p_p_e_e_3_eq2 X C i P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_u_p_p_e_e X C i P Q c d 4) x.
  rewrite <- pack_c_u_p_p_e_e_4_eq2 X C i P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_c_r_p_p_e_e : set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X C R P Q c d => (X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d).

Theorem pack_c_r_p_p_e_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> X = S 0.
let S X C R P Q c d. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_c_r_p_p_e_e_0_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_c_r_p_p_e_e X C R P Q c d 0.
let X C R P Q c d. apply pack_c_r_p_p_e_e_0_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C R P Q c d. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 1) U.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_c X C U HU.
Qed.

Theorem pack_c_r_p_p_e_e_1_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c_r_p_p_e_e X C R P Q c d 1) U.
let X C R P Q c d. apply pack_c_r_p_p_e_e_1_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X C R P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_c_r_p_p_e_e_2_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_c_r_p_p_e_e X C R P Q c d 2) x y.
let X C R P Q c d. apply pack_c_r_p_p_e_e_2_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X C R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_c_r_p_p_e_e_3_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_c_r_p_p_e_e X C R P Q c d 3) x.
let X C R P Q c d. apply pack_c_r_p_p_e_e_3_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_4_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X C R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_c_r_p_p_e_e_4_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_c_r_p_p_e_e X C R P Q c d 4) x.
let X C R P Q c d. apply pack_c_r_p_p_e_e_4_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_5_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> c = S 5.
let S X C R P Q c d. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_c_r_p_p_e_e_5_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_c_r_p_p_e_e X C R P Q c d 5.
let X C R P Q c d. apply pack_c_r_p_p_e_e_5_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_6_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_c_r_p_p_e_e X C R P Q c d -> d = S 6.
let S X C R P Q c d. assume H1.
rewrite H1. prove d = (X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_c_r_p_p_e_e_6_eq2: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_c_r_p_p_e_e X C R P Q c d 6.
let X C R P Q c d. apply pack_c_r_p_p_e_e_6_eq (pack_c_r_p_p_e_e X C R P Q c d) X C R P Q c d. reflexivity.
Qed.

Theorem pack_c_r_p_p_e_e_inj : forall X X', forall C C':(set -> prop) -> prop, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_c_r_p_p_e_e X C R P Q c d = pack_c_r_p_p_e_e X' C' R' P' Q' c' d' -> X = X' /\ (forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' C C' R R' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_c_r_p_p_e_e X C R P Q c d 0.
{ exact pack_c_r_p_p_e_e_0_eq (pack_c_r_p_p_e_e X C R P Q c d) X' C' R' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_c_r_p_p_e_e_0_eq2 X C R P Q c d. }
apply and7I.
- exact L1.
- let U. assume HU: forall x, U x -> x :e X.
  prove C U = C' U.
  rewrite pack_c_r_p_p_e_e_1_eq2 X C R P Q c d U HU.
  claim LU: forall x, U x -> x :e X'.
  { rewrite <- L1. exact HU. }
  rewrite H1. symmetry.
  exact pack_c_r_p_p_e_e_1_eq2 X' C' R' P' Q' c' d' U LU.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_c_r_p_p_e_e_2_eq2 X C R P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_c_r_p_p_e_e_2_eq2 X' C' R' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_c_r_p_p_e_e_3_eq2 X C R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_r_p_p_e_e_3_eq2 X' C' R' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_c_r_p_p_e_e_4_eq2 X C R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_c_r_p_p_e_e_4_eq2 X' C' R' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_c_r_p_p_e_e_5_eq2 X C R P Q c d.
  rewrite H1. symmetry.
  exact pack_c_r_p_p_e_e_5_eq2 X' C' R' P' Q' c' d'.
- prove d = d'.
  rewrite pack_c_r_p_p_e_e_6_eq2 X C R P Q c d.
  rewrite H1. symmetry.
  exact pack_c_r_p_p_e_e_6_eq2 X' C' R' P' Q' c' d'.
Qed.

Theorem pack_c_r_p_p_e_e_ext : forall X, forall C C':(set -> prop) -> prop, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_c_r_p_p_e_e X C R P Q c d = pack_c_r_p_p_e_e X C' R' P' Q' c d.
let X C C' R R' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_c X C,encode_r X R,encode_p X P,encode_p X Q,c,d) = (X,encode_c X C',encode_r X R',encode_p X P',encode_p X Q',c,d).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_c_r_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_c_r_p_p_e_e X C R P Q c d)) -> q S.

Theorem pack_struct_c_r_p_p_e_e_I: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_c_r_p_p_e_e (pack_c_r_p_p_e_e X C R P Q c d).
let X C R P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X C R P Q c Hc d Hd.
Qed.

Theorem pack_struct_c_r_p_p_e_e_E5: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_r_p_p_e_e (pack_c_r_p_p_e_e X C R P Q c d) -> c :e X.
let X C R P Q c d. assume H1. apply H1 (fun z => z = pack_c_r_p_p_e_e X C R P Q c d -> c :e X).
- let X'. let C'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_r_p_p_e_e X' C' R' P' Q' c' d' = pack_c_r_p_p_e_e X C R P Q c d.
  apply pack_c_r_p_p_e_e_inj X' X C' C R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_c_r_p_p_e_e_E6: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_c_r_p_p_e_e (pack_c_r_p_p_e_e X C R P Q c d) -> d :e X.
let X C R P Q c d. assume H1. apply H1 (fun z => z = pack_c_r_p_p_e_e X C R P Q c d -> d :e X).
- let X'. let C'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_c_r_p_p_e_e X' C' R' P' Q' c' d' = pack_c_r_p_p_e_e X C R P Q c d.
  apply pack_c_r_p_p_e_e_inj X' X C' C R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HC'C HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_c_r_p_p_e_e_eta: forall S, struct_c_r_p_p_e_e S -> S = pack_c_r_p_p_e_e (S 0) (decode_c (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_c_r_p_p_e_e (z 0) (decode_c (z 1)) (decode_r (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let C. let R. let P. let Q. let c. assume _. let d. assume _.
prove pack_c_r_p_p_e_e X C R P Q c d = pack_c_r_p_p_e_e (pack_c_r_p_p_e_e X C R P Q c d 0) (decode_c (pack_c_r_p_p_e_e X C R P Q c d 1)) (decode_r (pack_c_r_p_p_e_e X C R P Q c d 2)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 3)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 4)) (pack_c_r_p_p_e_e X C R P Q c d 5) (pack_c_r_p_p_e_e X C R P Q c d 6).
rewrite <- pack_c_r_p_p_e_e_0_eq2 X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_5_eq2 X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_6_eq2 X C R P Q c d.
apply pack_c_r_p_p_e_e_ext.
- let U. assume HU.
  rewrite <- pack_c_r_p_p_e_e_1_eq2 X C R P Q c d U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_c_r_p_p_e_e_2_eq2 X C R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_r_p_p_e_e_3_eq2 X C R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_c_r_p_p_e_e_4_eq2 X C R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_r_p_p_e_e_i : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_r_p_p_e_e_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' R' P' Q' c d = Phi X C R P Q c d)
  ->
  unpack_c_r_p_p_e_e_i (pack_c_r_p_p_e_e X C R P Q c d) Phi = Phi X C R P Q c d.
let Phi X C R P Q c d.
assume HPhi.
prove Phi (pack_c_r_p_p_e_e X C R P Q c d 0) (decode_c (pack_c_r_p_p_e_e X C R P Q c d 1)) (decode_r (pack_c_r_p_p_e_e X C R P Q c d 2)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 3)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 4)) (pack_c_r_p_p_e_e X C R P Q c d 5) (pack_c_r_p_p_e_e X C R P Q c d 6) = Phi X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_0_eq2 X C R P Q c d.
prove Phi X (decode_c (pack_c_r_p_p_e_e X C R P Q c d 1)) (decode_r (pack_c_r_p_p_e_e X C R P Q c d 2)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 3)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 4)) (pack_c_r_p_p_e_e X C R P Q c d 5) (pack_c_r_p_p_e_e X C R P Q c d 6) = Phi X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_5_eq2 X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_6_eq2 X C R P Q c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_r_p_p_e_e X C R P Q c d 1) U.
  rewrite <- pack_c_r_p_p_e_e_1_eq2 X C R P Q c d U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_r_p_p_e_e X C R P Q c d 2) x y.
  rewrite <- pack_c_r_p_p_e_e_2_eq2 X C R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_r_p_p_e_e X C R P Q c d 3) x.
  rewrite <- pack_c_r_p_p_e_e_3_eq2 X C R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_r_p_p_e_e X C R P Q c d 4) x.
  rewrite <- pack_c_r_p_p_e_e_4_eq2 X C R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_c_r_p_p_e_e_o : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_c_r_p_p_e_e_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X C' R' P' Q' c d = Phi X C R P Q c d)
  ->
  unpack_c_r_p_p_e_e_o (pack_c_r_p_p_e_e X C R P Q c d) Phi = Phi X C R P Q c d.
let Phi X C R P Q c d.
assume HPhi.
prove Phi (pack_c_r_p_p_e_e X C R P Q c d 0) (decode_c (pack_c_r_p_p_e_e X C R P Q c d 1)) (decode_r (pack_c_r_p_p_e_e X C R P Q c d 2)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 3)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 4)) (pack_c_r_p_p_e_e X C R P Q c d 5) (pack_c_r_p_p_e_e X C R P Q c d 6) = Phi X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_0_eq2 X C R P Q c d.
prove Phi X (decode_c (pack_c_r_p_p_e_e X C R P Q c d 1)) (decode_r (pack_c_r_p_p_e_e X C R P Q c d 2)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 3)) (decode_p (pack_c_r_p_p_e_e X C R P Q c d 4)) (pack_c_r_p_p_e_e X C R P Q c d 5) (pack_c_r_p_p_e_e X C R P Q c d 6) = Phi X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_5_eq2 X C R P Q c d.
rewrite <- pack_c_r_p_p_e_e_6_eq2 X C R P Q c d.
apply HPhi.
- let U. assume HU.
  prove C U <-> decode_c (pack_c_r_p_p_e_e X C R P Q c d 1) U.
  rewrite <- pack_c_r_p_p_e_e_1_eq2 X C R P Q c d U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_c_r_p_p_e_e X C R P Q c d 2) x y.
  rewrite <- pack_c_r_p_p_e_e_2_eq2 X C R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_c_r_p_p_e_e X C R P Q c d 3) x.
  rewrite <- pack_c_r_p_p_e_e_3_eq2 X C R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_c_r_p_p_e_e X C R P Q c d 4) x.
  rewrite <- pack_c_r_p_p_e_e_4_eq2 X C R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_u_r : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set := fun X f g h i j R => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R).

Theorem pack_b_b_b_u_u_r_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> X = S 0.
let S X f g h i j R. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_u_r_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, X = pack_b_b_b_u_u_r X f g h i j R 0.
let X f g h i j R. apply pack_b_b_b_u_u_r_0_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i j R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_r_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_u_u_r X f g h i j R 1) x y.
let X f g h i j R. apply pack_b_b_b_u_u_r_1_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i j R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_r_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_u_u_r X f g h i j R 2) x y.
let X f g h i j R. apply pack_b_b_b_u_u_r_2_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i j R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_r_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_u_u_r X f g h i j R 3) x y.
let X f g h i j R. apply pack_b_b_b_u_u_r_3_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i j R. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_u_r_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall x :e X, i x = decode_u (pack_b_b_b_u_u_r X f g h i j R 4) x.
let X f g h i j R. apply pack_b_b_b_u_u_r_4_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> forall x :e X, j x = decode_u (S 5) x.
let S X f g h i j R. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 5) x.
rewrite tuple_7_5_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_b_u_u_r_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall x :e X, j x = decode_u (pack_b_b_b_u_u_r X f g h i j R 5) x.
let X f g h i j R. apply pack_b_b_b_u_u_r_5_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, R x y = decode_r (S 6) x y.
let S X f g h i j R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) 6) x y.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_r_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_b_u_u_r X f g h i j R 6) x y.
let X f g h i j R. apply pack_b_b_b_u_u_r_6_eq (pack_b_b_b_u_u_r X f g h i j R) X f g h i j R. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_r_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, pack_b_b_b_u_u_r X f g h i j R = pack_b_b_b_u_u_r X' f' g' h' i' j' R' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y).
let X X' f f' g g' h h' i i' j j' R R'. assume H1.
claim L0: X' = pack_b_b_b_u_u_r X f g h i j R 0.
{ exact pack_b_b_b_u_u_r_0_eq (pack_b_b_b_u_u_r X f g h i j R) X' f' g' h' i' j' R' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_u_r_0_eq2 X f g h i j R. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_u_r_1_eq2 X f g h i j R x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_r_1_eq2 X' f' g' h' i' j' R' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_u_r_2_eq2 X f g h i j R x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_r_2_eq2 X' f' g' h' i' j' R' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_u_r_3_eq2 X f g h i j R x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_r_3_eq2 X' f' g' h' i' j' R' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_u_r_4_eq2 X f g h i j R x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_r_4_eq2 X' f' g' h' i' j' R' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_b_u_u_r_5_eq2 X f g h i j R x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_r_5_eq2 X' f' g' h' i' j' R' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_u_u_r_6_eq2 X f g h i j R x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_r_6_eq2 X' f' g' h' i' j' R' x Lx y Ly.
Qed.

Theorem pack_b_b_b_u_u_r_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_b_b_u_u_r X f g h i j R = pack_b_b_b_u_u_r X f' g' h' i' j' R'.
let X f f' g g' h h' i i' j j' R R'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_r X R) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_u X j',encode_r X R').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H5. }
rewrite <- L5.
claim L6: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_u_u_r : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, q (pack_b_b_b_u_u_r X f g h i j R)) -> q S.

Theorem pack_struct_b_b_b_u_u_r_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, struct_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let j. assume Hj. let R q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi j Hj R.
Qed.

Theorem pack_struct_b_b_b_u_u_r_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, struct_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R) -> forall x y :e X, f x y :e X.
let X f g h i j R. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let R'.
  assume Heq: pack_b_b_b_u_u_r X' f' g' h' i' j' R' = pack_b_b_b_u_u_r X f g h i j R.
  apply pack_b_b_b_u_u_r_inj X' X f' f g' g h' h i' i j' j R' R Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HR'R.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_r_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, struct_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R) -> forall x y :e X, g x y :e X.
let X f g h i j R. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let R'.
  assume Heq: pack_b_b_b_u_u_r X' f' g' h' i' j' R' = pack_b_b_b_u_u_r X f g h i j R.
  apply pack_b_b_b_u_u_r_inj X' X f' f g' g h' h i' i j' j R' R Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HR'R.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_r_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, struct_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R) -> forall x y :e X, h x y :e X.
let X f g h i j R. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_r X f g h i j R -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let R'.
  assume Heq: pack_b_b_b_u_u_r X' f' g' h' i' j' R' = pack_b_b_b_u_u_r X f g h i j R.
  apply pack_b_b_b_u_u_r_inj X' X f' f g' g h' h i' i j' j R' R Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HR'R.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_r_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, struct_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R) -> forall x :e X, i x :e X.
let X f g h i j R. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_r X f g h i j R -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let R'.
  assume Heq: pack_b_b_b_u_u_r X' f' g' h' i' j' R' = pack_b_b_b_u_u_r X f g h i j R.
  apply pack_b_b_b_u_u_r_inj X' X f' f g' g h' h i' i j' j R' R Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HR'R.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_r_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, struct_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R) -> forall x :e X, j x :e X.
let X f g h i j R. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_r X f g h i j R -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let R'.
  assume Heq: pack_b_b_b_u_u_r X' f' g' h' i' j' R' = pack_b_b_b_u_u_r X f g h i j R.
  apply pack_b_b_b_u_u_r_inj X' X f' f g' g h' h i' i j' j R' R Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HR'R.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_u_r_eta: forall S, struct_b_b_b_u_u_r S -> S = pack_b_b_b_u_u_r (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (decode_r (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_r (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_u (z 5)) (decode_r (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let j. assume _. let R.
prove pack_b_b_b_u_u_r X f g h i j R = pack_b_b_b_u_u_r (pack_b_b_b_u_u_r X f g h i j R 0) (decode_b (pack_b_b_b_u_u_r X f g h i j R 1)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 2)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 3)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 4)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 5)) (decode_r (pack_b_b_b_u_u_r X f g h i j R 6)).
rewrite <- pack_b_b_b_u_u_r_0_eq2 X f g h i j R.
apply pack_b_b_b_u_u_r_ext.
- exact pack_b_b_b_u_u_r_1_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_2_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_3_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_4_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_5_eq2 X f g h i j R.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_u_u_r_6_eq2 X f g h i j R x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_u_r_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (decode_r (S 6)).

Theorem unpack_b_b_b_u_u_r_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' h' i' j' R' = Phi X f g h i j R)
  ->
  unpack_b_b_b_u_u_r_i (pack_b_b_b_u_u_r X f g h i j R) Phi = Phi X f g h i j R.
let Phi X f g h i j R.
assume HPhi.
prove Phi (pack_b_b_b_u_u_r X f g h i j R 0) (decode_b (pack_b_b_b_u_u_r X f g h i j R 1)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 2)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 3)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 4)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 5)) (decode_r (pack_b_b_b_u_u_r X f g h i j R 6)) = Phi X f g h i j R.
rewrite <- pack_b_b_b_u_u_r_0_eq2 X f g h i j R.
prove Phi X (decode_b (pack_b_b_b_u_u_r X f g h i j R 1)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 2)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 3)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 4)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 5)) (decode_r (pack_b_b_b_u_u_r X f g h i j R 6)) = Phi X f g h i j R.
apply HPhi.
- exact pack_b_b_b_u_u_r_1_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_2_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_3_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_4_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_5_eq2 X f g h i j R.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_u_r X f g h i j R 6) x y.
  rewrite <- pack_b_b_b_u_u_r_6_eq2 X f g h i j R x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_u_r_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (decode_r (S 6)).

Theorem unpack_b_b_b_u_u_r_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' h' i' j' R' = Phi X f g h i j R)
  ->
  unpack_b_b_b_u_u_r_o (pack_b_b_b_u_u_r X f g h i j R) Phi = Phi X f g h i j R.
let Phi X f g h i j R.
assume HPhi.
prove Phi (pack_b_b_b_u_u_r X f g h i j R 0) (decode_b (pack_b_b_b_u_u_r X f g h i j R 1)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 2)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 3)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 4)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 5)) (decode_r (pack_b_b_b_u_u_r X f g h i j R 6)) = Phi X f g h i j R.
rewrite <- pack_b_b_b_u_u_r_0_eq2 X f g h i j R.
prove Phi X (decode_b (pack_b_b_b_u_u_r X f g h i j R 1)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 2)) (decode_b (pack_b_b_b_u_u_r X f g h i j R 3)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 4)) (decode_u (pack_b_b_b_u_u_r X f g h i j R 5)) (decode_r (pack_b_b_b_u_u_r X f g h i j R 6)) = Phi X f g h i j R.
apply HPhi.
- exact pack_b_b_b_u_u_r_1_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_2_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_3_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_4_eq2 X f g h i j R.
- exact pack_b_b_b_u_u_r_5_eq2 X f g h i j R.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_u_r X f g h i j R 6) x y.
  rewrite <- pack_b_b_b_u_u_r_6_eq2 X f g h i j R x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_u_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set := fun X f g h i j P => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P).

Theorem pack_b_b_b_u_u_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> X = S 0.
let S X f g h i j P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_u_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, X = pack_b_b_b_u_u_p X f g h i j P 0.
let X f g h i j P. apply pack_b_b_b_u_u_p_0_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i j P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_u_u_p X f g h i j P 1) x y.
let X f g h i j P. apply pack_b_b_b_u_u_p_1_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i j P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_u_u_p X f g h i j P 2) x y.
let X f g h i j P. apply pack_b_b_b_u_u_p_2_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i j P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_u_u_p X f g h i j P 3) x y.
let X f g h i j P. apply pack_b_b_b_u_u_p_3_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i j P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_u_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall x :e X, i x = decode_u (pack_b_b_b_u_u_p X f g h i j P 4) x.
let X f g h i j P. apply pack_b_b_b_u_u_p_4_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> forall x :e X, j x = decode_u (S 5) x.
let S X f g h i j P. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 5) x.
rewrite tuple_7_5_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_b_u_u_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall x :e X, j x = decode_u (pack_b_b_b_u_u_p X f g h i j P 5) x.
let X f g h i j P. apply pack_b_b_b_u_u_p_5_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_b_b_b_u_u_p X f g h i j P -> forall x :e X, P x = decode_p (S 6) x.
let S X f g h i j P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_u_u_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall x :e X, P x = decode_p (pack_b_b_b_u_u_p X f g h i j P 6) x.
let X f g h i j P. apply pack_b_b_b_u_u_p_6_eq (pack_b_b_b_u_u_p X f g h i j P) X f g h i j P. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, pack_b_b_b_u_u_p X f g h i j P = pack_b_b_b_u_u_p X' f' g' h' i' j' P' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x :e X, P x = P' x).
let X X' f f' g g' h h' i i' j j' P P'. assume H1.
claim L0: X' = pack_b_b_b_u_u_p X f g h i j P 0.
{ exact pack_b_b_b_u_u_p_0_eq (pack_b_b_b_u_u_p X f g h i j P) X' f' g' h' i' j' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_u_p_0_eq2 X f g h i j P. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_u_p_1_eq2 X f g h i j P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_p_1_eq2 X' f' g' h' i' j' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_u_p_2_eq2 X f g h i j P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_p_2_eq2 X' f' g' h' i' j' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_u_p_3_eq2 X f g h i j P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_p_3_eq2 X' f' g' h' i' j' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_u_p_4_eq2 X f g h i j P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_p_4_eq2 X' f' g' h' i' j' P' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_b_u_u_p_5_eq2 X f g h i j P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_p_5_eq2 X' f' g' h' i' j' P' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_u_u_p_6_eq2 X f g h i j P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_p_6_eq2 X' f' g' h' i' j' P' x Lx.
Qed.

Theorem pack_b_b_b_u_u_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_b_u_u_p X f g h i j P = pack_b_b_b_u_u_p X f' g' h' i' j' P'.
let X f f' g g' h h' i i' j j' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,encode_p X P) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_u X j',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_u_u_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, q (pack_b_b_b_u_u_p X f g h i j P)) -> q S.

Theorem pack_struct_b_b_b_u_u_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, struct_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let j. assume Hj. let P q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi j Hj P.
Qed.

Theorem pack_struct_b_b_b_u_u_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, struct_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P) -> forall x y :e X, f x y :e X.
let X f g h i j P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_p X f g h i j P -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let P'.
  assume Heq: pack_b_b_b_u_u_p X' f' g' h' i' j' P' = pack_b_b_b_u_u_p X f g h i j P.
  apply pack_b_b_b_u_u_p_inj X' X f' f g' g h' h i' i j' j P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, struct_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P) -> forall x y :e X, g x y :e X.
let X f g h i j P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_p X f g h i j P -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let P'.
  assume Heq: pack_b_b_b_u_u_p X' f' g' h' i' j' P' = pack_b_b_b_u_u_p X f g h i j P.
  apply pack_b_b_b_u_u_p_inj X' X f' f g' g h' h i' i j' j P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, struct_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P) -> forall x y :e X, h x y :e X.
let X f g h i j P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_p X f g h i j P -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let P'.
  assume Heq: pack_b_b_b_u_u_p X' f' g' h' i' j' P' = pack_b_b_b_u_u_p X f g h i j P.
  apply pack_b_b_b_u_u_p_inj X' X f' f g' g h' h i' i j' j P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_p_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, struct_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P) -> forall x :e X, i x :e X.
let X f g h i j P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_p X f g h i j P -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let P'.
  assume Heq: pack_b_b_b_u_u_p X' f' g' h' i' j' P' = pack_b_b_b_u_u_p X f g h i j P.
  apply pack_b_b_b_u_u_p_inj X' X f' f g' g h' h i' i j' j P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_p_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, struct_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P) -> forall x :e X, j x :e X.
let X f g h i j P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_p X f g h i j P -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let P'.
  assume Heq: pack_b_b_b_u_u_p X' f' g' h' i' j' P' = pack_b_b_b_u_u_p X f g h i j P.
  apply pack_b_b_b_u_u_p_inj X' X f' f g' g h' h i' i j' j P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_u_p_eta: forall S, struct_b_b_b_u_u_p S -> S = pack_b_b_b_u_u_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_u (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let j. assume _. let P.
prove pack_b_b_b_u_u_p X f g h i j P = pack_b_b_b_u_u_p (pack_b_b_b_u_u_p X f g h i j P 0) (decode_b (pack_b_b_b_u_u_p X f g h i j P 1)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 2)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 3)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 4)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 5)) (decode_p (pack_b_b_b_u_u_p X f g h i j P 6)).
rewrite <- pack_b_b_b_u_u_p_0_eq2 X f g h i j P.
apply pack_b_b_b_u_u_p_ext.
- exact pack_b_b_b_u_u_p_1_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_2_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_3_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_4_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_5_eq2 X f g h i j P.
- let x. assume Hx.
  rewrite <- pack_b_b_b_u_u_p_6_eq2 X f g h i j P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_u_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_u_u_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' i' j' P' = Phi X f g h i j P)
  ->
  unpack_b_b_b_u_u_p_i (pack_b_b_b_u_u_p X f g h i j P) Phi = Phi X f g h i j P.
let Phi X f g h i j P.
assume HPhi.
prove Phi (pack_b_b_b_u_u_p X f g h i j P 0) (decode_b (pack_b_b_b_u_u_p X f g h i j P 1)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 2)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 3)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 4)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 5)) (decode_p (pack_b_b_b_u_u_p X f g h i j P 6)) = Phi X f g h i j P.
rewrite <- pack_b_b_b_u_u_p_0_eq2 X f g h i j P.
prove Phi X (decode_b (pack_b_b_b_u_u_p X f g h i j P 1)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 2)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 3)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 4)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 5)) (decode_p (pack_b_b_b_u_u_p X f g h i j P 6)) = Phi X f g h i j P.
apply HPhi.
- exact pack_b_b_b_u_u_p_1_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_2_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_3_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_4_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_5_eq2 X f g h i j P.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_u_p X f g h i j P 6) x.
  rewrite <- pack_b_b_b_u_u_p_6_eq2 X f g h i j P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_u_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_u_u_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' i' j' P' = Phi X f g h i j P)
  ->
  unpack_b_b_b_u_u_p_o (pack_b_b_b_u_u_p X f g h i j P) Phi = Phi X f g h i j P.
let Phi X f g h i j P.
assume HPhi.
prove Phi (pack_b_b_b_u_u_p X f g h i j P 0) (decode_b (pack_b_b_b_u_u_p X f g h i j P 1)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 2)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 3)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 4)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 5)) (decode_p (pack_b_b_b_u_u_p X f g h i j P 6)) = Phi X f g h i j P.
rewrite <- pack_b_b_b_u_u_p_0_eq2 X f g h i j P.
prove Phi X (decode_b (pack_b_b_b_u_u_p X f g h i j P 1)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 2)) (decode_b (pack_b_b_b_u_u_p X f g h i j P 3)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 4)) (decode_u (pack_b_b_b_u_u_p X f g h i j P 5)) (decode_p (pack_b_b_b_u_u_p X f g h i j P 6)) = Phi X f g h i j P.
apply HPhi.
- exact pack_b_b_b_u_u_p_1_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_2_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_3_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_4_eq2 X f g h i j P.
- exact pack_b_b_b_u_u_p_5_eq2 X f g h i j P.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_u_p X f g h i j P 6) x.
  rewrite <- pack_b_b_b_u_u_p_6_eq2 X f g h i j P x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_u_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set := fun X f g h i j c => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c).

Theorem pack_b_b_b_u_u_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> X = S 0.
let S X f g h i j c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_u_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, X = pack_b_b_b_u_u_e X f g h i j c 0.
let X f g h i j c. apply pack_b_b_b_u_u_e_0_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i j c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_b_u_u_e X f g h i j c 1) x y.
let X f g h i j c. apply pack_b_b_b_u_u_e_1_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i j c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_b_u_u_e X f g h i j c 2) x y.
let X f g h i j c. apply pack_b_b_b_u_u_e_2_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i j c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_u_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall x y :e X, h x y = decode_b (pack_b_b_b_u_u_e X f g h i j c 3) x y.
let X f g h i j c. apply pack_b_b_b_u_u_e_3_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i j c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_u_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall x :e X, i x = decode_u (pack_b_b_b_u_u_e X f g h i j c 4) x.
let X f g h i j c. apply pack_b_b_b_u_u_e_4_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> forall x :e X, j x = decode_u (S 5) x.
let S X f g h i j c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_b_u_u_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall x :e X, j x = decode_u (pack_b_b_b_u_u_e X f g h i j c 5) x.
let X f g h i j c. apply pack_b_b_b_u_u_e_5_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_b_b_b_u_u_e X f g h i j c -> c = S 6.
let S X f g h i j c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_u_u_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, c = pack_b_b_b_u_u_e X f g h i j c 6.
let X f g h i j c. apply pack_b_b_b_u_u_e_6_eq (pack_b_b_b_u_u_e X f g h i j c) X f g h i j c. reflexivity.
Qed.

Theorem pack_b_b_b_u_u_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall c c':set, pack_b_b_b_u_u_e X f g h i j c = pack_b_b_b_u_u_e X' f' g' h' i' j' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ c = c'.
let X X' f f' g g' h h' i i' j j' c c'. assume H1.
claim L0: X' = pack_b_b_b_u_u_e X f g h i j c 0.
{ exact pack_b_b_b_u_u_e_0_eq (pack_b_b_b_u_u_e X f g h i j c) X' f' g' h' i' j' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_u_e_0_eq2 X f g h i j c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_u_e_1_eq2 X f g h i j c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_e_1_eq2 X' f' g' h' i' j' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_u_e_2_eq2 X f g h i j c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_e_2_eq2 X' f' g' h' i' j' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_u_e_3_eq2 X f g h i j c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_e_3_eq2 X' f' g' h' i' j' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_u_e_4_eq2 X f g h i j c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_e_4_eq2 X' f' g' h' i' j' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_b_u_u_e_5_eq2 X f g h i j c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_e_5_eq2 X' f' g' h' i' j' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_b_u_u_e_6_eq2 X f g h i j c.
  rewrite H1. symmetry.
  exact pack_b_b_b_u_u_e_6_eq2 X' f' g' h' i' j' c'.
Qed.

Theorem pack_b_b_b_u_u_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 pack_b_b_b_u_u_e X f g h i j c = pack_b_b_b_u_u_e X f' g' h' i' j' c.
let X f f' g g' h h' i i' j j' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_u X j,c) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_u X j',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_b_u_u_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall c:set, c :e X -> q (pack_b_b_b_u_u_e X f g h i j c)) -> q S.

Theorem pack_struct_b_b_b_u_u_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall c:set, c :e X -> struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let j. assume Hj. let c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi j Hj c Hc.
Qed.

Theorem pack_struct_b_b_b_u_u_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c) -> forall x y :e X, f x y :e X.
let X f g h i j c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e X f g h i j c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_u_e X' f' g' h' i' j' c' = pack_b_b_b_u_u_e X f g h i j c.
  apply pack_b_b_b_u_u_e_inj X' X f' f g' g h' h i' i j' j c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c) -> forall x y :e X, g x y :e X.
let X f g h i j c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e X f g h i j c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_u_e X' f' g' h' i' j' c' = pack_b_b_b_u_u_e X f g h i j c.
  apply pack_b_b_b_u_u_e_inj X' X f' f g' g h' h i' i j' j c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c) -> forall x y :e X, h x y :e X.
let X f g h i j c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e X f g h i j c -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_u_e X' f' g' h' i' j' c' = pack_b_b_b_u_u_e X f g h i j c.
  apply pack_b_b_b_u_u_e_inj X' X f' f g' g h' h i' i j' j c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c) -> forall x :e X, i x :e X.
let X f g h i j c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e X f g h i j c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_u_e X' f' g' h' i' j' c' = pack_b_b_b_u_u_e X f g h i j c.
  apply pack_b_b_b_u_u_e_inj X' X f' f g' g h' h i' i j' j c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c) -> forall x :e X, j x :e X.
let X f g h i j c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e X f g h i j c -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_u_e X' f' g' h' i' j' c' = pack_b_b_b_u_u_e X f g h i j c.
  apply pack_b_b_b_u_u_e_inj X' X f' f g' g h' h i' i j' j c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_u_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, struct_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c) -> c :e X.
let X f g h i j c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e X f g h i j c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_u_e X' f' g' h' i' j' c' = pack_b_b_b_u_u_e X f g h i j c.
  apply pack_b_b_b_u_u_e_inj X' X f' f g' g h' h i' i j' j c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hj'j Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_u_e_eta: forall S, struct_b_b_b_u_u_e S -> S = pack_b_b_b_u_u_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_u_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_u (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let j. assume _. let c. assume _.
prove pack_b_b_b_u_u_e X f g h i j c = pack_b_b_b_u_u_e (pack_b_b_b_u_u_e X f g h i j c 0) (decode_b (pack_b_b_b_u_u_e X f g h i j c 1)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 2)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 3)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 4)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 5)) (pack_b_b_b_u_u_e X f g h i j c 6).
rewrite <- pack_b_b_b_u_u_e_0_eq2 X f g h i j c.
rewrite <- pack_b_b_b_u_u_e_6_eq2 X f g h i j c.
apply pack_b_b_b_u_u_e_ext.
- exact pack_b_b_b_u_u_e_1_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_2_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_3_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_4_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_5_eq2 X f g h i j c.
Qed.


Definition unpack_b_b_b_u_u_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (S 6).

Theorem unpack_b_b_b_u_u_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) -> Phi X f' g' h' i' j' c = Phi X f g h i j c)
  ->
  unpack_b_b_b_u_u_e_i (pack_b_b_b_u_u_e X f g h i j c) Phi = Phi X f g h i j c.
let Phi X f g h i j c.
assume HPhi.
prove Phi (pack_b_b_b_u_u_e X f g h i j c 0) (decode_b (pack_b_b_b_u_u_e X f g h i j c 1)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 2)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 3)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 4)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 5)) (pack_b_b_b_u_u_e X f g h i j c 6) = Phi X f g h i j c.
rewrite <- pack_b_b_b_u_u_e_0_eq2 X f g h i j c.
prove Phi X (decode_b (pack_b_b_b_u_u_e X f g h i j c 1)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 2)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 3)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 4)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 5)) (pack_b_b_b_u_u_e X f g h i j c 6) = Phi X f g h i j c.
rewrite <- pack_b_b_b_u_u_e_6_eq2 X f g h i j c.
apply HPhi.
- exact pack_b_b_b_u_u_e_1_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_2_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_3_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_4_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_5_eq2 X f g h i j c.
Qed.


Definition unpack_b_b_b_u_u_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_u (S 5)) (S 6).

Theorem unpack_b_b_b_u_u_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) -> Phi X f' g' h' i' j' c = Phi X f g h i j c)
  ->
  unpack_b_b_b_u_u_e_o (pack_b_b_b_u_u_e X f g h i j c) Phi = Phi X f g h i j c.
let Phi X f g h i j c.
assume HPhi.
prove Phi (pack_b_b_b_u_u_e X f g h i j c 0) (decode_b (pack_b_b_b_u_u_e X f g h i j c 1)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 2)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 3)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 4)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 5)) (pack_b_b_b_u_u_e X f g h i j c 6) = Phi X f g h i j c.
rewrite <- pack_b_b_b_u_u_e_0_eq2 X f g h i j c.
prove Phi X (decode_b (pack_b_b_b_u_u_e X f g h i j c 1)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 2)) (decode_b (pack_b_b_b_u_u_e X f g h i j c 3)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 4)) (decode_u (pack_b_b_b_u_u_e X f g h i j c 5)) (pack_b_b_b_u_u_e X f g h i j c 6) = Phi X f g h i j c.
rewrite <- pack_b_b_b_u_u_e_6_eq2 X f g h i j c.
apply HPhi.
- exact pack_b_b_b_u_u_e_1_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_2_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_3_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_4_eq2 X f g h i j c.
- exact pack_b_b_b_u_u_e_5_eq2 X f g h i j c.
Qed.


Definition pack_b_b_b_u_r_r : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set := fun X f g h i R T => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T).

Theorem pack_b_b_b_u_r_r_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> X = S 0.
let S X f g h i R T. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_r_r_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, X = pack_b_b_b_u_r_r X f g h i R T 0.
let X f g h i R T. apply pack_b_b_b_u_r_r_0_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_r_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_u_r_r X f g h i R T 1) x y.
let X f g h i R T. apply pack_b_b_b_u_r_r_1_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_r_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_u_r_r X f g h i R T 2) x y.
let X f g h i R T. apply pack_b_b_b_u_r_r_2_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_r_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_u_r_r X f g h i R T 3) x y.
let X f g h i R T. apply pack_b_b_b_u_r_r_3_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i R T. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_r_r_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x :e X, i x = decode_u (pack_b_b_b_u_r_r X f g h i R T 4) x.
let X f g h i R T. apply pack_b_b_b_u_r_r_4_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X f g h i R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_r_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_b_u_r_r X f g h i R T 5) x y.
let X f g h i R T. apply pack_b_b_b_u_r_r_5_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, T x y = decode_r (S 6) x y.
let S X f g h i R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) 6) x y.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_r_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, T x y = decode_r (pack_b_b_b_u_r_r X f g h i R T 6) x y.
let X f g h i R T. apply pack_b_b_b_u_r_r_6_eq (pack_b_b_b_u_r_r X f g h i R T) X f g h i R T. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_r_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, pack_b_b_b_u_r_r X f g h i R T = pack_b_b_b_u_r_r X' f' g' h' i' R' T' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y).
let X X' f f' g g' h h' i i' R R' T T'. assume H1.
claim L0: X' = pack_b_b_b_u_r_r X f g h i R T 0.
{ exact pack_b_b_b_u_r_r_0_eq (pack_b_b_b_u_r_r X f g h i R T) X' f' g' h' i' R' T' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_r_r_0_eq2 X f g h i R T. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_r_r_1_eq2 X f g h i R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_r_1_eq2 X' f' g' h' i' R' T' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_r_r_2_eq2 X f g h i R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_r_2_eq2 X' f' g' h' i' R' T' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_r_r_3_eq2 X f g h i R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_r_3_eq2 X' f' g' h' i' R' T' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_r_r_4_eq2 X f g h i R T x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_r_4_eq2 X' f' g' h' i' R' T' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_u_r_r_5_eq2 X f g h i R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_r_5_eq2 X' f' g' h' i' R' T' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_b_u_r_r_6_eq2 X f g h i R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_r_6_eq2 X' f' g' h' i' R' T' x Lx y Ly.
Qed.

Theorem pack_b_b_b_u_r_r_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_b_b_b_u_r_r X f g h i R T = pack_b_b_b_u_r_r X f' g' h' i' R' T'.
let X f f' g g' h h' i i' R R' T T'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_r X T) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_r X R',encode_r X T').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_u_r_r : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, q (pack_b_b_b_u_r_r X f g h i R T)) -> q S.

Theorem pack_struct_b_b_b_u_r_r_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_b_u_r_r (pack_b_b_b_u_r_r X f g h i R T).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let R T q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi R T.
Qed.

Theorem pack_struct_b_b_b_u_r_r_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_b_u_r_r (pack_b_b_b_u_r_r X f g h i R T) -> forall x y :e X, f x y :e X.
let X f g h i R T. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let T'.
  assume Heq: pack_b_b_b_u_r_r X' f' g' h' i' R' T' = pack_b_b_b_u_r_r X f g h i R T.
  apply pack_b_b_b_u_r_r_inj X' X f' f g' g h' h i' i R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_r_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_b_u_r_r (pack_b_b_b_u_r_r X f g h i R T) -> forall x y :e X, g x y :e X.
let X f g h i R T. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let T'.
  assume Heq: pack_b_b_b_u_r_r X' f' g' h' i' R' T' = pack_b_b_b_u_r_r X f g h i R T.
  apply pack_b_b_b_u_r_r_inj X' X f' f g' g h' h i' i R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_r_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_b_u_r_r (pack_b_b_b_u_r_r X f g h i R T) -> forall x y :e X, h x y :e X.
let X f g h i R T. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_r X f g h i R T -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let T'.
  assume Heq: pack_b_b_b_u_r_r X' f' g' h' i' R' T' = pack_b_b_b_u_r_r X f g h i R T.
  apply pack_b_b_b_u_r_r_inj X' X f' f g' g h' h i' i R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_r_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_b_u_r_r (pack_b_b_b_u_r_r X f g h i R T) -> forall x :e X, i x :e X.
let X f g h i R T. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_r X f g h i R T -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let T'.
  assume Heq: pack_b_b_b_u_r_r X' f' g' h' i' R' T' = pack_b_b_b_u_r_r X f g h i R T.
  apply pack_b_b_b_u_r_r_inj X' X f' f g' g h' h i' i R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_r_r_eta: forall S, struct_b_b_b_u_r_r S -> S = pack_b_b_b_u_r_r (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_r (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_r (z 5)) (decode_r (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let R. let T.
prove pack_b_b_b_u_r_r X f g h i R T = pack_b_b_b_u_r_r (pack_b_b_b_u_r_r X f g h i R T 0) (decode_b (pack_b_b_b_u_r_r X f g h i R T 1)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 2)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 3)) (decode_u (pack_b_b_b_u_r_r X f g h i R T 4)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 5)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 6)).
rewrite <- pack_b_b_b_u_r_r_0_eq2 X f g h i R T.
apply pack_b_b_b_u_r_r_ext.
- exact pack_b_b_b_u_r_r_1_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_2_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_3_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_4_eq2 X f g h i R T.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_u_r_r_5_eq2 X f g h i R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_u_r_r_6_eq2 X f g h i R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_r_r_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).

Theorem unpack_b_b_b_u_r_r_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' h' i' R' T' = Phi X f g h i R T)
  ->
  unpack_b_b_b_u_r_r_i (pack_b_b_b_u_r_r X f g h i R T) Phi = Phi X f g h i R T.
let Phi X f g h i R T.
assume HPhi.
prove Phi (pack_b_b_b_u_r_r X f g h i R T 0) (decode_b (pack_b_b_b_u_r_r X f g h i R T 1)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 2)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 3)) (decode_u (pack_b_b_b_u_r_r X f g h i R T 4)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 5)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 6)) = Phi X f g h i R T.
rewrite <- pack_b_b_b_u_r_r_0_eq2 X f g h i R T.
prove Phi X (decode_b (pack_b_b_b_u_r_r X f g h i R T 1)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 2)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 3)) (decode_u (pack_b_b_b_u_r_r X f g h i R T 4)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 5)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 6)) = Phi X f g h i R T.
apply HPhi.
- exact pack_b_b_b_u_r_r_1_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_2_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_3_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_4_eq2 X f g h i R T.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_r_r X f g h i R T 5) x y.
  rewrite <- pack_b_b_b_u_r_r_5_eq2 X f g h i R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_b_u_r_r X f g h i R T 6) x y.
  rewrite <- pack_b_b_b_u_r_r_6_eq2 X f g h i R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_r_r_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).

Theorem unpack_b_b_b_u_r_r_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' h' i' R' T' = Phi X f g h i R T)
  ->
  unpack_b_b_b_u_r_r_o (pack_b_b_b_u_r_r X f g h i R T) Phi = Phi X f g h i R T.
let Phi X f g h i R T.
assume HPhi.
prove Phi (pack_b_b_b_u_r_r X f g h i R T 0) (decode_b (pack_b_b_b_u_r_r X f g h i R T 1)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 2)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 3)) (decode_u (pack_b_b_b_u_r_r X f g h i R T 4)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 5)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 6)) = Phi X f g h i R T.
rewrite <- pack_b_b_b_u_r_r_0_eq2 X f g h i R T.
prove Phi X (decode_b (pack_b_b_b_u_r_r X f g h i R T 1)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 2)) (decode_b (pack_b_b_b_u_r_r X f g h i R T 3)) (decode_u (pack_b_b_b_u_r_r X f g h i R T 4)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 5)) (decode_r (pack_b_b_b_u_r_r X f g h i R T 6)) = Phi X f g h i R T.
apply HPhi.
- exact pack_b_b_b_u_r_r_1_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_2_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_3_eq2 X f g h i R T.
- exact pack_b_b_b_u_r_r_4_eq2 X f g h i R T.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_r_r X f g h i R T 5) x y.
  rewrite <- pack_b_b_b_u_r_r_5_eq2 X f g h i R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_b_u_r_r X f g h i R T 6) x y.
  rewrite <- pack_b_b_b_u_r_r_6_eq2 X f g h i R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_r_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set := fun X f g h i R P => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P).

Theorem pack_b_b_b_u_r_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> X = S 0.
let S X f g h i R P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_r_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, X = pack_b_b_b_u_r_p X f g h i R P 0.
let X f g h i R P. apply pack_b_b_b_u_r_p_0_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_u_r_p X f g h i R P 1) x y.
let X f g h i R P. apply pack_b_b_b_u_r_p_1_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_u_r_p X f g h i R P 2) x y.
let X f g h i R P. apply pack_b_b_b_u_r_p_2_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_u_r_p X f g h i R P 3) x y.
let X f g h i R P. apply pack_b_b_b_u_r_p_3_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i R P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_r_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, i x = decode_u (pack_b_b_b_u_r_p X f g h i R P 4) x.
let X f g h i R P. apply pack_b_b_b_u_r_p_4_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X f g h i R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_b_u_r_p X f g h i R P 5) x y.
let X f g h i R P. apply pack_b_b_b_u_r_p_5_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_u_r_p X f g h i R P -> forall x :e X, P x = decode_p (S 6) x.
let S X f g h i R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_u_r_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, P x = decode_p (pack_b_b_b_u_r_p X f g h i R P 6) x.
let X f g h i R P. apply pack_b_b_b_u_r_p_6_eq (pack_b_b_b_u_r_p X f g h i R P) X f g h i R P. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, pack_b_b_b_u_r_p X f g h i R P = pack_b_b_b_u_r_p X' f' g' h' i' R' P' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x).
let X X' f f' g g' h h' i i' R R' P P'. assume H1.
claim L0: X' = pack_b_b_b_u_r_p X f g h i R P 0.
{ exact pack_b_b_b_u_r_p_0_eq (pack_b_b_b_u_r_p X f g h i R P) X' f' g' h' i' R' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_r_p_0_eq2 X f g h i R P. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_r_p_1_eq2 X f g h i R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_p_1_eq2 X' f' g' h' i' R' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_r_p_2_eq2 X f g h i R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_p_2_eq2 X' f' g' h' i' R' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_r_p_3_eq2 X f g h i R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_p_3_eq2 X' f' g' h' i' R' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_r_p_4_eq2 X f g h i R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_p_4_eq2 X' f' g' h' i' R' P' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_u_r_p_5_eq2 X f g h i R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_p_5_eq2 X' f' g' h' i' R' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_u_r_p_6_eq2 X f g h i R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_p_6_eq2 X' f' g' h' i' R' P' x Lx.
Qed.

Theorem pack_b_b_b_u_r_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_b_u_r_p X f g h i R P = pack_b_b_b_u_r_p X f' g' h' i' R' P'.
let X f f' g g' h h' i i' R R' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,encode_p X P) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_r X R',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_u_r_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, q (pack_b_b_b_u_r_p X f g h i R P)) -> q S.

Theorem pack_struct_b_b_b_u_r_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_b_u_r_p (pack_b_b_b_u_r_p X f g h i R P).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let R P q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi R P.
Qed.

Theorem pack_struct_b_b_b_u_r_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_b_u_r_p (pack_b_b_b_u_r_p X f g h i R P) -> forall x y :e X, f x y :e X.
let X f g h i R P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let P'.
  assume Heq: pack_b_b_b_u_r_p X' f' g' h' i' R' P' = pack_b_b_b_u_r_p X f g h i R P.
  apply pack_b_b_b_u_r_p_inj X' X f' f g' g h' h i' i R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_b_u_r_p (pack_b_b_b_u_r_p X f g h i R P) -> forall x y :e X, g x y :e X.
let X f g h i R P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let P'.
  assume Heq: pack_b_b_b_u_r_p X' f' g' h' i' R' P' = pack_b_b_b_u_r_p X f g h i R P.
  apply pack_b_b_b_u_r_p_inj X' X f' f g' g h' h i' i R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_b_u_r_p (pack_b_b_b_u_r_p X f g h i R P) -> forall x y :e X, h x y :e X.
let X f g h i R P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_p X f g h i R P -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let P'.
  assume Heq: pack_b_b_b_u_r_p X' f' g' h' i' R' P' = pack_b_b_b_u_r_p X f g h i R P.
  apply pack_b_b_b_u_r_p_inj X' X f' f g' g h' h i' i R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_p_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_b_u_r_p (pack_b_b_b_u_r_p X f g h i R P) -> forall x :e X, i x :e X.
let X f g h i R P. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_p X f g h i R P -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let P'.
  assume Heq: pack_b_b_b_u_r_p X' f' g' h' i' R' P' = pack_b_b_b_u_r_p X f g h i R P.
  apply pack_b_b_b_u_r_p_inj X' X f' f g' g h' h i' i R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_r_p_eta: forall S, struct_b_b_b_u_r_p S -> S = pack_b_b_b_u_r_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_r (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let R. let P.
prove pack_b_b_b_u_r_p X f g h i R P = pack_b_b_b_u_r_p (pack_b_b_b_u_r_p X f g h i R P 0) (decode_b (pack_b_b_b_u_r_p X f g h i R P 1)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 2)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 3)) (decode_u (pack_b_b_b_u_r_p X f g h i R P 4)) (decode_r (pack_b_b_b_u_r_p X f g h i R P 5)) (decode_p (pack_b_b_b_u_r_p X f g h i R P 6)).
rewrite <- pack_b_b_b_u_r_p_0_eq2 X f g h i R P.
apply pack_b_b_b_u_r_p_ext.
- exact pack_b_b_b_u_r_p_1_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_2_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_3_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_4_eq2 X f g h i R P.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_u_r_p_5_eq2 X f g h i R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_u_r_p_6_eq2 X f g h i R P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_r_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_u_r_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' i' R' P' = Phi X f g h i R P)
  ->
  unpack_b_b_b_u_r_p_i (pack_b_b_b_u_r_p X f g h i R P) Phi = Phi X f g h i R P.
let Phi X f g h i R P.
assume HPhi.
prove Phi (pack_b_b_b_u_r_p X f g h i R P 0) (decode_b (pack_b_b_b_u_r_p X f g h i R P 1)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 2)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 3)) (decode_u (pack_b_b_b_u_r_p X f g h i R P 4)) (decode_r (pack_b_b_b_u_r_p X f g h i R P 5)) (decode_p (pack_b_b_b_u_r_p X f g h i R P 6)) = Phi X f g h i R P.
rewrite <- pack_b_b_b_u_r_p_0_eq2 X f g h i R P.
prove Phi X (decode_b (pack_b_b_b_u_r_p X f g h i R P 1)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 2)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 3)) (decode_u (pack_b_b_b_u_r_p X f g h i R P 4)) (decode_r (pack_b_b_b_u_r_p X f g h i R P 5)) (decode_p (pack_b_b_b_u_r_p X f g h i R P 6)) = Phi X f g h i R P.
apply HPhi.
- exact pack_b_b_b_u_r_p_1_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_2_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_3_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_4_eq2 X f g h i R P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_r_p X f g h i R P 5) x y.
  rewrite <- pack_b_b_b_u_r_p_5_eq2 X f g h i R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_r_p X f g h i R P 6) x.
  rewrite <- pack_b_b_b_u_r_p_6_eq2 X f g h i R P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_r_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_u_r_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' i' R' P' = Phi X f g h i R P)
  ->
  unpack_b_b_b_u_r_p_o (pack_b_b_b_u_r_p X f g h i R P) Phi = Phi X f g h i R P.
let Phi X f g h i R P.
assume HPhi.
prove Phi (pack_b_b_b_u_r_p X f g h i R P 0) (decode_b (pack_b_b_b_u_r_p X f g h i R P 1)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 2)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 3)) (decode_u (pack_b_b_b_u_r_p X f g h i R P 4)) (decode_r (pack_b_b_b_u_r_p X f g h i R P 5)) (decode_p (pack_b_b_b_u_r_p X f g h i R P 6)) = Phi X f g h i R P.
rewrite <- pack_b_b_b_u_r_p_0_eq2 X f g h i R P.
prove Phi X (decode_b (pack_b_b_b_u_r_p X f g h i R P 1)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 2)) (decode_b (pack_b_b_b_u_r_p X f g h i R P 3)) (decode_u (pack_b_b_b_u_r_p X f g h i R P 4)) (decode_r (pack_b_b_b_u_r_p X f g h i R P 5)) (decode_p (pack_b_b_b_u_r_p X f g h i R P 6)) = Phi X f g h i R P.
apply HPhi.
- exact pack_b_b_b_u_r_p_1_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_2_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_3_eq2 X f g h i R P.
- exact pack_b_b_b_u_r_p_4_eq2 X f g h i R P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_r_p X f g h i R P 5) x y.
  rewrite <- pack_b_b_b_u_r_p_5_eq2 X f g h i R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_r_p X f g h i R P 6) x.
  rewrite <- pack_b_b_b_u_r_p_6_eq2 X f g h i R P x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_r_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set := fun X f g h i R c => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c).

Theorem pack_b_b_b_u_r_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> X = S 0.
let S X f g h i R c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_r_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, X = pack_b_b_b_u_r_e X f g h i R c 0.
let X f g h i R c. apply pack_b_b_b_u_r_e_0_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_b_u_r_e X f g h i R c 1) x y.
let X f g h i R c. apply pack_b_b_b_u_r_e_1_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_b_u_r_e X f g h i R c 2) x y.
let X f g h i R c. apply pack_b_b_b_u_r_e_2_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, h x y = decode_b (pack_b_b_b_u_r_e X f g h i R c 3) x y.
let X f g h i R c. apply pack_b_b_b_u_r_e_3_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i R c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_r_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_b_u_r_e X f g h i R c 4) x.
let X f g h i R c. apply pack_b_b_b_u_r_e_4_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X f g h i R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_r_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_b_u_r_e X f g h i R c 5) x y.
let X f g h i R c. apply pack_b_b_b_u_r_e_5_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_b_u_r_e X f g h i R c -> c = S 6.
let S X f g h i R c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_u_r_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, c = pack_b_b_b_u_r_e X f g h i R c 6.
let X f g h i R c. apply pack_b_b_b_u_r_e_6_eq (pack_b_b_b_u_r_e X f g h i R c) X f g h i R c. reflexivity.
Qed.

Theorem pack_b_b_b_u_r_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall c c':set, pack_b_b_b_u_r_e X f g h i R c = pack_b_b_b_u_r_e X' f' g' h' i' R' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ c = c'.
let X X' f f' g g' h h' i i' R R' c c'. assume H1.
claim L0: X' = pack_b_b_b_u_r_e X f g h i R c 0.
{ exact pack_b_b_b_u_r_e_0_eq (pack_b_b_b_u_r_e X f g h i R c) X' f' g' h' i' R' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_r_e_0_eq2 X f g h i R c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_r_e_1_eq2 X f g h i R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_e_1_eq2 X' f' g' h' i' R' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_r_e_2_eq2 X f g h i R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_e_2_eq2 X' f' g' h' i' R' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_r_e_3_eq2 X f g h i R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_e_3_eq2 X' f' g' h' i' R' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_r_e_4_eq2 X f g h i R c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_e_4_eq2 X' f' g' h' i' R' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_u_r_e_5_eq2 X f g h i R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_e_5_eq2 X' f' g' h' i' R' c' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_b_u_r_e_6_eq2 X f g h i R c.
  rewrite H1. symmetry.
  exact pack_b_b_b_u_r_e_6_eq2 X' f' g' h' i' R' c'.
Qed.

Theorem pack_b_b_b_u_r_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_b_b_u_r_e X f g h i R c = pack_b_b_b_u_r_e X f' g' h' i' R' c.
let X f f' g g' h h' i i' R R' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_r X R,c) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_r X R',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_b_u_r_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> q (pack_b_b_b_u_r_e X f g h i R c)) -> q S.

Theorem pack_struct_b_b_b_u_r_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> struct_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let R c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi R c Hc.
Qed.

Theorem pack_struct_b_b_b_u_r_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c) -> forall x y :e X, f x y :e X.
let X f g h i R c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_r_e X' f' g' h' i' R' c' = pack_b_b_b_u_r_e X f g h i R c.
  apply pack_b_b_b_u_r_e_inj X' X f' f g' g h' h i' i R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c) -> forall x y :e X, g x y :e X.
let X f g h i R c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_r_e X' f' g' h' i' R' c' = pack_b_b_b_u_r_e X f g h i R c.
  apply pack_b_b_b_u_r_e_inj X' X f' f g' g h' h i' i R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c) -> forall x y :e X, h x y :e X.
let X f g h i R c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_e X f g h i R c -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_r_e X' f' g' h' i' R' c' = pack_b_b_b_u_r_e X f g h i R c.
  apply pack_b_b_b_u_r_e_inj X' X f' f g' g h' h i' i R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c) -> forall x :e X, i x :e X.
let X f g h i R c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_e X f g h i R c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_r_e X' f' g' h' i' R' c' = pack_b_b_b_u_r_e X f g h i R c.
  apply pack_b_b_b_u_r_e_inj X' X f' f g' g h' h i' i R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_r_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c) -> c :e X.
let X f g h i R c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_e X f g h i R c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_r_e X' f' g' h' i' R' c' = pack_b_b_b_u_r_e X f g h i R c.
  apply pack_b_b_b_u_r_e_inj X' X f' f g' g h' h i' i R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HR'R Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_r_e_eta: forall S, struct_b_b_b_u_r_e S -> S = pack_b_b_b_u_r_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_r_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_r (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let R. let c. assume _.
prove pack_b_b_b_u_r_e X f g h i R c = pack_b_b_b_u_r_e (pack_b_b_b_u_r_e X f g h i R c 0) (decode_b (pack_b_b_b_u_r_e X f g h i R c 1)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 2)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 3)) (decode_u (pack_b_b_b_u_r_e X f g h i R c 4)) (decode_r (pack_b_b_b_u_r_e X f g h i R c 5)) (pack_b_b_b_u_r_e X f g h i R c 6).
rewrite <- pack_b_b_b_u_r_e_0_eq2 X f g h i R c.
rewrite <- pack_b_b_b_u_r_e_6_eq2 X f g h i R c.
apply pack_b_b_b_u_r_e_ext.
- exact pack_b_b_b_u_r_e_1_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_2_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_3_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_4_eq2 X f g h i R c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_u_r_e_5_eq2 X f g h i R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_r_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_b_u_r_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' h' i' R' c = Phi X f g h i R c)
  ->
  unpack_b_b_b_u_r_e_i (pack_b_b_b_u_r_e X f g h i R c) Phi = Phi X f g h i R c.
let Phi X f g h i R c.
assume HPhi.
prove Phi (pack_b_b_b_u_r_e X f g h i R c 0) (decode_b (pack_b_b_b_u_r_e X f g h i R c 1)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 2)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 3)) (decode_u (pack_b_b_b_u_r_e X f g h i R c 4)) (decode_r (pack_b_b_b_u_r_e X f g h i R c 5)) (pack_b_b_b_u_r_e X f g h i R c 6) = Phi X f g h i R c.
rewrite <- pack_b_b_b_u_r_e_0_eq2 X f g h i R c.
prove Phi X (decode_b (pack_b_b_b_u_r_e X f g h i R c 1)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 2)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 3)) (decode_u (pack_b_b_b_u_r_e X f g h i R c 4)) (decode_r (pack_b_b_b_u_r_e X f g h i R c 5)) (pack_b_b_b_u_r_e X f g h i R c 6) = Phi X f g h i R c.
rewrite <- pack_b_b_b_u_r_e_6_eq2 X f g h i R c.
apply HPhi.
- exact pack_b_b_b_u_r_e_1_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_2_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_3_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_4_eq2 X f g h i R c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_r_e X f g h i R c 5) x y.
  rewrite <- pack_b_b_b_u_r_e_5_eq2 X f g h i R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_r_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_b_u_r_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' h' i' R' c = Phi X f g h i R c)
  ->
  unpack_b_b_b_u_r_e_o (pack_b_b_b_u_r_e X f g h i R c) Phi = Phi X f g h i R c.
let Phi X f g h i R c.
assume HPhi.
prove Phi (pack_b_b_b_u_r_e X f g h i R c 0) (decode_b (pack_b_b_b_u_r_e X f g h i R c 1)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 2)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 3)) (decode_u (pack_b_b_b_u_r_e X f g h i R c 4)) (decode_r (pack_b_b_b_u_r_e X f g h i R c 5)) (pack_b_b_b_u_r_e X f g h i R c 6) = Phi X f g h i R c.
rewrite <- pack_b_b_b_u_r_e_0_eq2 X f g h i R c.
prove Phi X (decode_b (pack_b_b_b_u_r_e X f g h i R c 1)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 2)) (decode_b (pack_b_b_b_u_r_e X f g h i R c 3)) (decode_u (pack_b_b_b_u_r_e X f g h i R c 4)) (decode_r (pack_b_b_b_u_r_e X f g h i R c 5)) (pack_b_b_b_u_r_e X f g h i R c 6) = Phi X f g h i R c.
rewrite <- pack_b_b_b_u_r_e_6_eq2 X f g h i R c.
apply HPhi.
- exact pack_b_b_b_u_r_e_1_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_2_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_3_eq2 X f g h i R c.
- exact pack_b_b_b_u_r_e_4_eq2 X f g h i R c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_u_r_e X f g h i R c 5) x y.
  rewrite <- pack_b_b_b_u_r_e_5_eq2 X f g h i R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_p_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set := fun X f g h i P Q => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q).

Theorem pack_b_b_b_u_p_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> X = S 0.
let S X f g h i P Q. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_p_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, X = pack_b_b_b_u_p_p X f g h i P Q 0.
let X f g h i P Q. apply pack_b_b_b_u_p_p_0_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_p_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_u_p_p X f g h i P Q 1) x y.
let X f g h i P Q. apply pack_b_b_b_u_p_p_1_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_p_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_u_p_p X f g h i P Q 2) x y.
let X f g h i P Q. apply pack_b_b_b_u_p_p_2_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_p_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_u_p_p X f g h i P Q 3) x y.
let X f g h i P Q. apply pack_b_b_b_u_p_p_3_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_p_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_b_b_b_u_p_p X f g h i P Q 4) x.
let X f g h i P Q. apply pack_b_b_b_u_p_p_4_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X f g h i P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_u_p_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_b_b_b_u_p_p X f g h i P Q 5) x.
let X f g h i P Q. apply pack_b_b_b_u_p_p_5_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_u_p_p X f g h i P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X f g h i P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_b_u_p_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_b_b_b_u_p_p X f g h i P Q 6) x.
let X f g h i P Q. apply pack_b_b_b_u_p_p_6_eq (pack_b_b_b_u_p_p X f g h i P Q) X f g h i P Q. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, pack_b_b_b_u_p_p X f g h i P Q = pack_b_b_b_u_p_p X' f' g' h' i' P' Q' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' f f' g g' h h' i i' P P' Q Q'. assume H1.
claim L0: X' = pack_b_b_b_u_p_p X f g h i P Q 0.
{ exact pack_b_b_b_u_p_p_0_eq (pack_b_b_b_u_p_p X f g h i P Q) X' f' g' h' i' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_p_p_0_eq2 X f g h i P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_p_p_1_eq2 X f g h i P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_p_1_eq2 X' f' g' h' i' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_p_p_2_eq2 X f g h i P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_p_2_eq2 X' f' g' h' i' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_p_p_3_eq2 X f g h i P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_p_3_eq2 X' f' g' h' i' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_p_p_4_eq2 X f g h i P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_p_4_eq2 X' f' g' h' i' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_u_p_p_5_eq2 X f g h i P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_p_5_eq2 X' f' g' h' i' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_b_u_p_p_6_eq2 X f g h i P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_p_6_eq2 X' f' g' h' i' P' Q' x Lx.
Qed.

Theorem pack_b_b_b_u_p_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_b_u_p_p X f g h i P Q = pack_b_b_b_u_p_p X f' g' h' i' P' Q'.
let X f f' g g' h h' i i' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,encode_p X Q) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_p X P',encode_p X Q').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_u_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, q (pack_b_b_b_u_p_p X f g h i P Q)) -> q S.

Theorem pack_struct_b_b_b_u_p_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_u_p_p (pack_b_b_b_u_p_p X f g h i P Q).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let P Q q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi P Q.
Qed.

Theorem pack_struct_b_b_b_u_p_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_u_p_p (pack_b_b_b_u_p_p X f g h i P Q) -> forall x y :e X, f x y :e X.
let X f g h i P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_p X f g h i P Q -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let Q'.
  assume Heq: pack_b_b_b_u_p_p X' f' g' h' i' P' Q' = pack_b_b_b_u_p_p X f g h i P Q.
  apply pack_b_b_b_u_p_p_inj X' X f' f g' g h' h i' i P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_u_p_p (pack_b_b_b_u_p_p X f g h i P Q) -> forall x y :e X, g x y :e X.
let X f g h i P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_p X f g h i P Q -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let Q'.
  assume Heq: pack_b_b_b_u_p_p X' f' g' h' i' P' Q' = pack_b_b_b_u_p_p X f g h i P Q.
  apply pack_b_b_b_u_p_p_inj X' X f' f g' g h' h i' i P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_u_p_p (pack_b_b_b_u_p_p X f g h i P Q) -> forall x y :e X, h x y :e X.
let X f g h i P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_p X f g h i P Q -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let Q'.
  assume Heq: pack_b_b_b_u_p_p X' f' g' h' i' P' Q' = pack_b_b_b_u_p_p X f g h i P Q.
  apply pack_b_b_b_u_p_p_inj X' X f' f g' g h' h i' i P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_p_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_u_p_p (pack_b_b_b_u_p_p X f g h i P Q) -> forall x :e X, i x :e X.
let X f g h i P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_p X f g h i P Q -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let Q'.
  assume Heq: pack_b_b_b_u_p_p X' f' g' h' i' P' Q' = pack_b_b_b_u_p_p X f g h i P Q.
  apply pack_b_b_b_u_p_p_inj X' X f' f g' g h' h i' i P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_p_p_eta: forall S, struct_b_b_b_u_p_p S -> S = pack_b_b_b_u_p_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let P. let Q.
prove pack_b_b_b_u_p_p X f g h i P Q = pack_b_b_b_u_p_p (pack_b_b_b_u_p_p X f g h i P Q 0) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 1)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 2)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 3)) (decode_u (pack_b_b_b_u_p_p X f g h i P Q 4)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 5)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 6)).
rewrite <- pack_b_b_b_u_p_p_0_eq2 X f g h i P Q.
apply pack_b_b_b_u_p_p_ext.
- exact pack_b_b_b_u_p_p_1_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_2_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_3_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_4_eq2 X f g h i P Q.
- let x. assume Hx.
  rewrite <- pack_b_b_b_u_p_p_5_eq2 X f g h i P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_u_p_p_6_eq2 X f g h i P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_p_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_u_p_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' h' i' P' Q' = Phi X f g h i P Q)
  ->
  unpack_b_b_b_u_p_p_i (pack_b_b_b_u_p_p X f g h i P Q) Phi = Phi X f g h i P Q.
let Phi X f g h i P Q.
assume HPhi.
prove Phi (pack_b_b_b_u_p_p X f g h i P Q 0) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 1)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 2)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 3)) (decode_u (pack_b_b_b_u_p_p X f g h i P Q 4)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 5)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 6)) = Phi X f g h i P Q.
rewrite <- pack_b_b_b_u_p_p_0_eq2 X f g h i P Q.
prove Phi X (decode_b (pack_b_b_b_u_p_p X f g h i P Q 1)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 2)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 3)) (decode_u (pack_b_b_b_u_p_p X f g h i P Q 4)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 5)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 6)) = Phi X f g h i P Q.
apply HPhi.
- exact pack_b_b_b_u_p_p_1_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_2_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_3_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_4_eq2 X f g h i P Q.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_p_p X f g h i P Q 5) x.
  rewrite <- pack_b_b_b_u_p_p_5_eq2 X f g h i P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_b_u_p_p X f g h i P Q 6) x.
  rewrite <- pack_b_b_b_u_p_p_6_eq2 X f g h i P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_p_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_u_p_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' h' i' P' Q' = Phi X f g h i P Q)
  ->
  unpack_b_b_b_u_p_p_o (pack_b_b_b_u_p_p X f g h i P Q) Phi = Phi X f g h i P Q.
let Phi X f g h i P Q.
assume HPhi.
prove Phi (pack_b_b_b_u_p_p X f g h i P Q 0) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 1)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 2)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 3)) (decode_u (pack_b_b_b_u_p_p X f g h i P Q 4)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 5)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 6)) = Phi X f g h i P Q.
rewrite <- pack_b_b_b_u_p_p_0_eq2 X f g h i P Q.
prove Phi X (decode_b (pack_b_b_b_u_p_p X f g h i P Q 1)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 2)) (decode_b (pack_b_b_b_u_p_p X f g h i P Q 3)) (decode_u (pack_b_b_b_u_p_p X f g h i P Q 4)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 5)) (decode_p (pack_b_b_b_u_p_p X f g h i P Q 6)) = Phi X f g h i P Q.
apply HPhi.
- exact pack_b_b_b_u_p_p_1_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_2_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_3_eq2 X f g h i P Q.
- exact pack_b_b_b_u_p_p_4_eq2 X f g h i P Q.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_p_p X f g h i P Q 5) x.
  rewrite <- pack_b_b_b_u_p_p_5_eq2 X f g h i P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_b_u_p_p X f g h i P Q 6) x.
  rewrite <- pack_b_b_b_u_p_p_6_eq2 X f g h i P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set := fun X f g h i P c => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c).

Theorem pack_b_b_b_u_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> X = S 0.
let S X f g h i P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, X = pack_b_b_b_u_p_e X f g h i P c 0.
let X f g h i P c. apply pack_b_b_b_u_p_e_0_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_b_u_p_e X f g h i P c 1) x y.
let X f g h i P c. apply pack_b_b_b_u_p_e_1_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_b_u_p_e X f g h i P c 2) x y.
let X f g h i P c. apply pack_b_b_b_u_p_e_2_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall x y :e X, h x y = decode_b (pack_b_b_b_u_p_e X f g h i P c 3) x y.
let X f g h i P c. apply pack_b_b_b_u_p_e_3_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_b_u_p_e X f g h i P c 4) x.
let X f g h i P c. apply pack_b_b_b_u_p_e_4_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> forall x :e X, P x = decode_p (S 5) x.
let S X f g h i P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_u_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_b_u_p_e X f g h i P c 5) x.
let X f g h i P c. apply pack_b_b_b_u_p_e_5_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_b_u_p_e X f g h i P c -> c = S 6.
let S X f g h i P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_u_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, c = pack_b_b_b_u_p_e X f g h i P c 6.
let X f g h i P c. apply pack_b_b_b_u_p_e_6_eq (pack_b_b_b_u_p_e X f g h i P c) X f g h i P c. reflexivity.
Qed.

Theorem pack_b_b_b_u_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall c c':set, pack_b_b_b_u_p_e X f g h i P c = pack_b_b_b_u_p_e X' f' g' h' i' P' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' f f' g g' h h' i i' P P' c c'. assume H1.
claim L0: X' = pack_b_b_b_u_p_e X f g h i P c 0.
{ exact pack_b_b_b_u_p_e_0_eq (pack_b_b_b_u_p_e X f g h i P c) X' f' g' h' i' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_p_e_0_eq2 X f g h i P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_p_e_1_eq2 X f g h i P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_e_1_eq2 X' f' g' h' i' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_p_e_2_eq2 X f g h i P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_e_2_eq2 X' f' g' h' i' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_p_e_3_eq2 X f g h i P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_e_3_eq2 X' f' g' h' i' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_p_e_4_eq2 X f g h i P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_e_4_eq2 X' f' g' h' i' P' c' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_u_p_e_5_eq2 X f g h i P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_e_5_eq2 X' f' g' h' i' P' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_b_u_p_e_6_eq2 X f g h i P c.
  rewrite H1. symmetry.
  exact pack_b_b_b_u_p_e_6_eq2 X' f' g' h' i' P' c'.
Qed.

Theorem pack_b_b_b_u_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_b_u_p_e X f g h i P c = pack_b_b_b_u_p_e X f' g' h' i' P' c.
let X f f' g g' h h' i i' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,encode_p X P,c) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_b_u_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall c:set, c :e X -> q (pack_b_b_b_u_p_e X f g h i P c)) -> q S.

Theorem pack_struct_b_b_b_u_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall c:set, c :e X -> struct_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let P c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi P c Hc.
Qed.

Theorem pack_struct_b_b_b_u_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, struct_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c) -> forall x y :e X, f x y :e X.
let X f g h i P c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_e X f g h i P c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_p_e X' f' g' h' i' P' c' = pack_b_b_b_u_p_e X f g h i P c.
  apply pack_b_b_b_u_p_e_inj X' X f' f g' g h' h i' i P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, struct_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c) -> forall x y :e X, g x y :e X.
let X f g h i P c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_e X f g h i P c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_p_e X' f' g' h' i' P' c' = pack_b_b_b_u_p_e X f g h i P c.
  apply pack_b_b_b_u_p_e_inj X' X f' f g' g h' h i' i P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, struct_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c) -> forall x y :e X, h x y :e X.
let X f g h i P c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_e X f g h i P c -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_p_e X' f' g' h' i' P' c' = pack_b_b_b_u_p_e X f g h i P c.
  apply pack_b_b_b_u_p_e_inj X' X f' f g' g h' h i' i P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, struct_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c) -> forall x :e X, i x :e X.
let X f g h i P c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_e X f g h i P c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_p_e X' f' g' h' i' P' c' = pack_b_b_b_u_p_e X f g h i P c.
  apply pack_b_b_b_u_p_e_inj X' X f' f g' g h' h i' i P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, struct_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c) -> c :e X.
let X f g h i P c. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_e X f g h i P c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_u_p_e X' f' g' h' i' P' c' = pack_b_b_b_u_p_e X f g h i P c.
  apply pack_b_b_b_u_p_e_inj X' X f' f g' g h' h i' i P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_p_e_eta: forall S, struct_b_b_b_u_p_e S -> S = pack_b_b_b_u_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let P. let c. assume _.
prove pack_b_b_b_u_p_e X f g h i P c = pack_b_b_b_u_p_e (pack_b_b_b_u_p_e X f g h i P c 0) (decode_b (pack_b_b_b_u_p_e X f g h i P c 1)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 2)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 3)) (decode_u (pack_b_b_b_u_p_e X f g h i P c 4)) (decode_p (pack_b_b_b_u_p_e X f g h i P c 5)) (pack_b_b_b_u_p_e X f g h i P c 6).
rewrite <- pack_b_b_b_u_p_e_0_eq2 X f g h i P c.
rewrite <- pack_b_b_b_u_p_e_6_eq2 X f g h i P c.
apply pack_b_b_b_u_p_e_ext.
- exact pack_b_b_b_u_p_e_1_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_2_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_3_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_4_eq2 X f g h i P c.
- let x. assume Hx.
  rewrite <- pack_b_b_b_u_p_e_5_eq2 X f g h i P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_b_u_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' i' P' c = Phi X f g h i P c)
  ->
  unpack_b_b_b_u_p_e_i (pack_b_b_b_u_p_e X f g h i P c) Phi = Phi X f g h i P c.
let Phi X f g h i P c.
assume HPhi.
prove Phi (pack_b_b_b_u_p_e X f g h i P c 0) (decode_b (pack_b_b_b_u_p_e X f g h i P c 1)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 2)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 3)) (decode_u (pack_b_b_b_u_p_e X f g h i P c 4)) (decode_p (pack_b_b_b_u_p_e X f g h i P c 5)) (pack_b_b_b_u_p_e X f g h i P c 6) = Phi X f g h i P c.
rewrite <- pack_b_b_b_u_p_e_0_eq2 X f g h i P c.
prove Phi X (decode_b (pack_b_b_b_u_p_e X f g h i P c 1)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 2)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 3)) (decode_u (pack_b_b_b_u_p_e X f g h i P c 4)) (decode_p (pack_b_b_b_u_p_e X f g h i P c 5)) (pack_b_b_b_u_p_e X f g h i P c 6) = Phi X f g h i P c.
rewrite <- pack_b_b_b_u_p_e_6_eq2 X f g h i P c.
apply HPhi.
- exact pack_b_b_b_u_p_e_1_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_2_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_3_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_4_eq2 X f g h i P c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_p_e X f g h i P c 5) x.
  rewrite <- pack_b_b_b_u_p_e_5_eq2 X f g h i P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_u_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_b_u_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' i' P' c = Phi X f g h i P c)
  ->
  unpack_b_b_b_u_p_e_o (pack_b_b_b_u_p_e X f g h i P c) Phi = Phi X f g h i P c.
let Phi X f g h i P c.
assume HPhi.
prove Phi (pack_b_b_b_u_p_e X f g h i P c 0) (decode_b (pack_b_b_b_u_p_e X f g h i P c 1)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 2)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 3)) (decode_u (pack_b_b_b_u_p_e X f g h i P c 4)) (decode_p (pack_b_b_b_u_p_e X f g h i P c 5)) (pack_b_b_b_u_p_e X f g h i P c 6) = Phi X f g h i P c.
rewrite <- pack_b_b_b_u_p_e_0_eq2 X f g h i P c.
prove Phi X (decode_b (pack_b_b_b_u_p_e X f g h i P c 1)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 2)) (decode_b (pack_b_b_b_u_p_e X f g h i P c 3)) (decode_u (pack_b_b_b_u_p_e X f g h i P c 4)) (decode_p (pack_b_b_b_u_p_e X f g h i P c 5)) (pack_b_b_b_u_p_e X f g h i P c 6) = Phi X f g h i P c.
rewrite <- pack_b_b_b_u_p_e_6_eq2 X f g h i P c.
apply HPhi.
- exact pack_b_b_b_u_p_e_1_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_2_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_3_eq2 X f g h i P c.
- exact pack_b_b_b_u_p_e_4_eq2 X f g h i P c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_u_p_e X f g h i P c 5) x.
  rewrite <- pack_b_b_b_u_p_e_5_eq2 X f g h i P c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_u_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> set -> set -> set := fun X f g h i c d => (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d).

Theorem pack_b_b_b_u_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> X = S 0.
let S X f g h i c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_u_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, X = pack_b_b_b_u_e_e X f g h i c d 0.
let X f g h i c d. apply pack_b_b_b_u_e_e_0_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h i c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_b_u_e_e X f g h i c d 1) x y.
let X f g h i c d. apply pack_b_b_b_u_e_e_1_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h i c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_b_u_e_e X f g h i c d 2) x y.
let X f g h i c d. apply pack_b_b_b_u_e_e_2_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h i c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_u_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, forall x y :e X, h x y = decode_b (pack_b_b_b_u_e_e X f g h i c d 3) x y.
let X f g h i c d. apply pack_b_b_b_u_e_e_3_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> forall x :e X, i x = decode_u (S 4) x.
let S X f g h i c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_b_u_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_b_b_u_e_e X f g h i c d 4) x.
let X f g h i c d. apply pack_b_b_b_u_e_e_4_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> c = S 5.
let S X f g h i c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_b_u_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, c = pack_b_b_b_u_e_e X f g h i c d 5.
let X f g h i c d. apply pack_b_b_b_u_e_e_5_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, S = pack_b_b_b_u_e_e X f g h i c d -> d = S 6.
let S X f g h i c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_u_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, d = pack_b_b_b_u_e_e X f g h i c d 6.
let X f g h i c d. apply pack_b_b_b_u_e_e_6_eq (pack_b_b_b_u_e_e X f g h i c d) X f g h i c d. reflexivity.
Qed.

Theorem pack_b_b_b_u_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall c c':set, forall d d':set, pack_b_b_b_u_e_e X f g h i c d = pack_b_b_b_u_e_e X' f' g' h' i' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, i x = i' x) /\ c = c' /\ d = d'.
let X X' f f' g g' h h' i i' c c' d d'. assume H1.
claim L0: X' = pack_b_b_b_u_e_e X f g h i c d 0.
{ exact pack_b_b_b_u_e_e_0_eq (pack_b_b_b_u_e_e X f g h i c d) X' f' g' h' i' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_u_e_e_0_eq2 X f g h i c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_u_e_e_1_eq2 X f g h i c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_e_e_1_eq2 X' f' g' h' i' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_u_e_e_2_eq2 X f g h i c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_e_e_2_eq2 X' f' g' h' i' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_u_e_e_3_eq2 X f g h i c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_e_e_3_eq2 X' f' g' h' i' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_b_u_e_e_4_eq2 X f g h i c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_u_e_e_4_eq2 X' f' g' h' i' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_b_b_u_e_e_5_eq2 X f g h i c d.
  rewrite H1. symmetry.
  exact pack_b_b_b_u_e_e_5_eq2 X' f' g' h' i' c' d'.
- prove d = d'.
  rewrite pack_b_b_b_u_e_e_6_eq2 X f g h i c d.
  rewrite H1. symmetry.
  exact pack_b_b_b_u_e_e_6_eq2 X' f' g' h' i' c' d'.
Qed.

Theorem pack_b_b_b_u_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall i i':set -> set, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, i x = i' x) ->
 pack_b_b_b_u_e_e X f g h i c d = pack_b_b_b_u_e_e X f' g' h' i' c d.
let X f f' g g' h h' i i' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_u X i,c,d) = (X,encode_b X f',encode_b X g',encode_b X h',encode_u X i',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_b_u_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_b_u_e_e X f g h i c d)) -> q S.

Theorem pack_struct_b_b_b_u_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let i. assume Hi. let c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg h Hh i Hi c Hc d Hd.
Qed.

Theorem pack_struct_b_b_b_u_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d) -> forall x y :e X, f x y :e X.
let X f g h i c d. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e X f g h i c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_u_e_e X' f' g' h' i' c' d' = pack_b_b_b_u_e_e X f g h i c d.
  apply pack_b_b_b_u_e_e_inj X' X f' f g' g h' h i' i c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d) -> forall x y :e X, g x y :e X.
let X f g h i c d. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e X f g h i c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_u_e_e X' f' g' h' i' c' d' = pack_b_b_b_u_e_e X f g h i c d.
  apply pack_b_b_b_u_e_e_inj X' X f' f g' g h' h i' i c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_e_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d) -> forall x y :e X, h x y :e X.
let X f g h i c d. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e X f g h i c d -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_u_e_e X' f' g' h' i' c' d' = pack_b_b_b_u_e_e X f g h i c d.
  apply pack_b_b_b_u_e_e_inj X' X f' f g' g h' h i' i c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_e_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d) -> forall x :e X, i x :e X.
let X f g h i c d. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e X f g h i c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_u_e_e X' f' g' h' i' c' d' = pack_b_b_b_u_e_e X f g h i c d.
  apply pack_b_b_b_u_e_e_inj X' X f' f g' g h' h i' i c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d) -> c :e X.
let X f g h i c d. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e X f g h i c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_u_e_e X' f' g' h' i' c' d' = pack_b_b_b_u_e_e X f g h i c d.
  apply pack_b_b_b_u_e_e_inj X' X f' f g' g h' h i' i c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_u_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set, struct_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d) -> d :e X.
let X f g h i c d. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e X f g h i c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let i'. assume Hi'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_u_e_e X' f' g' h' i' c' d' = pack_b_b_b_u_e_e X f g h i c d.
  apply pack_b_b_b_u_e_e_inj X' X f' f g' g h' h i' i c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h Hi'i Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_b_u_e_e_eta: forall S, struct_b_b_b_u_e_e S -> S = pack_b_b_b_u_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_u_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_u (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let i. assume _. let c. assume _. let d. assume _.
prove pack_b_b_b_u_e_e X f g h i c d = pack_b_b_b_u_e_e (pack_b_b_b_u_e_e X f g h i c d 0) (decode_b (pack_b_b_b_u_e_e X f g h i c d 1)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 2)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 3)) (decode_u (pack_b_b_b_u_e_e X f g h i c d 4)) (pack_b_b_b_u_e_e X f g h i c d 5) (pack_b_b_b_u_e_e X f g h i c d 6).
rewrite <- pack_b_b_b_u_e_e_0_eq2 X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_5_eq2 X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_6_eq2 X f g h i c d.
apply pack_b_b_b_u_e_e_ext.
- exact pack_b_b_b_u_e_e_1_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_2_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_3_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_4_eq2 X f g h i c d.
Qed.


Definition unpack_b_b_b_u_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (S 5) (S 6).

Theorem unpack_b_b_b_u_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) -> Phi X f' g' h' i' c d = Phi X f g h i c d)
  ->
  unpack_b_b_b_u_e_e_i (pack_b_b_b_u_e_e X f g h i c d) Phi = Phi X f g h i c d.
let Phi X f g h i c d.
assume HPhi.
prove Phi (pack_b_b_b_u_e_e X f g h i c d 0) (decode_b (pack_b_b_b_u_e_e X f g h i c d 1)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 2)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 3)) (decode_u (pack_b_b_b_u_e_e X f g h i c d 4)) (pack_b_b_b_u_e_e X f g h i c d 5) (pack_b_b_b_u_e_e X f g h i c d 6) = Phi X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_0_eq2 X f g h i c d.
prove Phi X (decode_b (pack_b_b_b_u_e_e X f g h i c d 1)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 2)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 3)) (decode_u (pack_b_b_b_u_e_e X f g h i c d 4)) (pack_b_b_b_u_e_e X f g h i c d 5) (pack_b_b_b_u_e_e X f g h i c d 6) = Phi X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_5_eq2 X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_6_eq2 X f g h i c d.
apply HPhi.
- exact pack_b_b_b_u_e_e_1_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_2_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_3_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_4_eq2 X f g h i c d.
Qed.


Definition unpack_b_b_b_u_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_u (S 4)) (S 5) (S 6).

Theorem unpack_b_b_b_u_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall i:set -> set, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) -> Phi X f' g' h' i' c d = Phi X f g h i c d)
  ->
  unpack_b_b_b_u_e_e_o (pack_b_b_b_u_e_e X f g h i c d) Phi = Phi X f g h i c d.
let Phi X f g h i c d.
assume HPhi.
prove Phi (pack_b_b_b_u_e_e X f g h i c d 0) (decode_b (pack_b_b_b_u_e_e X f g h i c d 1)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 2)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 3)) (decode_u (pack_b_b_b_u_e_e X f g h i c d 4)) (pack_b_b_b_u_e_e X f g h i c d 5) (pack_b_b_b_u_e_e X f g h i c d 6) = Phi X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_0_eq2 X f g h i c d.
prove Phi X (decode_b (pack_b_b_b_u_e_e X f g h i c d 1)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 2)) (decode_b (pack_b_b_b_u_e_e X f g h i c d 3)) (decode_u (pack_b_b_b_u_e_e X f g h i c d 4)) (pack_b_b_b_u_e_e X f g h i c d 5) (pack_b_b_b_u_e_e X f g h i c d 6) = Phi X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_5_eq2 X f g h i c d.
rewrite <- pack_b_b_b_u_e_e_6_eq2 X f g h i c d.
apply HPhi.
- exact pack_b_b_b_u_e_e_1_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_2_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_3_eq2 X f g h i c d.
- exact pack_b_b_b_u_e_e_4_eq2 X f g h i c d.
Qed.


Definition pack_b_b_b_r_r_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set := fun X f g h R T P => (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P).

Theorem pack_b_b_b_r_r_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> X = S 0.
let S X f g h R T P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_r_r_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, X = pack_b_b_b_r_r_p X f g h R T P 0.
let X f g h R T P. apply pack_b_b_b_r_r_p_0_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_r_r_p X f g h R T P 1) x y.
let X f g h R T P. apply pack_b_b_b_r_r_p_1_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_r_r_p X f g h R T P 2) x y.
let X f g h R T P. apply pack_b_b_b_r_r_p_2_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_r_r_p X f g h R T P 3) x y.
let X f g h R T P. apply pack_b_b_b_r_r_p_3_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g h R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_b_r_r_p X f g h R T P 4) x y.
let X f g h R T P. apply pack_b_b_b_r_r_p_4_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, T x y = decode_r (S 5) x y.
let S X f g h R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, T x y = decode_r (pack_b_b_b_r_r_p X f g h R T P 5) x y.
let X f g h R T P. apply pack_b_b_b_r_r_p_5_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_b_r_r_p X f g h R T P -> forall x :e X, P x = decode_p (S 6) x.
let S X f g h R T P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_r_r_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x :e X, P x = decode_p (pack_b_b_b_r_r_p X f g h R T P 6) x.
let X f g h R T P. apply pack_b_b_b_r_r_p_6_eq (pack_b_b_b_r_r_p X f g h R T P) X f g h R T P. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, pack_b_b_b_r_r_p X f g h R T P = pack_b_b_b_r_r_p X' f' g' h' R' T' P' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x).
let X X' f f' g g' h h' R R' T T' P P'. assume H1.
claim L0: X' = pack_b_b_b_r_r_p X f g h R T P 0.
{ exact pack_b_b_b_r_r_p_0_eq (pack_b_b_b_r_r_p X f g h R T P) X' f' g' h' R' T' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_r_r_p_0_eq2 X f g h R T P. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_r_r_p_1_eq2 X f g h R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_p_1_eq2 X' f' g' h' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_r_r_p_2_eq2 X f g h R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_p_2_eq2 X' f' g' h' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_r_r_p_3_eq2 X f g h R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_p_3_eq2 X' f' g' h' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_r_r_p_4_eq2 X f g h R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_p_4_eq2 X' f' g' h' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_b_r_r_p_5_eq2 X f g h R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_p_5_eq2 X' f' g' h' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_r_r_p_6_eq2 X f g h R T P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_p_6_eq2 X' f' g' h' R' T' P' x Lx.
Qed.

Theorem pack_b_b_b_r_r_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_b_r_r_p X f g h R T P = pack_b_b_b_r_r_p X f' g' h' R' T' P'.
let X f f' g g' h h' R R' T T' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,encode_p X P) = (X,encode_b X f',encode_b X g',encode_b X h',encode_r X R',encode_r X T',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_r_r_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, q (pack_b_b_b_r_r_p X f g h R T P)) -> q S.

Theorem pack_struct_b_b_b_r_r_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_b_r_r_p (pack_b_b_b_r_r_p X f g h R T P).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let R T P q. assume Hq.
exact Hq X f Hf g Hg h Hh R T P.
Qed.

Theorem pack_struct_b_b_b_r_r_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_b_r_r_p (pack_b_b_b_r_r_p X f g h R T P) -> forall x y :e X, f x y :e X.
let X f g h R T P. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let P'.
  assume Heq: pack_b_b_b_r_r_p X' f' g' h' R' T' P' = pack_b_b_b_r_r_p X f g h R T P.
  apply pack_b_b_b_r_r_p_inj X' X f' f g' g h' h R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_r_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_b_r_r_p (pack_b_b_b_r_r_p X f g h R T P) -> forall x y :e X, g x y :e X.
let X f g h R T P. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let P'.
  assume Heq: pack_b_b_b_r_r_p X' f' g' h' R' T' P' = pack_b_b_b_r_r_p X f g h R T P.
  apply pack_b_b_b_r_r_p_inj X' X f' f g' g h' h R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_r_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_b_r_r_p (pack_b_b_b_r_r_p X f g h R T P) -> forall x y :e X, h x y :e X.
let X f g h R T P. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_p X f g h R T P -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let P'.
  assume Heq: pack_b_b_b_r_r_p X' f' g' h' R' T' P' = pack_b_b_b_r_r_p X f g h R T P.
  apply pack_b_b_b_r_r_p_inj X' X f' f g' g h' h R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem struct_b_b_b_r_r_p_eta: forall S, struct_b_b_b_r_r_p S -> S = pack_b_b_b_r_r_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_r (z 4)) (decode_r (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let R. let T. let P.
prove pack_b_b_b_r_r_p X f g h R T P = pack_b_b_b_r_r_p (pack_b_b_b_r_r_p X f g h R T P 0) (decode_b (pack_b_b_b_r_r_p X f g h R T P 1)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 2)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 3)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 4)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 5)) (decode_p (pack_b_b_b_r_r_p X f g h R T P 6)).
rewrite <- pack_b_b_b_r_r_p_0_eq2 X f g h R T P.
apply pack_b_b_b_r_r_p_ext.
- exact pack_b_b_b_r_r_p_1_eq2 X f g h R T P.
- exact pack_b_b_b_r_r_p_2_eq2 X f g h R T P.
- exact pack_b_b_b_r_r_p_3_eq2 X f g h R T P.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_r_p_4_eq2 X f g h R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_r_p_5_eq2 X f g h R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_r_r_p_6_eq2 X f g h R T P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_r_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_r_r_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' R' T' P' = Phi X f g h R T P)
  ->
  unpack_b_b_b_r_r_p_i (pack_b_b_b_r_r_p X f g h R T P) Phi = Phi X f g h R T P.
let Phi X f g h R T P.
assume HPhi.
prove Phi (pack_b_b_b_r_r_p X f g h R T P 0) (decode_b (pack_b_b_b_r_r_p X f g h R T P 1)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 2)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 3)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 4)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 5)) (decode_p (pack_b_b_b_r_r_p X f g h R T P 6)) = Phi X f g h R T P.
rewrite <- pack_b_b_b_r_r_p_0_eq2 X f g h R T P.
prove Phi X (decode_b (pack_b_b_b_r_r_p X f g h R T P 1)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 2)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 3)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 4)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 5)) (decode_p (pack_b_b_b_r_r_p X f g h R T P 6)) = Phi X f g h R T P.
apply HPhi.
- exact pack_b_b_b_r_r_p_1_eq2 X f g h R T P.
- exact pack_b_b_b_r_r_p_2_eq2 X f g h R T P.
- exact pack_b_b_b_r_r_p_3_eq2 X f g h R T P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_r_p X f g h R T P 4) x y.
  rewrite <- pack_b_b_b_r_r_p_4_eq2 X f g h R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_b_r_r_p X f g h R T P 5) x y.
  rewrite <- pack_b_b_b_r_r_p_5_eq2 X f g h R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_r_r_p X f g h R T P 6) x.
  rewrite <- pack_b_b_b_r_r_p_6_eq2 X f g h R T P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_r_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_r_r_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' R' T' P' = Phi X f g h R T P)
  ->
  unpack_b_b_b_r_r_p_o (pack_b_b_b_r_r_p X f g h R T P) Phi = Phi X f g h R T P.
let Phi X f g h R T P.
assume HPhi.
prove Phi (pack_b_b_b_r_r_p X f g h R T P 0) (decode_b (pack_b_b_b_r_r_p X f g h R T P 1)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 2)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 3)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 4)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 5)) (decode_p (pack_b_b_b_r_r_p X f g h R T P 6)) = Phi X f g h R T P.
rewrite <- pack_b_b_b_r_r_p_0_eq2 X f g h R T P.
prove Phi X (decode_b (pack_b_b_b_r_r_p X f g h R T P 1)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 2)) (decode_b (pack_b_b_b_r_r_p X f g h R T P 3)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 4)) (decode_r (pack_b_b_b_r_r_p X f g h R T P 5)) (decode_p (pack_b_b_b_r_r_p X f g h R T P 6)) = Phi X f g h R T P.
apply HPhi.
- exact pack_b_b_b_r_r_p_1_eq2 X f g h R T P.
- exact pack_b_b_b_r_r_p_2_eq2 X f g h R T P.
- exact pack_b_b_b_r_r_p_3_eq2 X f g h R T P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_r_p X f g h R T P 4) x y.
  rewrite <- pack_b_b_b_r_r_p_4_eq2 X f g h R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_b_r_r_p X f g h R T P 5) x y.
  rewrite <- pack_b_b_b_r_r_p_5_eq2 X f g h R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_r_r_p X f g h R T P 6) x.
  rewrite <- pack_b_b_b_r_r_p_6_eq2 X f g h R T P x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_r_r_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set := fun X f g h R T c => (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c).

Theorem pack_b_b_b_r_r_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> X = S 0.
let S X f g h R T c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_r_r_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, X = pack_b_b_b_r_r_e X f g h R T c 0.
let X f g h R T c. apply pack_b_b_b_r_r_e_0_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_b_r_r_e X f g h R T c 1) x y.
let X f g h R T c. apply pack_b_b_b_r_r_e_1_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_b_r_r_e X f g h R T c 2) x y.
let X f g h R T c. apply pack_b_b_b_r_r_e_2_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, h x y = decode_b (pack_b_b_b_r_r_e X f g h R T c 3) x y.
let X f g h R T c. apply pack_b_b_b_r_r_e_3_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g h R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_b_r_r_e X f g h R T c 4) x y.
let X f g h R T c. apply pack_b_b_b_r_r_e_4_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, T x y = decode_r (S 5) x y.
let S X f g h R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_r_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_b_b_b_r_r_e X f g h R T c 5) x y.
let X f g h R T c. apply pack_b_b_b_r_r_e_5_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_b_r_r_e X f g h R T c -> c = S 6.
let S X f g h R T c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_r_r_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c = pack_b_b_b_r_r_e X f g h R T c 6.
let X f g h R T c. apply pack_b_b_b_r_r_e_6_eq (pack_b_b_b_r_r_e X f g h R T c) X f g h R T c. reflexivity.
Qed.

Theorem pack_b_b_b_r_r_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, pack_b_b_b_r_r_e X f g h R T c = pack_b_b_b_r_r_e X' f' g' h' R' T' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c'.
let X X' f f' g g' h h' R R' T T' c c'. assume H1.
claim L0: X' = pack_b_b_b_r_r_e X f g h R T c 0.
{ exact pack_b_b_b_r_r_e_0_eq (pack_b_b_b_r_r_e X f g h R T c) X' f' g' h' R' T' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_r_r_e_0_eq2 X f g h R T c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_r_r_e_1_eq2 X f g h R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_e_1_eq2 X' f' g' h' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_r_r_e_2_eq2 X f g h R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_e_2_eq2 X' f' g' h' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_r_r_e_3_eq2 X f g h R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_e_3_eq2 X' f' g' h' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_r_r_e_4_eq2 X f g h R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_e_4_eq2 X' f' g' h' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_b_r_r_e_5_eq2 X f g h R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_e_5_eq2 X' f' g' h' R' T' c' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_b_r_r_e_6_eq2 X f g h R T c.
  rewrite H1. symmetry.
  exact pack_b_b_b_r_r_e_6_eq2 X' f' g' h' R' T' c'.
Qed.

Theorem pack_b_b_b_r_r_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_b_b_b_r_r_e X f g h R T c = pack_b_b_b_r_r_e X f' g' h' R' T' c.
let X f f' g g' h h' R R' T T' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_r X T,c) = (X,encode_b X f',encode_b X g',encode_b X h',encode_r X R',encode_r X T',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_b_r_r_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> q (pack_b_b_b_r_r_e X f g h R T c)) -> q S.

Theorem pack_struct_b_b_b_r_r_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> struct_b_b_b_r_r_e (pack_b_b_b_r_r_e X f g h R T c).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let R T c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg h Hh R T c Hc.
Qed.

Theorem pack_struct_b_b_b_r_r_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_b_r_r_e (pack_b_b_b_r_r_e X f g h R T c) -> forall x y :e X, f x y :e X.
let X f g h R T c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_r_e X' f' g' h' R' T' c' = pack_b_b_b_r_r_e X f g h R T c.
  apply pack_b_b_b_r_r_e_inj X' X f' f g' g h' h R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_r_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_b_r_r_e (pack_b_b_b_r_r_e X f g h R T c) -> forall x y :e X, g x y :e X.
let X f g h R T c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_r_e X' f' g' h' R' T' c' = pack_b_b_b_r_r_e X f g h R T c.
  apply pack_b_b_b_r_r_e_inj X' X f' f g' g h' h R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_r_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_b_r_r_e (pack_b_b_b_r_r_e X f g h R T c) -> forall x y :e X, h x y :e X.
let X f g h R T c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_e X f g h R T c -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_r_e X' f' g' h' R' T' c' = pack_b_b_b_r_r_e X f g h R T c.
  apply pack_b_b_b_r_r_e_inj X' X f' f g' g h' h R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_r_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_b_r_r_e (pack_b_b_b_r_r_e X f g h R T c) -> c :e X.
let X f g h R T c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_e X f g h R T c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_r_e X' f' g' h' R' T' c' = pack_b_b_b_r_r_e X f g h R T c.
  apply pack_b_b_b_r_r_e_inj X' X f' f g' g h' h R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HT'T Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_b_r_r_e_eta: forall S, struct_b_b_b_r_r_e S -> S = pack_b_b_b_r_r_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_r_r_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_r (z 4)) (decode_r (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let R. let T. let c. assume _.
prove pack_b_b_b_r_r_e X f g h R T c = pack_b_b_b_r_r_e (pack_b_b_b_r_r_e X f g h R T c 0) (decode_b (pack_b_b_b_r_r_e X f g h R T c 1)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 2)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 3)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 4)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 5)) (pack_b_b_b_r_r_e X f g h R T c 6).
rewrite <- pack_b_b_b_r_r_e_0_eq2 X f g h R T c.
rewrite <- pack_b_b_b_r_r_e_6_eq2 X f g h R T c.
apply pack_b_b_b_r_r_e_ext.
- exact pack_b_b_b_r_r_e_1_eq2 X f g h R T c.
- exact pack_b_b_b_r_r_e_2_eq2 X f g h R T c.
- exact pack_b_b_b_r_r_e_3_eq2 X f g h R T c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_r_e_4_eq2 X f g h R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_r_e_5_eq2 X f g h R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_r_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_b_r_r_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' h' R' T' c = Phi X f g h R T c)
  ->
  unpack_b_b_b_r_r_e_i (pack_b_b_b_r_r_e X f g h R T c) Phi = Phi X f g h R T c.
let Phi X f g h R T c.
assume HPhi.
prove Phi (pack_b_b_b_r_r_e X f g h R T c 0) (decode_b (pack_b_b_b_r_r_e X f g h R T c 1)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 2)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 3)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 4)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 5)) (pack_b_b_b_r_r_e X f g h R T c 6) = Phi X f g h R T c.
rewrite <- pack_b_b_b_r_r_e_0_eq2 X f g h R T c.
prove Phi X (decode_b (pack_b_b_b_r_r_e X f g h R T c 1)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 2)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 3)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 4)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 5)) (pack_b_b_b_r_r_e X f g h R T c 6) = Phi X f g h R T c.
rewrite <- pack_b_b_b_r_r_e_6_eq2 X f g h R T c.
apply HPhi.
- exact pack_b_b_b_r_r_e_1_eq2 X f g h R T c.
- exact pack_b_b_b_r_r_e_2_eq2 X f g h R T c.
- exact pack_b_b_b_r_r_e_3_eq2 X f g h R T c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_r_e X f g h R T c 4) x y.
  rewrite <- pack_b_b_b_r_r_e_4_eq2 X f g h R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_b_r_r_e X f g h R T c 5) x y.
  rewrite <- pack_b_b_b_r_r_e_5_eq2 X f g h R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_r_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_b_r_r_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' h' R' T' c = Phi X f g h R T c)
  ->
  unpack_b_b_b_r_r_e_o (pack_b_b_b_r_r_e X f g h R T c) Phi = Phi X f g h R T c.
let Phi X f g h R T c.
assume HPhi.
prove Phi (pack_b_b_b_r_r_e X f g h R T c 0) (decode_b (pack_b_b_b_r_r_e X f g h R T c 1)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 2)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 3)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 4)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 5)) (pack_b_b_b_r_r_e X f g h R T c 6) = Phi X f g h R T c.
rewrite <- pack_b_b_b_r_r_e_0_eq2 X f g h R T c.
prove Phi X (decode_b (pack_b_b_b_r_r_e X f g h R T c 1)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 2)) (decode_b (pack_b_b_b_r_r_e X f g h R T c 3)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 4)) (decode_r (pack_b_b_b_r_r_e X f g h R T c 5)) (pack_b_b_b_r_r_e X f g h R T c 6) = Phi X f g h R T c.
rewrite <- pack_b_b_b_r_r_e_6_eq2 X f g h R T c.
apply HPhi.
- exact pack_b_b_b_r_r_e_1_eq2 X f g h R T c.
- exact pack_b_b_b_r_r_e_2_eq2 X f g h R T c.
- exact pack_b_b_b_r_r_e_3_eq2 X f g h R T c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_r_e X f g h R T c 4) x y.
  rewrite <- pack_b_b_b_r_r_e_4_eq2 X f g h R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_b_r_r_e X f g h R T c 5) x y.
  rewrite <- pack_b_b_b_r_r_e_5_eq2 X f g h R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_b_r_p_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X f g h R P Q => (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q).

Theorem pack_b_b_b_r_p_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> X = S 0.
let S X f g h R P Q. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_r_p_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_b_b_b_r_p_p X f g h R P Q 0.
let X f g h R P Q. apply pack_b_b_b_r_p_p_0_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_b_r_p_p X f g h R P Q 1) x y.
let X f g h R P Q. apply pack_b_b_b_r_p_p_1_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_b_r_p_p X f g h R P Q 2) x y.
let X f g h R P Q. apply pack_b_b_b_r_p_p_2_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, h x y = decode_b (pack_b_b_b_r_p_p X f g h R P Q 3) x y.
let X f g h R P Q. apply pack_b_b_b_r_p_p_3_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g h R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_b_r_p_p X f g h R P Q 4) x y.
let X f g h R P Q. apply pack_b_b_b_r_p_p_4_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X f g h R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_r_p_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_b_b_b_r_p_p X f g h R P Q 5) x.
let X f g h R P Q. apply pack_b_b_b_r_p_p_5_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_b_r_p_p X f g h R P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X f g h R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_b_r_p_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_b_b_b_r_p_p X f g h R P Q 6) x.
let X f g h R P Q. apply pack_b_b_b_r_p_p_6_eq (pack_b_b_b_r_p_p X f g h R P Q) X f g h R P Q. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_b_b_b_r_p_p X f g h R P Q = pack_b_b_b_r_p_p X' f' g' h' R' P' Q' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' f f' g g' h h' R R' P P' Q Q'. assume H1.
claim L0: X' = pack_b_b_b_r_p_p X f g h R P Q 0.
{ exact pack_b_b_b_r_p_p_0_eq (pack_b_b_b_r_p_p X f g h R P Q) X' f' g' h' R' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_r_p_p_0_eq2 X f g h R P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_r_p_p_1_eq2 X f g h R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_p_1_eq2 X' f' g' h' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_r_p_p_2_eq2 X f g h R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_p_2_eq2 X' f' g' h' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_r_p_p_3_eq2 X f g h R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_p_3_eq2 X' f' g' h' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_r_p_p_4_eq2 X f g h R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_p_4_eq2 X' f' g' h' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_r_p_p_5_eq2 X f g h R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_p_5_eq2 X' f' g' h' R' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_b_r_p_p_6_eq2 X f g h R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_p_6_eq2 X' f' g' h' R' P' Q' x Lx.
Qed.

Theorem pack_b_b_b_r_p_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_b_r_p_p X f g h R P Q = pack_b_b_b_r_p_p X f' g' h' R' P' Q'.
let X f f' g g' h h' R R' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,encode_p X Q) = (X,encode_b X f',encode_b X g',encode_b X h',encode_r X R',encode_p X P',encode_p X Q').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_b_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_b_b_b_r_p_p X f g h R P Q)) -> q S.

Theorem pack_struct_b_b_b_r_p_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_r_p_p (pack_b_b_b_r_p_p X f g h R P Q).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let R P Q q. assume Hq.
exact Hq X f Hf g Hg h Hh R P Q.
Qed.

Theorem pack_struct_b_b_b_r_p_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_r_p_p (pack_b_b_b_r_p_p X f g h R P Q) -> forall x y :e X, f x y :e X.
let X f g h R P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let Q'.
  assume Heq: pack_b_b_b_r_p_p X' f' g' h' R' P' Q' = pack_b_b_b_r_p_p X f g h R P Q.
  apply pack_b_b_b_r_p_p_inj X' X f' f g' g h' h R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_p_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_r_p_p (pack_b_b_b_r_p_p X f g h R P Q) -> forall x y :e X, g x y :e X.
let X f g h R P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let Q'.
  assume Heq: pack_b_b_b_r_p_p X' f' g' h' R' P' Q' = pack_b_b_b_r_p_p X f g h R P Q.
  apply pack_b_b_b_r_p_p_inj X' X f' f g' g h' h R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_p_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_b_r_p_p (pack_b_b_b_r_p_p X f g h R P Q) -> forall x y :e X, h x y :e X.
let X f g h R P Q. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_p X f g h R P Q -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let Q'.
  assume Heq: pack_b_b_b_r_p_p X' f' g' h' R' P' Q' = pack_b_b_b_r_p_p X f g h R P Q.
  apply pack_b_b_b_r_p_p_inj X' X f' f g' g h' h R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem struct_b_b_b_r_p_p_eta: forall S, struct_b_b_b_r_p_p S -> S = pack_b_b_b_r_p_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let h. assume _. let R. let P. let Q.
prove pack_b_b_b_r_p_p X f g h R P Q = pack_b_b_b_r_p_p (pack_b_b_b_r_p_p X f g h R P Q 0) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 1)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 2)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 3)) (decode_r (pack_b_b_b_r_p_p X f g h R P Q 4)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 5)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 6)).
rewrite <- pack_b_b_b_r_p_p_0_eq2 X f g h R P Q.
apply pack_b_b_b_r_p_p_ext.
- exact pack_b_b_b_r_p_p_1_eq2 X f g h R P Q.
- exact pack_b_b_b_r_p_p_2_eq2 X f g h R P Q.
- exact pack_b_b_b_r_p_p_3_eq2 X f g h R P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_p_p_4_eq2 X f g h R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_r_p_p_5_eq2 X f g h R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_r_p_p_6_eq2 X f g h R P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_p_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_r_p_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' h' R' P' Q' = Phi X f g h R P Q)
  ->
  unpack_b_b_b_r_p_p_i (pack_b_b_b_r_p_p X f g h R P Q) Phi = Phi X f g h R P Q.
let Phi X f g h R P Q.
assume HPhi.
prove Phi (pack_b_b_b_r_p_p X f g h R P Q 0) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 1)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 2)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 3)) (decode_r (pack_b_b_b_r_p_p X f g h R P Q 4)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 5)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 6)) = Phi X f g h R P Q.
rewrite <- pack_b_b_b_r_p_p_0_eq2 X f g h R P Q.
prove Phi X (decode_b (pack_b_b_b_r_p_p X f g h R P Q 1)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 2)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 3)) (decode_r (pack_b_b_b_r_p_p X f g h R P Q 4)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 5)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 6)) = Phi X f g h R P Q.
apply HPhi.
- exact pack_b_b_b_r_p_p_1_eq2 X f g h R P Q.
- exact pack_b_b_b_r_p_p_2_eq2 X f g h R P Q.
- exact pack_b_b_b_r_p_p_3_eq2 X f g h R P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_p_p X f g h R P Q 4) x y.
  rewrite <- pack_b_b_b_r_p_p_4_eq2 X f g h R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_r_p_p X f g h R P Q 5) x.
  rewrite <- pack_b_b_b_r_p_p_5_eq2 X f g h R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_b_r_p_p X f g h R P Q 6) x.
  rewrite <- pack_b_b_b_r_p_p_6_eq2 X f g h R P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_p_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_b_r_p_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' h' R' P' Q' = Phi X f g h R P Q)
  ->
  unpack_b_b_b_r_p_p_o (pack_b_b_b_r_p_p X f g h R P Q) Phi = Phi X f g h R P Q.
let Phi X f g h R P Q.
assume HPhi.
prove Phi (pack_b_b_b_r_p_p X f g h R P Q 0) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 1)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 2)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 3)) (decode_r (pack_b_b_b_r_p_p X f g h R P Q 4)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 5)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 6)) = Phi X f g h R P Q.
rewrite <- pack_b_b_b_r_p_p_0_eq2 X f g h R P Q.
prove Phi X (decode_b (pack_b_b_b_r_p_p X f g h R P Q 1)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 2)) (decode_b (pack_b_b_b_r_p_p X f g h R P Q 3)) (decode_r (pack_b_b_b_r_p_p X f g h R P Q 4)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 5)) (decode_p (pack_b_b_b_r_p_p X f g h R P Q 6)) = Phi X f g h R P Q.
apply HPhi.
- exact pack_b_b_b_r_p_p_1_eq2 X f g h R P Q.
- exact pack_b_b_b_r_p_p_2_eq2 X f g h R P Q.
- exact pack_b_b_b_r_p_p_3_eq2 X f g h R P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_p_p X f g h R P Q 4) x y.
  rewrite <- pack_b_b_b_r_p_p_4_eq2 X f g h R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_r_p_p X f g h R P Q 5) x.
  rewrite <- pack_b_b_b_r_p_p_5_eq2 X f g h R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_b_r_p_p X f g h R P Q 6) x.
  rewrite <- pack_b_b_b_r_p_p_6_eq2 X f g h R P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_r_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X f g h R P c => (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c).

Theorem pack_b_b_b_r_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> X = S 0.
let S X f g h R P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_r_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_b_b_b_r_p_e X f g h R P c 0.
let X f g h R P c. apply pack_b_b_b_r_p_e_0_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_b_r_p_e X f g h R P c 1) x y.
let X f g h R P c. apply pack_b_b_b_r_p_e_1_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_b_r_p_e X f g h R P c 2) x y.
let X f g h R P c. apply pack_b_b_b_r_p_e_2_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, h x y = decode_b (pack_b_b_b_r_p_e X f g h R P c 3) x y.
let X f g h R P c. apply pack_b_b_b_r_p_e_3_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g h R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_b_r_p_e X f g h R P c 4) x y.
let X f g h R P c. apply pack_b_b_b_r_p_e_4_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> forall x :e X, P x = decode_p (S 5) x.
let S X f g h R P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_r_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_b_r_p_e X f g h R P c 5) x.
let X f g h R P c. apply pack_b_b_b_r_p_e_5_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_b_r_p_e X f g h R P c -> c = S 6.
let S X f g h R P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_r_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_b_b_b_r_p_e X f g h R P c 6.
let X f g h R P c. apply pack_b_b_b_r_p_e_6_eq (pack_b_b_b_r_p_e X f g h R P c) X f g h R P c. reflexivity.
Qed.

Theorem pack_b_b_b_r_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_b_b_b_r_p_e X f g h R P c = pack_b_b_b_r_p_e X' f' g' h' R' P' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' f f' g g' h h' R R' P P' c c'. assume H1.
claim L0: X' = pack_b_b_b_r_p_e X f g h R P c 0.
{ exact pack_b_b_b_r_p_e_0_eq (pack_b_b_b_r_p_e X f g h R P c) X' f' g' h' R' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_r_p_e_0_eq2 X f g h R P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_r_p_e_1_eq2 X f g h R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_e_1_eq2 X' f' g' h' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_r_p_e_2_eq2 X f g h R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_e_2_eq2 X' f' g' h' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_r_p_e_3_eq2 X f g h R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_e_3_eq2 X' f' g' h' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_r_p_e_4_eq2 X f g h R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_e_4_eq2 X' f' g' h' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_r_p_e_5_eq2 X f g h R P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_e_5_eq2 X' f' g' h' R' P' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_b_r_p_e_6_eq2 X f g h R P c.
  rewrite H1. symmetry.
  exact pack_b_b_b_r_p_e_6_eq2 X' f' g' h' R' P' c'.
Qed.

Theorem pack_b_b_b_r_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_b_r_p_e X f g h R P c = pack_b_b_b_r_p_e X f' g' h' R' P' c.
let X f f' g g' h h' R R' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,encode_p X P,c) = (X,encode_b X f',encode_b X g',encode_b X h',encode_r X R',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_b_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_b_b_b_r_p_e X f g h R P c)) -> q S.

Theorem pack_struct_b_b_b_r_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_b_b_b_r_p_e (pack_b_b_b_r_p_e X f g h R P c).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let R P c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg h Hh R P c Hc.
Qed.

Theorem pack_struct_b_b_b_r_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_b_r_p_e (pack_b_b_b_r_p_e X f g h R P c) -> forall x y :e X, f x y :e X.
let X f g h R P c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_p_e X' f' g' h' R' P' c' = pack_b_b_b_r_p_e X f g h R P c.
  apply pack_b_b_b_r_p_e_inj X' X f' f g' g h' h R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_b_r_p_e (pack_b_b_b_r_p_e X f g h R P c) -> forall x y :e X, g x y :e X.
let X f g h R P c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_p_e X' f' g' h' R' P' c' = pack_b_b_b_r_p_e X f g h R P c.
  apply pack_b_b_b_r_p_e_inj X' X f' f g' g h' h R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_p_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_b_r_p_e (pack_b_b_b_r_p_e X f g h R P c) -> forall x y :e X, h x y :e X.
let X f g h R P c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_e X f g h R P c -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_p_e X' f' g' h' R' P' c' = pack_b_b_b_r_p_e X f g h R P c.
  apply pack_b_b_b_r_p_e_inj X' X f' f g' g h' h R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_b_r_p_e (pack_b_b_b_r_p_e X f g h R P c) -> c :e X.
let X f g h R P c. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_e X f g h R P c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_r_p_e X' f' g' h' R' P' c' = pack_b_b_b_r_p_e X f g h R P c.
  apply pack_b_b_b_r_p_e_inj X' X f' f g' g h' h R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_b_r_p_e_eta: forall S, struct_b_b_b_r_p_e S -> S = pack_b_b_b_r_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_r_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let R. let P. let c. assume _.
prove pack_b_b_b_r_p_e X f g h R P c = pack_b_b_b_r_p_e (pack_b_b_b_r_p_e X f g h R P c 0) (decode_b (pack_b_b_b_r_p_e X f g h R P c 1)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 2)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 3)) (decode_r (pack_b_b_b_r_p_e X f g h R P c 4)) (decode_p (pack_b_b_b_r_p_e X f g h R P c 5)) (pack_b_b_b_r_p_e X f g h R P c 6).
rewrite <- pack_b_b_b_r_p_e_0_eq2 X f g h R P c.
rewrite <- pack_b_b_b_r_p_e_6_eq2 X f g h R P c.
apply pack_b_b_b_r_p_e_ext.
- exact pack_b_b_b_r_p_e_1_eq2 X f g h R P c.
- exact pack_b_b_b_r_p_e_2_eq2 X f g h R P c.
- exact pack_b_b_b_r_p_e_3_eq2 X f g h R P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_p_e_4_eq2 X f g h R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_r_p_e_5_eq2 X f g h R P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_b_r_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' R' P' c = Phi X f g h R P c)
  ->
  unpack_b_b_b_r_p_e_i (pack_b_b_b_r_p_e X f g h R P c) Phi = Phi X f g h R P c.
let Phi X f g h R P c.
assume HPhi.
prove Phi (pack_b_b_b_r_p_e X f g h R P c 0) (decode_b (pack_b_b_b_r_p_e X f g h R P c 1)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 2)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 3)) (decode_r (pack_b_b_b_r_p_e X f g h R P c 4)) (decode_p (pack_b_b_b_r_p_e X f g h R P c 5)) (pack_b_b_b_r_p_e X f g h R P c 6) = Phi X f g h R P c.
rewrite <- pack_b_b_b_r_p_e_0_eq2 X f g h R P c.
prove Phi X (decode_b (pack_b_b_b_r_p_e X f g h R P c 1)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 2)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 3)) (decode_r (pack_b_b_b_r_p_e X f g h R P c 4)) (decode_p (pack_b_b_b_r_p_e X f g h R P c 5)) (pack_b_b_b_r_p_e X f g h R P c 6) = Phi X f g h R P c.
rewrite <- pack_b_b_b_r_p_e_6_eq2 X f g h R P c.
apply HPhi.
- exact pack_b_b_b_r_p_e_1_eq2 X f g h R P c.
- exact pack_b_b_b_r_p_e_2_eq2 X f g h R P c.
- exact pack_b_b_b_r_p_e_3_eq2 X f g h R P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_p_e X f g h R P c 4) x y.
  rewrite <- pack_b_b_b_r_p_e_4_eq2 X f g h R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_r_p_e X f g h R P c 5) x.
  rewrite <- pack_b_b_b_r_p_e_5_eq2 X f g h R P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_b_r_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' R' P' c = Phi X f g h R P c)
  ->
  unpack_b_b_b_r_p_e_o (pack_b_b_b_r_p_e X f g h R P c) Phi = Phi X f g h R P c.
let Phi X f g h R P c.
assume HPhi.
prove Phi (pack_b_b_b_r_p_e X f g h R P c 0) (decode_b (pack_b_b_b_r_p_e X f g h R P c 1)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 2)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 3)) (decode_r (pack_b_b_b_r_p_e X f g h R P c 4)) (decode_p (pack_b_b_b_r_p_e X f g h R P c 5)) (pack_b_b_b_r_p_e X f g h R P c 6) = Phi X f g h R P c.
rewrite <- pack_b_b_b_r_p_e_0_eq2 X f g h R P c.
prove Phi X (decode_b (pack_b_b_b_r_p_e X f g h R P c 1)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 2)) (decode_b (pack_b_b_b_r_p_e X f g h R P c 3)) (decode_r (pack_b_b_b_r_p_e X f g h R P c 4)) (decode_p (pack_b_b_b_r_p_e X f g h R P c 5)) (pack_b_b_b_r_p_e X f g h R P c 6) = Phi X f g h R P c.
rewrite <- pack_b_b_b_r_p_e_6_eq2 X f g h R P c.
apply HPhi.
- exact pack_b_b_b_r_p_e_1_eq2 X f g h R P c.
- exact pack_b_b_b_r_p_e_2_eq2 X f g h R P c.
- exact pack_b_b_b_r_p_e_3_eq2 X f g h R P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_p_e X f g h R P c 4) x y.
  rewrite <- pack_b_b_b_r_p_e_4_eq2 X f g h R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_r_p_e X f g h R P c 5) x.
  rewrite <- pack_b_b_b_r_p_e_5_eq2 X f g h R P c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_r_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> set -> set -> set := fun X f g h R c d => (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d).

Theorem pack_b_b_b_r_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> X = S 0.
let S X f g h R c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_r_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, X = pack_b_b_b_r_e_e X f g h R c d 0.
let X f g h R c d. apply pack_b_b_b_r_e_e_0_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_b_r_e_e X f g h R c d 1) x y.
let X f g h R c d. apply pack_b_b_b_r_e_e_1_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_b_r_e_e X f g h R c d 2) x y.
let X f g h R c d. apply pack_b_b_b_r_e_e_2_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, h x y = decode_b (pack_b_b_b_r_e_e X f g h R c d 3) x y.
let X f g h R c d. apply pack_b_b_b_r_e_e_3_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g h R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_b_r_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_b_b_r_e_e X f g h R c d 4) x y.
let X f g h R c d. apply pack_b_b_b_r_e_e_4_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> c = S 5.
let S X f g h R c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_b_r_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, c = pack_b_b_b_r_e_e X f g h R c d 5.
let X f g h R c d. apply pack_b_b_b_r_e_e_5_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_b_r_e_e X f g h R c d -> d = S 6.
let S X f g h R c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_r_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, d = pack_b_b_b_r_e_e X f g h R c d 6.
let X f g h R c d. apply pack_b_b_b_r_e_e_6_eq (pack_b_b_b_r_e_e X f g h R c d) X f g h R c d. reflexivity.
Qed.

Theorem pack_b_b_b_r_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall c c':set, forall d d':set, pack_b_b_b_r_e_e X f g h R c d = pack_b_b_b_r_e_e X' f' g' h' R' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x y :e X, R x y = R' x y) /\ c = c' /\ d = d'.
let X X' f f' g g' h h' R R' c c' d d'. assume H1.
claim L0: X' = pack_b_b_b_r_e_e X f g h R c d 0.
{ exact pack_b_b_b_r_e_e_0_eq (pack_b_b_b_r_e_e X f g h R c d) X' f' g' h' R' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_r_e_e_0_eq2 X f g h R c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_r_e_e_1_eq2 X f g h R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_e_e_1_eq2 X' f' g' h' R' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_r_e_e_2_eq2 X f g h R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_e_e_2_eq2 X' f' g' h' R' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_r_e_e_3_eq2 X f g h R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_e_e_3_eq2 X' f' g' h' R' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_b_r_e_e_4_eq2 X f g h R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_r_e_e_4_eq2 X' f' g' h' R' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_b_r_e_e_5_eq2 X f g h R c d.
  rewrite H1. symmetry.
  exact pack_b_b_b_r_e_e_5_eq2 X' f' g' h' R' c' d'.
- prove d = d'.
  rewrite pack_b_b_b_r_e_e_6_eq2 X f g h R c d.
  rewrite H1. symmetry.
  exact pack_b_b_b_r_e_e_6_eq2 X' f' g' h' R' c' d'.
Qed.

Theorem pack_b_b_b_r_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall R R':set -> set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_b_b_r_e_e X f g h R c d = pack_b_b_b_r_e_e X f' g' h' R' c d.
let X f f' g g' h h' R R' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_r X R,c,d) = (X,encode_b X f',encode_b X g',encode_b X h',encode_r X R',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_b_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_b_r_e_e X f g h R c d)) -> q S.

Theorem pack_struct_b_b_b_r_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let R c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg h Hh R c Hc d Hd.
Qed.

Theorem pack_struct_b_b_b_r_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d) -> forall x y :e X, f x y :e X.
let X f g h R c d. assume H1. apply H1 (fun z => z = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_r_e_e X' f' g' h' R' c' d' = pack_b_b_b_r_e_e X f g h R c d.
  apply pack_b_b_b_r_e_e_inj X' X f' f g' g h' h R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d) -> forall x y :e X, g x y :e X.
let X f g h R c d. assume H1. apply H1 (fun z => z = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_r_e_e X' f' g' h' R' c' d' = pack_b_b_b_r_e_e X f g h R c d.
  apply pack_b_b_b_r_e_e_inj X' X f' f g' g h' h R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_e_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d) -> forall x y :e X, h x y :e X.
let X f g h R c d. assume H1. apply H1 (fun z => z = pack_b_b_b_r_e_e X f g h R c d -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_r_e_e X' f' g' h' R' c' d' = pack_b_b_b_r_e_e X f g h R c d.
  apply pack_b_b_b_r_e_e_inj X' X f' f g' g h' h R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d) -> c :e X.
let X f g h R c d. assume H1. apply H1 (fun z => z = pack_b_b_b_r_e_e X f g h R c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_r_e_e X' f' g' h' R' c' d' = pack_b_b_b_r_e_e X f g h R c d.
  apply pack_b_b_b_r_e_e_inj X' X f' f g' g h' h R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_r_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d) -> d :e X.
let X f g h R c d. assume H1. apply H1 (fun z => z = pack_b_b_b_r_e_e X f g h R c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_r_e_e X' f' g' h' R' c' d' = pack_b_b_b_r_e_e X f g h R c d.
  apply pack_b_b_b_r_e_e_inj X' X f' f g' g h' h R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HR'R Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_b_r_e_e_eta: forall S, struct_b_b_b_r_e_e S -> S = pack_b_b_b_r_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_r_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let R. let c. assume _. let d. assume _.
prove pack_b_b_b_r_e_e X f g h R c d = pack_b_b_b_r_e_e (pack_b_b_b_r_e_e X f g h R c d 0) (decode_b (pack_b_b_b_r_e_e X f g h R c d 1)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 2)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 3)) (decode_r (pack_b_b_b_r_e_e X f g h R c d 4)) (pack_b_b_b_r_e_e X f g h R c d 5) (pack_b_b_b_r_e_e X f g h R c d 6).
rewrite <- pack_b_b_b_r_e_e_0_eq2 X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_5_eq2 X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_6_eq2 X f g h R c d.
apply pack_b_b_b_r_e_e_ext.
- exact pack_b_b_b_r_e_e_1_eq2 X f g h R c d.
- exact pack_b_b_b_r_e_e_2_eq2 X f g h R c d.
- exact pack_b_b_b_r_e_e_3_eq2 X f g h R c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_b_r_e_e_4_eq2 X f g h R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_b_b_r_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' h' R' c d = Phi X f g h R c d)
  ->
  unpack_b_b_b_r_e_e_i (pack_b_b_b_r_e_e X f g h R c d) Phi = Phi X f g h R c d.
let Phi X f g h R c d.
assume HPhi.
prove Phi (pack_b_b_b_r_e_e X f g h R c d 0) (decode_b (pack_b_b_b_r_e_e X f g h R c d 1)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 2)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 3)) (decode_r (pack_b_b_b_r_e_e X f g h R c d 4)) (pack_b_b_b_r_e_e X f g h R c d 5) (pack_b_b_b_r_e_e X f g h R c d 6) = Phi X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_0_eq2 X f g h R c d.
prove Phi X (decode_b (pack_b_b_b_r_e_e X f g h R c d 1)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 2)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 3)) (decode_r (pack_b_b_b_r_e_e X f g h R c d 4)) (pack_b_b_b_r_e_e X f g h R c d 5) (pack_b_b_b_r_e_e X f g h R c d 6) = Phi X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_5_eq2 X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_6_eq2 X f g h R c d.
apply HPhi.
- exact pack_b_b_b_r_e_e_1_eq2 X f g h R c d.
- exact pack_b_b_b_r_e_e_2_eq2 X f g h R c d.
- exact pack_b_b_b_r_e_e_3_eq2 X f g h R c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_e_e X f g h R c d 4) x y.
  rewrite <- pack_b_b_b_r_e_e_4_eq2 X f g h R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_r_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_b_b_r_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall R:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' h' R' c d = Phi X f g h R c d)
  ->
  unpack_b_b_b_r_e_e_o (pack_b_b_b_r_e_e X f g h R c d) Phi = Phi X f g h R c d.
let Phi X f g h R c d.
assume HPhi.
prove Phi (pack_b_b_b_r_e_e X f g h R c d 0) (decode_b (pack_b_b_b_r_e_e X f g h R c d 1)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 2)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 3)) (decode_r (pack_b_b_b_r_e_e X f g h R c d 4)) (pack_b_b_b_r_e_e X f g h R c d 5) (pack_b_b_b_r_e_e X f g h R c d 6) = Phi X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_0_eq2 X f g h R c d.
prove Phi X (decode_b (pack_b_b_b_r_e_e X f g h R c d 1)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 2)) (decode_b (pack_b_b_b_r_e_e X f g h R c d 3)) (decode_r (pack_b_b_b_r_e_e X f g h R c d 4)) (pack_b_b_b_r_e_e X f g h R c d 5) (pack_b_b_b_r_e_e X f g h R c d 6) = Phi X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_5_eq2 X f g h R c d.
rewrite <- pack_b_b_b_r_e_e_6_eq2 X f g h R c d.
apply HPhi.
- exact pack_b_b_b_r_e_e_1_eq2 X f g h R c d.
- exact pack_b_b_b_r_e_e_2_eq2 X f g h R c d.
- exact pack_b_b_b_r_e_e_3_eq2 X f g h R c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_b_r_e_e X f g h R c d 4) x y.
  rewrite <- pack_b_b_b_r_e_e_4_eq2 X f g h R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_b_p_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set := fun X f g h P Q c => (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c).

Theorem pack_b_b_b_p_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> X = S 0.
let S X f g h P Q c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_p_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_b_b_b_p_p_e X f g h P Q c 0.
let X f g h P Q c. apply pack_b_b_b_p_p_e_0_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_p_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_b_p_p_e X f g h P Q c 1) x y.
let X f g h P Q c. apply pack_b_b_b_p_p_e_1_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_p_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_b_p_p_e X f g h P Q c 2) x y.
let X f g h P Q c. apply pack_b_b_b_p_p_e_2_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_p_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, h x y = decode_b (pack_b_b_b_p_p_e X f g h P Q c 3) x y.
let X f g h P Q c. apply pack_b_b_b_p_p_e_3_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X f g h P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_p_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_b_p_p_e X f g h P Q c 4) x.
let X f g h P Q c. apply pack_b_b_b_p_p_e_4_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X f g h P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_b_p_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_b_b_b_p_p_e X f g h P Q c 5) x.
let X f g h P Q c. apply pack_b_b_b_p_p_e_5_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_b_p_p_e X f g h P Q c -> c = S 6.
let S X f g h P Q c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_p_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_b_b_b_p_p_e X f g h P Q c 6.
let X f g h P Q c. apply pack_b_b_b_p_p_e_6_eq (pack_b_b_b_p_p_e X f g h P Q c) X f g h P Q c. reflexivity.
Qed.

Theorem pack_b_b_b_p_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_b_b_b_p_p_e X f g h P Q c = pack_b_b_b_p_p_e X' f' g' h' P' Q' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' f f' g g' h h' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_b_b_b_p_p_e X f g h P Q c 0.
{ exact pack_b_b_b_p_p_e_0_eq (pack_b_b_b_p_p_e X f g h P Q c) X' f' g' h' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_p_p_e_0_eq2 X f g h P Q c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_p_p_e_1_eq2 X f g h P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_p_e_1_eq2 X' f' g' h' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_p_p_e_2_eq2 X f g h P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_p_e_2_eq2 X' f' g' h' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_p_p_e_3_eq2 X f g h P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_p_e_3_eq2 X' f' g' h' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_p_p_e_4_eq2 X f g h P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_p_e_4_eq2 X' f' g' h' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_b_p_p_e_5_eq2 X f g h P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_p_e_5_eq2 X' f' g' h' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_b_p_p_e_6_eq2 X f g h P Q c.
  rewrite H1. symmetry.
  exact pack_b_b_b_p_p_e_6_eq2 X' f' g' h' P' Q' c'.
Qed.

Theorem pack_b_b_b_p_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_b_p_p_e X f g h P Q c = pack_b_b_b_p_p_e X f' g' h' P' Q' c.
let X f f' g g' h h' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,encode_p X Q,c) = (X,encode_b X f',encode_b X g',encode_b X h',encode_p X P',encode_p X Q',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_b_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_b_b_b_p_p_e X f g h P Q c)) -> q S.

Theorem pack_struct_b_b_b_p_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_b_b_b_p_p_e (pack_b_b_b_p_p_e X f g h P Q c).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let P Q c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg h Hh P Q c Hc.
Qed.

Theorem pack_struct_b_b_b_p_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_b_p_p_e (pack_b_b_b_p_p_e X f g h P Q c) -> forall x y :e X, f x y :e X.
let X f g h P Q c. assume H1. apply H1 (fun z => z = pack_b_b_b_p_p_e X f g h P Q c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_p_p_e X' f' g' h' P' Q' c' = pack_b_b_b_p_p_e X f g h P Q c.
  apply pack_b_b_b_p_p_e_inj X' X f' f g' g h' h P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_b_p_p_e (pack_b_b_b_p_p_e X f g h P Q c) -> forall x y :e X, g x y :e X.
let X f g h P Q c. assume H1. apply H1 (fun z => z = pack_b_b_b_p_p_e X f g h P Q c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_p_p_e X' f' g' h' P' Q' c' = pack_b_b_b_p_p_e X f g h P Q c.
  apply pack_b_b_b_p_p_e_inj X' X f' f g' g h' h P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_p_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_b_p_p_e (pack_b_b_b_p_p_e X f g h P Q c) -> forall x y :e X, h x y :e X.
let X f g h P Q c. assume H1. apply H1 (fun z => z = pack_b_b_b_p_p_e X f g h P Q c -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_p_p_e X' f' g' h' P' Q' c' = pack_b_b_b_p_p_e X f g h P Q c.
  apply pack_b_b_b_p_p_e_inj X' X f' f g' g h' h P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_b_p_p_e (pack_b_b_b_p_p_e X f g h P Q c) -> c :e X.
let X f g h P Q c. assume H1. apply H1 (fun z => z = pack_b_b_b_p_p_e X f g h P Q c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_b_p_p_e X' f' g' h' P' Q' c' = pack_b_b_b_p_p_e X f g h P Q c.
  apply pack_b_b_b_p_p_e_inj X' X f' f g' g h' h P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_b_p_p_e_eta: forall S, struct_b_b_b_p_p_e S -> S = pack_b_b_b_p_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_p_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let P. let Q. let c. assume _.
prove pack_b_b_b_p_p_e X f g h P Q c = pack_b_b_b_p_p_e (pack_b_b_b_p_p_e X f g h P Q c 0) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 1)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 2)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 3)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 4)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 5)) (pack_b_b_b_p_p_e X f g h P Q c 6).
rewrite <- pack_b_b_b_p_p_e_0_eq2 X f g h P Q c.
rewrite <- pack_b_b_b_p_p_e_6_eq2 X f g h P Q c.
apply pack_b_b_b_p_p_e_ext.
- exact pack_b_b_b_p_p_e_1_eq2 X f g h P Q c.
- exact pack_b_b_b_p_p_e_2_eq2 X f g h P Q c.
- exact pack_b_b_b_p_p_e_3_eq2 X f g h P Q c.
- let x. assume Hx.
  rewrite <- pack_b_b_b_p_p_e_4_eq2 X f g h P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_b_p_p_e_5_eq2 X f g h P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_p_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_b_p_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' h' P' Q' c = Phi X f g h P Q c)
  ->
  unpack_b_b_b_p_p_e_i (pack_b_b_b_p_p_e X f g h P Q c) Phi = Phi X f g h P Q c.
let Phi X f g h P Q c.
assume HPhi.
prove Phi (pack_b_b_b_p_p_e X f g h P Q c 0) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 1)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 2)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 3)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 4)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 5)) (pack_b_b_b_p_p_e X f g h P Q c 6) = Phi X f g h P Q c.
rewrite <- pack_b_b_b_p_p_e_0_eq2 X f g h P Q c.
prove Phi X (decode_b (pack_b_b_b_p_p_e X f g h P Q c 1)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 2)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 3)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 4)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 5)) (pack_b_b_b_p_p_e X f g h P Q c 6) = Phi X f g h P Q c.
rewrite <- pack_b_b_b_p_p_e_6_eq2 X f g h P Q c.
apply HPhi.
- exact pack_b_b_b_p_p_e_1_eq2 X f g h P Q c.
- exact pack_b_b_b_p_p_e_2_eq2 X f g h P Q c.
- exact pack_b_b_b_p_p_e_3_eq2 X f g h P Q c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_p_p_e X f g h P Q c 4) x.
  rewrite <- pack_b_b_b_p_p_e_4_eq2 X f g h P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_b_p_p_e X f g h P Q c 5) x.
  rewrite <- pack_b_b_b_p_p_e_5_eq2 X f g h P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_p_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_b_p_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' h' P' Q' c = Phi X f g h P Q c)
  ->
  unpack_b_b_b_p_p_e_o (pack_b_b_b_p_p_e X f g h P Q c) Phi = Phi X f g h P Q c.
let Phi X f g h P Q c.
assume HPhi.
prove Phi (pack_b_b_b_p_p_e X f g h P Q c 0) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 1)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 2)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 3)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 4)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 5)) (pack_b_b_b_p_p_e X f g h P Q c 6) = Phi X f g h P Q c.
rewrite <- pack_b_b_b_p_p_e_0_eq2 X f g h P Q c.
prove Phi X (decode_b (pack_b_b_b_p_p_e X f g h P Q c 1)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 2)) (decode_b (pack_b_b_b_p_p_e X f g h P Q c 3)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 4)) (decode_p (pack_b_b_b_p_p_e X f g h P Q c 5)) (pack_b_b_b_p_p_e X f g h P Q c 6) = Phi X f g h P Q c.
rewrite <- pack_b_b_b_p_p_e_6_eq2 X f g h P Q c.
apply HPhi.
- exact pack_b_b_b_p_p_e_1_eq2 X f g h P Q c.
- exact pack_b_b_b_p_p_e_2_eq2 X f g h P Q c.
- exact pack_b_b_b_p_p_e_3_eq2 X f g h P Q c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_p_p_e X f g h P Q c 4) x.
  rewrite <- pack_b_b_b_p_p_e_4_eq2 X f g h P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_b_p_p_e X f g h P Q c 5) x.
  rewrite <- pack_b_b_b_p_p_e_5_eq2 X f g h P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_b_p_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> set -> set -> set := fun X f g h P c d => (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d).

Theorem pack_b_b_b_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> X = S 0.
let S X f g h P c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_b_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, X = pack_b_b_b_p_e_e X f g h P c d 0.
let X f g h P c d. apply pack_b_b_b_p_e_e_0_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_b_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_b_p_e_e X f g h P c d 1) x y.
let X f g h P c d. apply pack_b_b_b_p_e_e_1_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_b_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_b_p_e_e X f g h P c d 2) x y.
let X f g h P c d. apply pack_b_b_b_p_e_e_2_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_b_b_b_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, h x y = decode_b (pack_b_b_b_p_e_e X f g h P c d 3) x y.
let X f g h P c d. apply pack_b_b_b_p_e_e_3_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X f g h P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_b_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_b_b_p_e_e X f g h P c d 4) x.
let X f g h P c d. apply pack_b_b_b_p_e_e_4_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> c = S 5.
let S X f g h P c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_b_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, c = pack_b_b_b_p_e_e X f g h P c d 5.
let X f g h P c d. apply pack_b_b_b_p_e_e_5_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_b_p_e_e X f g h P c d -> d = S 6.
let S X f g h P c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_b_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, d = pack_b_b_b_p_e_e X f g h P c d 6.
let X f g h P c d. apply pack_b_b_b_p_e_e_6_eq (pack_b_b_b_p_e_e X f g h P c d) X f g h P c d. reflexivity.
Qed.

Theorem pack_b_b_b_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall P P':set -> prop, forall c c':set, forall d d':set, pack_b_b_b_p_e_e X f g h P c d = pack_b_b_b_p_e_e X' f' g' h' P' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, h x y = h' x y) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' f f' g g' h h' P P' c c' d d'. assume H1.
claim L0: X' = pack_b_b_b_p_e_e X f g h P c d 0.
{ exact pack_b_b_b_p_e_e_0_eq (pack_b_b_b_p_e_e X f g h P c d) X' f' g' h' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_b_p_e_e_0_eq2 X f g h P c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_b_p_e_e_1_eq2 X f g h P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_e_e_1_eq2 X' f' g' h' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_b_p_e_e_2_eq2 X f g h P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_e_e_2_eq2 X' f' g' h' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove h x y = h' x y.
  rewrite pack_b_b_b_p_e_e_3_eq2 X f g h P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_e_e_3_eq2 X' f' g' h' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_b_p_e_e_4_eq2 X f g h P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_b_p_e_e_4_eq2 X' f' g' h' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_b_b_p_e_e_5_eq2 X f g h P c d.
  rewrite H1. symmetry.
  exact pack_b_b_b_p_e_e_5_eq2 X' f' g' h' P' c' d'.
- prove d = d'.
  rewrite pack_b_b_b_p_e_e_6_eq2 X f g h P c d.
  rewrite H1. symmetry.
  exact pack_b_b_b_p_e_e_6_eq2 X' f' g' h' P' c' d'.
Qed.

Theorem pack_b_b_b_p_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set, forall P P':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_b_p_e_e X f g h P c d = pack_b_b_b_p_e_e X f' g' h' P' c d.
let X f f' g g' h h' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_b X h,encode_p X P,c,d) = (X,encode_b X f',encode_b X g',encode_b X h',encode_p X P',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_b_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_b_p_e_e X f g h P c d)) -> q S.

Theorem pack_struct_b_b_b_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall h:set -> set -> set, (forall x y :e X, h x y :e X) -> forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d).
let X f. assume Hf. let g. assume Hg. let h. assume Hh. let P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg h Hh P c Hc d Hd.
Qed.

Theorem pack_struct_b_b_b_p_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d) -> forall x y :e X, f x y :e X.
let X f g h P c d. assume H1. apply H1 (fun z => z = pack_b_b_b_p_e_e X f g h P c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_p_e_e X' f' g' h' P' c' d' = pack_b_b_b_p_e_e X f g h P c d.
  apply pack_b_b_b_p_e_e_inj X' X f' f g' g h' h P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d) -> forall x y :e X, g x y :e X.
let X f g h P c d. assume H1. apply H1 (fun z => z = pack_b_b_b_p_e_e X f g h P c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_p_e_e X' f' g' h' P' c' d' = pack_b_b_b_p_e_e X f g h P c d.
  apply pack_b_b_b_p_e_e_inj X' X f' f g' g h' h P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_e_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d) -> forall x y :e X, h x y :e X.
let X f g h P c d. assume H1. apply H1 (fun z => z = pack_b_b_b_p_e_e X f g h P c d -> forall x y :e X, h x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_p_e_e X' f' g' h' P' c' d' = pack_b_b_b_p_e_e X f g h P c d.
  apply pack_b_b_b_p_e_e_inj X' X f' f g' g h' h P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hh'h x Hx y Hy.  exact Hh' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d) -> c :e X.
let X f g h P c d. assume H1. apply H1 (fun z => z = pack_b_b_b_p_e_e X f g h P c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_p_e_e X' f' g' h' P' c' d' = pack_b_b_b_p_e_e X f g h P c d.
  apply pack_b_b_b_p_e_e_inj X' X f' f g' g h' h P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_b_p_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d) -> d :e X.
let X f g h P c d. assume H1. apply H1 (fun z => z = pack_b_b_b_p_e_e X f g h P c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let h'. assume Hh'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_b_p_e_e X' f' g' h' P' c' d' = pack_b_b_b_p_e_e X f g h P c d.
  apply pack_b_b_b_p_e_e_inj X' X f' f g' g h' h P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hh'h HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_b_p_e_e_eta: forall S, struct_b_b_b_p_e_e S -> S = pack_b_b_b_p_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_b_p_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_b (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let h. assume _. let P. let c. assume _. let d. assume _.
prove pack_b_b_b_p_e_e X f g h P c d = pack_b_b_b_p_e_e (pack_b_b_b_p_e_e X f g h P c d 0) (decode_b (pack_b_b_b_p_e_e X f g h P c d 1)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 2)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 3)) (decode_p (pack_b_b_b_p_e_e X f g h P c d 4)) (pack_b_b_b_p_e_e X f g h P c d 5) (pack_b_b_b_p_e_e X f g h P c d 6).
rewrite <- pack_b_b_b_p_e_e_0_eq2 X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_5_eq2 X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_6_eq2 X f g h P c d.
apply pack_b_b_b_p_e_e_ext.
- exact pack_b_b_b_p_e_e_1_eq2 X f g h P c d.
- exact pack_b_b_b_p_e_e_2_eq2 X f g h P c d.
- exact pack_b_b_b_p_e_e_3_eq2 X f g h P c d.
- let x. assume Hx.
  rewrite <- pack_b_b_b_p_e_e_4_eq2 X f g h P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_b_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' P' c d = Phi X f g h P c d)
  ->
  unpack_b_b_b_p_e_e_i (pack_b_b_b_p_e_e X f g h P c d) Phi = Phi X f g h P c d.
let Phi X f g h P c d.
assume HPhi.
prove Phi (pack_b_b_b_p_e_e X f g h P c d 0) (decode_b (pack_b_b_b_p_e_e X f g h P c d 1)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 2)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 3)) (decode_p (pack_b_b_b_p_e_e X f g h P c d 4)) (pack_b_b_b_p_e_e X f g h P c d 5) (pack_b_b_b_p_e_e X f g h P c d 6) = Phi X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_0_eq2 X f g h P c d.
prove Phi X (decode_b (pack_b_b_b_p_e_e X f g h P c d 1)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 2)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 3)) (decode_p (pack_b_b_b_p_e_e X f g h P c d 4)) (pack_b_b_b_p_e_e X f g h P c d 5) (pack_b_b_b_p_e_e X f g h P c d 6) = Phi X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_5_eq2 X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_6_eq2 X f g h P c d.
apply HPhi.
- exact pack_b_b_b_p_e_e_1_eq2 X f g h P c d.
- exact pack_b_b_b_p_e_e_2_eq2 X f g h P c d.
- exact pack_b_b_b_p_e_e_3_eq2 X f g h P c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_p_e_e X f g h P c d 4) x.
  rewrite <- pack_b_b_b_p_e_e_4_eq2 X f g h P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_b_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_b_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h':set -> set -> set, (forall x y :e X, h x y = h' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' h' P' c d = Phi X f g h P c d)
  ->
  unpack_b_b_b_p_e_e_o (pack_b_b_b_p_e_e X f g h P c d) Phi = Phi X f g h P c d.
let Phi X f g h P c d.
assume HPhi.
prove Phi (pack_b_b_b_p_e_e X f g h P c d 0) (decode_b (pack_b_b_b_p_e_e X f g h P c d 1)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 2)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 3)) (decode_p (pack_b_b_b_p_e_e X f g h P c d 4)) (pack_b_b_b_p_e_e X f g h P c d 5) (pack_b_b_b_p_e_e X f g h P c d 6) = Phi X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_0_eq2 X f g h P c d.
prove Phi X (decode_b (pack_b_b_b_p_e_e X f g h P c d 1)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 2)) (decode_b (pack_b_b_b_p_e_e X f g h P c d 3)) (decode_p (pack_b_b_b_p_e_e X f g h P c d 4)) (pack_b_b_b_p_e_e X f g h P c d 5) (pack_b_b_b_p_e_e X f g h P c d 6) = Phi X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_5_eq2 X f g h P c d.
rewrite <- pack_b_b_b_p_e_e_6_eq2 X f g h P c d.
apply HPhi.
- exact pack_b_b_b_p_e_e_1_eq2 X f g h P c d.
- exact pack_b_b_b_p_e_e_2_eq2 X f g h P c d.
- exact pack_b_b_b_p_e_e_3_eq2 X f g h P c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_b_p_e_e X f g h P c d 4) x.
  rewrite <- pack_b_b_b_p_e_e_4_eq2 X f g h P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_u_r_r : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set := fun X f g i j R T => (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T).

Theorem pack_b_b_u_u_r_r_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> X = S 0.
let S X f g i j R T. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_u_r_r_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, X = pack_b_b_u_u_r_r X f g i j R T 0.
let X f g i j R T. apply pack_b_b_u_u_r_r_0_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_r_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_u_u_r_r X f g i j R T 1) x y.
let X f g i j R T. apply pack_b_b_u_u_r_r_1_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_r_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_u_u_r_r X f g i j R T 2) x y.
let X f g i j R T. apply pack_b_b_u_u_r_r_2_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i j R T. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_u_r_r_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x :e X, i x = decode_u (pack_b_b_u_u_r_r X f g i j R T 3) x.
let X f g i j R T. apply pack_b_b_u_u_r_r_3_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> forall x :e X, j x = decode_u (S 4) x.
let S X f g i j R T. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_u_u_r_r_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x :e X, j x = decode_u (pack_b_b_u_u_r_r X f g i j R T 4) x.
let X f g i j R T. apply pack_b_b_u_u_r_r_4_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X f g i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_r_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_u_u_r_r X f g i j R T 5) x y.
let X f g i j R T. apply pack_b_b_u_u_r_r_5_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_b_b_u_u_r_r X f g i j R T -> forall x y :e X, T x y = decode_r (S 6) x y.
let S X f g i j R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) 6) x y.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_r_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall x y :e X, T x y = decode_r (pack_b_b_u_u_r_r X f g i j R T 6) x y.
let X f g i j R T. apply pack_b_b_u_u_r_r_6_eq (pack_b_b_u_u_r_r X f g i j R T) X f g i j R T. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_r_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, pack_b_b_u_u_r_r X f g i j R T = pack_b_b_u_u_r_r X' f' g' i' j' R' T' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y).
let X X' f f' g g' i i' j j' R R' T T'. assume H1.
claim L0: X' = pack_b_b_u_u_r_r X f g i j R T 0.
{ exact pack_b_b_u_u_r_r_0_eq (pack_b_b_u_u_r_r X f g i j R T) X' f' g' i' j' R' T' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_u_r_r_0_eq2 X f g i j R T. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_u_r_r_1_eq2 X f g i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_r_1_eq2 X' f' g' i' j' R' T' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_u_r_r_2_eq2 X f g i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_r_2_eq2 X' f' g' i' j' R' T' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_u_r_r_3_eq2 X f g i j R T x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_r_3_eq2 X' f' g' i' j' R' T' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_u_u_r_r_4_eq2 X f g i j R T x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_r_4_eq2 X' f' g' i' j' R' T' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_u_r_r_5_eq2 X f g i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_r_5_eq2 X' f' g' i' j' R' T' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_u_u_r_r_6_eq2 X f g i j R T x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_r_6_eq2 X' f' g' i' j' R' T' x Lx y Ly.
Qed.

Theorem pack_b_b_u_u_r_r_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_b_b_u_u_r_r X f g i j R T = pack_b_b_u_u_r_r X f' g' i' j' R' T'.
let X f f' g g' i i' j j' R R' T T'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_r X T) = (X,encode_b X f',encode_b X g',encode_u X i',encode_u X j',encode_r X R',encode_r X T').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_u_u_r_r : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, q (pack_b_b_u_u_r_r X f g i j R T)) -> q S.

Theorem pack_struct_b_b_u_u_r_r_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_u_u_r_r (pack_b_b_u_u_r_r X f g i j R T).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let j. assume Hj. let R T q. assume Hq.
exact Hq X f Hf g Hg i Hi j Hj R T.
Qed.

Theorem pack_struct_b_b_u_u_r_r_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_u_u_r_r (pack_b_b_u_u_r_r X f g i j R T) -> forall x y :e X, f x y :e X.
let X f g i j R T. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_r X f g i j R T -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_b_b_u_u_r_r X' f' g' i' j' R' T' = pack_b_b_u_u_r_r X f g i j R T.
  apply pack_b_b_u_u_r_r_inj X' X f' f g' g i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_r_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_u_u_r_r (pack_b_b_u_u_r_r X f g i j R T) -> forall x y :e X, g x y :e X.
let X f g i j R T. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_r X f g i j R T -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_b_b_u_u_r_r X' f' g' i' j' R' T' = pack_b_b_u_u_r_r X f g i j R T.
  apply pack_b_b_u_u_r_r_inj X' X f' f g' g i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_r_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_u_u_r_r (pack_b_b_u_u_r_r X f g i j R T) -> forall x :e X, i x :e X.
let X f g i j R T. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_r X f g i j R T -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_b_b_u_u_r_r X' f' g' i' j' R' T' = pack_b_b_u_u_r_r X f g i j R T.
  apply pack_b_b_u_u_r_r_inj X' X f' f g' g i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_r_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_b_b_u_u_r_r (pack_b_b_u_u_r_r X f g i j R T) -> forall x :e X, j x :e X.
let X f g i j R T. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_r X f g i j R T -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'.
  assume Heq: pack_b_b_u_u_r_r X' f' g' i' j' R' T' = pack_b_b_u_u_r_r X f g i j R T.
  apply pack_b_b_u_u_r_r_inj X' X f' f g' g i' i j' j R' R T' T Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HT'T.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_u_u_r_r_eta: forall S, struct_b_b_u_u_r_r S -> S = pack_b_b_u_u_r_r (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_r (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_r (z 5)) (decode_r (z 6))).
let X. let f. assume _. let g. assume _. let i. assume _. let j. assume _. let R. let T.
prove pack_b_b_u_u_r_r X f g i j R T = pack_b_b_u_u_r_r (pack_b_b_u_u_r_r X f g i j R T 0) (decode_b (pack_b_b_u_u_r_r X f g i j R T 1)) (decode_b (pack_b_b_u_u_r_r X f g i j R T 2)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 3)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 4)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 5)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 6)).
rewrite <- pack_b_b_u_u_r_r_0_eq2 X f g i j R T.
apply pack_b_b_u_u_r_r_ext.
- exact pack_b_b_u_u_r_r_1_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_2_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_3_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_4_eq2 X f g i j R T.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_u_r_r_5_eq2 X f g i j R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_u_r_r_6_eq2 X f g i j R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_r_r_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).

Theorem unpack_b_b_u_u_r_r_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' i' j' R' T' = Phi X f g i j R T)
  ->
  unpack_b_b_u_u_r_r_i (pack_b_b_u_u_r_r X f g i j R T) Phi = Phi X f g i j R T.
let Phi X f g i j R T.
assume HPhi.
prove Phi (pack_b_b_u_u_r_r X f g i j R T 0) (decode_b (pack_b_b_u_u_r_r X f g i j R T 1)) (decode_b (pack_b_b_u_u_r_r X f g i j R T 2)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 3)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 4)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 5)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 6)) = Phi X f g i j R T.
rewrite <- pack_b_b_u_u_r_r_0_eq2 X f g i j R T.
prove Phi X (decode_b (pack_b_b_u_u_r_r X f g i j R T 1)) (decode_b (pack_b_b_u_u_r_r X f g i j R T 2)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 3)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 4)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 5)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 6)) = Phi X f g i j R T.
apply HPhi.
- exact pack_b_b_u_u_r_r_1_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_2_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_3_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_4_eq2 X f g i j R T.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_u_r_r X f g i j R T 5) x y.
  rewrite <- pack_b_b_u_u_r_r_5_eq2 X f g i j R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_u_u_r_r X f g i j R T 6) x y.
  rewrite <- pack_b_b_u_u_r_r_6_eq2 X f g i j R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_r_r_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_r (S 6)).

Theorem unpack_b_b_u_u_r_r_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' i' j' R' T' = Phi X f g i j R T)
  ->
  unpack_b_b_u_u_r_r_o (pack_b_b_u_u_r_r X f g i j R T) Phi = Phi X f g i j R T.
let Phi X f g i j R T.
assume HPhi.
prove Phi (pack_b_b_u_u_r_r X f g i j R T 0) (decode_b (pack_b_b_u_u_r_r X f g i j R T 1)) (decode_b (pack_b_b_u_u_r_r X f g i j R T 2)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 3)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 4)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 5)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 6)) = Phi X f g i j R T.
rewrite <- pack_b_b_u_u_r_r_0_eq2 X f g i j R T.
prove Phi X (decode_b (pack_b_b_u_u_r_r X f g i j R T 1)) (decode_b (pack_b_b_u_u_r_r X f g i j R T 2)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 3)) (decode_u (pack_b_b_u_u_r_r X f g i j R T 4)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 5)) (decode_r (pack_b_b_u_u_r_r X f g i j R T 6)) = Phi X f g i j R T.
apply HPhi.
- exact pack_b_b_u_u_r_r_1_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_2_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_3_eq2 X f g i j R T.
- exact pack_b_b_u_u_r_r_4_eq2 X f g i j R T.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_u_r_r X f g i j R T 5) x y.
  rewrite <- pack_b_b_u_u_r_r_5_eq2 X f g i j R T x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_u_u_r_r X f g i j R T 6) x y.
  rewrite <- pack_b_b_u_u_r_r_6_eq2 X f g i j R T x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_u_u_r_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set := fun X f g i j R P => (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P).

Theorem pack_b_b_u_u_r_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> X = S 0.
let S X f g i j R P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_u_r_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, X = pack_b_b_u_u_r_p X f g i j R P 0.
let X f g i j R P. apply pack_b_b_u_u_r_p_0_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i j R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_u_u_r_p X f g i j R P 1) x y.
let X f g i j R P. apply pack_b_b_u_u_r_p_1_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i j R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_u_u_r_p X f g i j R P 2) x y.
let X f g i j R P. apply pack_b_b_u_u_r_p_2_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i j R P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_u_r_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, i x = decode_u (pack_b_b_u_u_r_p X f g i j R P 3) x.
let X f g i j R P. apply pack_b_b_u_u_r_p_3_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> forall x :e X, j x = decode_u (S 4) x.
let S X f g i j R P. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_u_u_r_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, j x = decode_u (pack_b_b_u_u_r_p X f g i j R P 4) x.
let X f g i j R P. apply pack_b_b_u_u_r_p_4_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X f g i j R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_u_u_r_p X f g i j R P 5) x y.
let X f g i j R P. apply pack_b_b_u_u_r_p_5_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_u_r_p X f g i j R P -> forall x :e X, P x = decode_p (S 6) x.
let S X f g i j R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_u_r_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall x :e X, P x = decode_p (pack_b_b_u_u_r_p X f g i j R P 6) x.
let X f g i j R P. apply pack_b_b_u_u_r_p_6_eq (pack_b_b_u_u_r_p X f g i j R P) X f g i j R P. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, pack_b_b_u_u_r_p X f g i j R P = pack_b_b_u_u_r_p X' f' g' i' j' R' P' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x).
let X X' f f' g g' i i' j j' R R' P P'. assume H1.
claim L0: X' = pack_b_b_u_u_r_p X f g i j R P 0.
{ exact pack_b_b_u_u_r_p_0_eq (pack_b_b_u_u_r_p X f g i j R P) X' f' g' i' j' R' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_u_r_p_0_eq2 X f g i j R P. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_u_r_p_1_eq2 X f g i j R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_p_1_eq2 X' f' g' i' j' R' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_u_r_p_2_eq2 X f g i j R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_p_2_eq2 X' f' g' i' j' R' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_u_r_p_3_eq2 X f g i j R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_p_3_eq2 X' f' g' i' j' R' P' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_u_u_r_p_4_eq2 X f g i j R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_p_4_eq2 X' f' g' i' j' R' P' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_u_r_p_5_eq2 X f g i j R P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_p_5_eq2 X' f' g' i' j' R' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_u_r_p_6_eq2 X f g i j R P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_p_6_eq2 X' f' g' i' j' R' P' x Lx.
Qed.

Theorem pack_b_b_u_u_r_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_u_u_r_p X f g i j R P = pack_b_b_u_u_r_p X f' g' i' j' R' P'.
let X f f' g g' i i' j j' R R' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,encode_p X P) = (X,encode_b X f',encode_b X g',encode_u X i',encode_u X j',encode_r X R',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_u_u_r_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, q (pack_b_b_u_u_r_p X f g i j R P)) -> q S.

Theorem pack_struct_b_b_u_u_r_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_u_u_r_p (pack_b_b_u_u_r_p X f g i j R P).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let j. assume Hj. let R P q. assume Hq.
exact Hq X f Hf g Hg i Hi j Hj R P.
Qed.

Theorem pack_struct_b_b_u_u_r_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_u_u_r_p (pack_b_b_u_u_r_p X f g i j R P) -> forall x y :e X, f x y :e X.
let X f g i j R P. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_p X f g i j R P -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_b_b_u_u_r_p X' f' g' i' j' R' P' = pack_b_b_u_u_r_p X f g i j R P.
  apply pack_b_b_u_u_r_p_inj X' X f' f g' g i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_u_u_r_p (pack_b_b_u_u_r_p X f g i j R P) -> forall x y :e X, g x y :e X.
let X f g i j R P. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_p X f g i j R P -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_b_b_u_u_r_p X' f' g' i' j' R' P' = pack_b_b_u_u_r_p X f g i j R P.
  apply pack_b_b_u_u_r_p_inj X' X f' f g' g i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_u_u_r_p (pack_b_b_u_u_r_p X f g i j R P) -> forall x :e X, i x :e X.
let X f g i j R P. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_p X f g i j R P -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_b_b_u_u_r_p X' f' g' i' j' R' P' = pack_b_b_u_u_r_p X f g i j R P.
  apply pack_b_b_u_u_r_p_inj X' X f' f g' g i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_p_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, struct_b_b_u_u_r_p (pack_b_b_u_u_r_p X f g i j R P) -> forall x :e X, j x :e X.
let X f g i j R P. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_p X f g i j R P -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'.
  assume Heq: pack_b_b_u_u_r_p X' f' g' i' j' R' P' = pack_b_b_u_u_r_p X f g i j R P.
  apply pack_b_b_u_u_r_p_inj X' X f' f g' g i' i j' j R' R P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_u_u_r_p_eta: forall S, struct_b_b_u_u_r_p S -> S = pack_b_b_u_u_r_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_r (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let i. assume _. let j. assume _. let R. let P.
prove pack_b_b_u_u_r_p X f g i j R P = pack_b_b_u_u_r_p (pack_b_b_u_u_r_p X f g i j R P 0) (decode_b (pack_b_b_u_u_r_p X f g i j R P 1)) (decode_b (pack_b_b_u_u_r_p X f g i j R P 2)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 3)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 4)) (decode_r (pack_b_b_u_u_r_p X f g i j R P 5)) (decode_p (pack_b_b_u_u_r_p X f g i j R P 6)).
rewrite <- pack_b_b_u_u_r_p_0_eq2 X f g i j R P.
apply pack_b_b_u_u_r_p_ext.
- exact pack_b_b_u_u_r_p_1_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_2_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_3_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_4_eq2 X f g i j R P.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_u_r_p_5_eq2 X f g i j R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_u_r_p_6_eq2 X f g i j R P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_r_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_u_r_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' j' R' P' = Phi X f g i j R P)
  ->
  unpack_b_b_u_u_r_p_i (pack_b_b_u_u_r_p X f g i j R P) Phi = Phi X f g i j R P.
let Phi X f g i j R P.
assume HPhi.
prove Phi (pack_b_b_u_u_r_p X f g i j R P 0) (decode_b (pack_b_b_u_u_r_p X f g i j R P 1)) (decode_b (pack_b_b_u_u_r_p X f g i j R P 2)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 3)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 4)) (decode_r (pack_b_b_u_u_r_p X f g i j R P 5)) (decode_p (pack_b_b_u_u_r_p X f g i j R P 6)) = Phi X f g i j R P.
rewrite <- pack_b_b_u_u_r_p_0_eq2 X f g i j R P.
prove Phi X (decode_b (pack_b_b_u_u_r_p X f g i j R P 1)) (decode_b (pack_b_b_u_u_r_p X f g i j R P 2)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 3)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 4)) (decode_r (pack_b_b_u_u_r_p X f g i j R P 5)) (decode_p (pack_b_b_u_u_r_p X f g i j R P 6)) = Phi X f g i j R P.
apply HPhi.
- exact pack_b_b_u_u_r_p_1_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_2_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_3_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_4_eq2 X f g i j R P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_u_r_p X f g i j R P 5) x y.
  rewrite <- pack_b_b_u_u_r_p_5_eq2 X f g i j R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_u_r_p X f g i j R P 6) x.
  rewrite <- pack_b_b_u_u_r_p_6_eq2 X f g i j R P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_r_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_u_r_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' j' R' P' = Phi X f g i j R P)
  ->
  unpack_b_b_u_u_r_p_o (pack_b_b_u_u_r_p X f g i j R P) Phi = Phi X f g i j R P.
let Phi X f g i j R P.
assume HPhi.
prove Phi (pack_b_b_u_u_r_p X f g i j R P 0) (decode_b (pack_b_b_u_u_r_p X f g i j R P 1)) (decode_b (pack_b_b_u_u_r_p X f g i j R P 2)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 3)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 4)) (decode_r (pack_b_b_u_u_r_p X f g i j R P 5)) (decode_p (pack_b_b_u_u_r_p X f g i j R P 6)) = Phi X f g i j R P.
rewrite <- pack_b_b_u_u_r_p_0_eq2 X f g i j R P.
prove Phi X (decode_b (pack_b_b_u_u_r_p X f g i j R P 1)) (decode_b (pack_b_b_u_u_r_p X f g i j R P 2)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 3)) (decode_u (pack_b_b_u_u_r_p X f g i j R P 4)) (decode_r (pack_b_b_u_u_r_p X f g i j R P 5)) (decode_p (pack_b_b_u_u_r_p X f g i j R P 6)) = Phi X f g i j R P.
apply HPhi.
- exact pack_b_b_u_u_r_p_1_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_2_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_3_eq2 X f g i j R P.
- exact pack_b_b_u_u_r_p_4_eq2 X f g i j R P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_u_r_p X f g i j R P 5) x y.
  rewrite <- pack_b_b_u_u_r_p_5_eq2 X f g i j R P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_u_r_p X f g i j R P 6) x.
  rewrite <- pack_b_b_u_u_r_p_6_eq2 X f g i j R P x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_u_r_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set := fun X f g i j R c => (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c).

Theorem pack_b_b_u_u_r_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> X = S 0.
let S X f g i j R c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_u_r_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, X = pack_b_b_u_u_r_e X f g i j R c 0.
let X f g i j R c. apply pack_b_b_u_u_r_e_0_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i j R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_u_u_r_e X f g i j R c 1) x y.
let X f g i j R c. apply pack_b_b_u_u_r_e_1_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i j R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_u_u_r_e X f g i j R c 2) x y.
let X f g i j R c. apply pack_b_b_u_u_r_e_2_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i j R c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_u_r_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_u_u_r_e X f g i j R c 3) x.
let X f g i j R c. apply pack_b_b_u_u_r_e_3_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> forall x :e X, j x = decode_u (S 4) x.
let S X f g i j R c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_u_u_r_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x :e X, j x = decode_u (pack_b_b_u_u_r_e X f g i j R c 4) x.
let X f g i j R c. apply pack_b_b_u_u_r_e_4_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> forall x y :e X, R x y = decode_r (S 5) x y.
let S X f g i j R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_r_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_u_u_r_e X f g i j R c 5) x y.
let X f g i j R c. apply pack_b_b_u_u_r_e_5_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_b_u_u_r_e X f g i j R c -> c = S 6.
let S X f g i j R c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_u_r_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, c = pack_b_b_u_u_r_e X f g i j R c 6.
let X f g i j R c. apply pack_b_b_u_u_r_e_6_eq (pack_b_b_u_u_r_e X f g i j R c) X f g i j R c. reflexivity.
Qed.

Theorem pack_b_b_u_u_r_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall c c':set, pack_b_b_u_u_r_e X f g i j R c = pack_b_b_u_u_r_e X' f' g' i' j' R' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ c = c'.
let X X' f f' g g' i i' j j' R R' c c'. assume H1.
claim L0: X' = pack_b_b_u_u_r_e X f g i j R c 0.
{ exact pack_b_b_u_u_r_e_0_eq (pack_b_b_u_u_r_e X f g i j R c) X' f' g' i' j' R' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_u_r_e_0_eq2 X f g i j R c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_u_r_e_1_eq2 X f g i j R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_e_1_eq2 X' f' g' i' j' R' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_u_r_e_2_eq2 X f g i j R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_e_2_eq2 X' f' g' i' j' R' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_u_r_e_3_eq2 X f g i j R c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_e_3_eq2 X' f' g' i' j' R' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_u_u_r_e_4_eq2 X f g i j R c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_e_4_eq2 X' f' g' i' j' R' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_u_r_e_5_eq2 X f g i j R c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_e_5_eq2 X' f' g' i' j' R' c' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_u_u_r_e_6_eq2 X f g i j R c.
  rewrite H1. symmetry.
  exact pack_b_b_u_u_r_e_6_eq2 X' f' g' i' j' R' c'.
Qed.

Theorem pack_b_b_u_u_r_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_b_u_u_r_e X f g i j R c = pack_b_b_u_u_r_e X f' g' i' j' R' c.
let X f f' g g' i i' j j' R R' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_r X R,c) = (X,encode_b X f',encode_b X g',encode_u X i',encode_u X j',encode_r X R',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_u_u_r_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> q (pack_b_b_u_u_r_e X f g i j R c)) -> q S.

Theorem pack_struct_b_b_u_u_r_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> struct_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let j. assume Hj. let R c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg i Hi j Hj R c Hc.
Qed.

Theorem pack_struct_b_b_u_u_r_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c) -> forall x y :e X, f x y :e X.
let X f g i j R c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_e X f g i j R c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_r_e X' f' g' i' j' R' c' = pack_b_b_u_u_r_e X f g i j R c.
  apply pack_b_b_u_u_r_e_inj X' X f' f g' g i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c) -> forall x y :e X, g x y :e X.
let X f g i j R c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_e X f g i j R c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_r_e X' f' g' i' j' R' c' = pack_b_b_u_u_r_e X f g i j R c.
  apply pack_b_b_u_u_r_e_inj X' X f' f g' g i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c) -> forall x :e X, i x :e X.
let X f g i j R c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_e X f g i j R c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_r_e X' f' g' i' j' R' c' = pack_b_b_u_u_r_e X f g i j R c.
  apply pack_b_b_u_u_r_e_inj X' X f' f g' g i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c) -> forall x :e X, j x :e X.
let X f g i j R c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_e X f g i j R c -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_r_e X' f' g' i' j' R' c' = pack_b_b_u_u_r_e X f g i j R c.
  apply pack_b_b_u_u_r_e_inj X' X f' f g' g i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_r_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set, struct_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c) -> c :e X.
let X f g i j R c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_e X f g i j R c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let R'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_r_e X' f' g' i' j' R' c' = pack_b_b_u_u_r_e X f g i j R c.
  apply pack_b_b_u_u_r_e_inj X' X f' f g' g i' i j' j R' R c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HR'R Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_u_u_r_e_eta: forall S, struct_b_b_u_u_r_e S -> S = pack_b_b_u_u_r_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_u_r_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_r (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let j. assume _. let R. let c. assume _.
prove pack_b_b_u_u_r_e X f g i j R c = pack_b_b_u_u_r_e (pack_b_b_u_u_r_e X f g i j R c 0) (decode_b (pack_b_b_u_u_r_e X f g i j R c 1)) (decode_b (pack_b_b_u_u_r_e X f g i j R c 2)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 3)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 4)) (decode_r (pack_b_b_u_u_r_e X f g i j R c 5)) (pack_b_b_u_u_r_e X f g i j R c 6).
rewrite <- pack_b_b_u_u_r_e_0_eq2 X f g i j R c.
rewrite <- pack_b_b_u_u_r_e_6_eq2 X f g i j R c.
apply pack_b_b_u_u_r_e_ext.
- exact pack_b_b_u_u_r_e_1_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_2_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_3_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_4_eq2 X f g i j R c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_u_r_e_5_eq2 X f g i j R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_r_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_u_u_r_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' i' j' R' c = Phi X f g i j R c)
  ->
  unpack_b_b_u_u_r_e_i (pack_b_b_u_u_r_e X f g i j R c) Phi = Phi X f g i j R c.
let Phi X f g i j R c.
assume HPhi.
prove Phi (pack_b_b_u_u_r_e X f g i j R c 0) (decode_b (pack_b_b_u_u_r_e X f g i j R c 1)) (decode_b (pack_b_b_u_u_r_e X f g i j R c 2)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 3)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 4)) (decode_r (pack_b_b_u_u_r_e X f g i j R c 5)) (pack_b_b_u_u_r_e X f g i j R c 6) = Phi X f g i j R c.
rewrite <- pack_b_b_u_u_r_e_0_eq2 X f g i j R c.
prove Phi X (decode_b (pack_b_b_u_u_r_e X f g i j R c 1)) (decode_b (pack_b_b_u_u_r_e X f g i j R c 2)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 3)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 4)) (decode_r (pack_b_b_u_u_r_e X f g i j R c 5)) (pack_b_b_u_u_r_e X f g i j R c 6) = Phi X f g i j R c.
rewrite <- pack_b_b_u_u_r_e_6_eq2 X f g i j R c.
apply HPhi.
- exact pack_b_b_u_u_r_e_1_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_2_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_3_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_4_eq2 X f g i j R c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_u_r_e X f g i j R c 5) x y.
  rewrite <- pack_b_b_u_u_r_e_5_eq2 X f g i j R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_r_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_u_u_r_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' i' j' R' c = Phi X f g i j R c)
  ->
  unpack_b_b_u_u_r_e_o (pack_b_b_u_u_r_e X f g i j R c) Phi = Phi X f g i j R c.
let Phi X f g i j R c.
assume HPhi.
prove Phi (pack_b_b_u_u_r_e X f g i j R c 0) (decode_b (pack_b_b_u_u_r_e X f g i j R c 1)) (decode_b (pack_b_b_u_u_r_e X f g i j R c 2)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 3)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 4)) (decode_r (pack_b_b_u_u_r_e X f g i j R c 5)) (pack_b_b_u_u_r_e X f g i j R c 6) = Phi X f g i j R c.
rewrite <- pack_b_b_u_u_r_e_0_eq2 X f g i j R c.
prove Phi X (decode_b (pack_b_b_u_u_r_e X f g i j R c 1)) (decode_b (pack_b_b_u_u_r_e X f g i j R c 2)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 3)) (decode_u (pack_b_b_u_u_r_e X f g i j R c 4)) (decode_r (pack_b_b_u_u_r_e X f g i j R c 5)) (pack_b_b_u_u_r_e X f g i j R c 6) = Phi X f g i j R c.
rewrite <- pack_b_b_u_u_r_e_6_eq2 X f g i j R c.
apply HPhi.
- exact pack_b_b_u_u_r_e_1_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_2_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_3_eq2 X f g i j R c.
- exact pack_b_b_u_u_r_e_4_eq2 X f g i j R c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_u_r_e X f g i j R c 5) x y.
  rewrite <- pack_b_b_u_u_r_e_5_eq2 X f g i j R c x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_u_u_p_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set := fun X f g i j P Q => (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q).

Theorem pack_b_b_u_u_p_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> X = S 0.
let S X f g i j P Q. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_u_p_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, X = pack_b_b_u_u_p_p X f g i j P Q 0.
let X f g i j P Q. apply pack_b_b_u_u_p_p_0_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i j P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_p_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_u_u_p_p X f g i j P Q 1) x y.
let X f g i j P Q. apply pack_b_b_u_u_p_p_1_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i j P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_p_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_u_u_p_p X f g i j P Q 2) x y.
let X f g i j P Q. apply pack_b_b_u_u_p_p_2_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_u_p_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_b_b_u_u_p_p X f g i j P Q 3) x.
let X f g i j P Q. apply pack_b_b_u_u_p_p_3_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> forall x :e X, j x = decode_u (S 4) x.
let S X f g i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_u_u_p_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, j x = decode_u (pack_b_b_u_u_p_p X f g i j P Q 4) x.
let X f g i j P Q. apply pack_b_b_u_u_p_p_4_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X f g i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_u_p_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_b_b_u_u_p_p X f g i j P Q 5) x.
let X f g i j P Q. apply pack_b_b_u_u_p_p_5_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_u_p_p X f g i j P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X f g i j P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_u_u_p_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_b_b_u_u_p_p X f g i j P Q 6) x.
let X f g i j P Q. apply pack_b_b_u_u_p_p_6_eq (pack_b_b_u_u_p_p X f g i j P Q) X f g i j P Q. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, pack_b_b_u_u_p_p X f g i j P Q = pack_b_b_u_u_p_p X' f' g' i' j' P' Q' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' f f' g g' i i' j j' P P' Q Q'. assume H1.
claim L0: X' = pack_b_b_u_u_p_p X f g i j P Q 0.
{ exact pack_b_b_u_u_p_p_0_eq (pack_b_b_u_u_p_p X f g i j P Q) X' f' g' i' j' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_u_p_p_0_eq2 X f g i j P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_u_p_p_1_eq2 X f g i j P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_p_1_eq2 X' f' g' i' j' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_u_p_p_2_eq2 X f g i j P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_p_2_eq2 X' f' g' i' j' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_u_p_p_3_eq2 X f g i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_p_3_eq2 X' f' g' i' j' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_u_u_p_p_4_eq2 X f g i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_p_4_eq2 X' f' g' i' j' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_u_p_p_5_eq2 X f g i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_p_5_eq2 X' f' g' i' j' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_u_u_p_p_6_eq2 X f g i j P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_p_6_eq2 X' f' g' i' j' P' Q' x Lx.
Qed.

Theorem pack_b_b_u_u_p_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_u_u_p_p X f g i j P Q = pack_b_b_u_u_p_p X f' g' i' j' P' Q'.
let X f f' g g' i i' j j' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,encode_p X Q) = (X,encode_b X f',encode_b X g',encode_u X i',encode_u X j',encode_p X P',encode_p X Q').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_u_u_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall Q:set -> prop, q (pack_b_b_u_u_p_p X f g i j P Q)) -> q S.

Theorem pack_struct_b_b_u_u_p_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_u_p_p (pack_b_b_u_u_p_p X f g i j P Q).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let j. assume Hj. let P Q q. assume Hq.
exact Hq X f Hf g Hg i Hi j Hj P Q.
Qed.

Theorem pack_struct_b_b_u_u_p_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_u_p_p (pack_b_b_u_u_p_p X f g i j P Q) -> forall x y :e X, f x y :e X.
let X f g i j P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_p X f g i j P Q -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_b_b_u_u_p_p X' f' g' i' j' P' Q' = pack_b_b_u_u_p_p X f g i j P Q.
  apply pack_b_b_u_u_p_p_inj X' X f' f g' g i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_u_p_p (pack_b_b_u_u_p_p X f g i j P Q) -> forall x y :e X, g x y :e X.
let X f g i j P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_p X f g i j P Q -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_b_b_u_u_p_p X' f' g' i' j' P' Q' = pack_b_b_u_u_p_p X f g i j P Q.
  apply pack_b_b_u_u_p_p_inj X' X f' f g' g i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_u_p_p (pack_b_b_u_u_p_p X f g i j P Q) -> forall x :e X, i x :e X.
let X f g i j P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_p X f g i j P Q -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_b_b_u_u_p_p X' f' g' i' j' P' Q' = pack_b_b_u_u_p_p X f g i j P Q.
  apply pack_b_b_u_u_p_p_inj X' X f' f g' g i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_p_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_u_p_p (pack_b_b_u_u_p_p X f g i j P Q) -> forall x :e X, j x :e X.
let X f g i j P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_p X f g i j P Q -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'.
  assume Heq: pack_b_b_u_u_p_p X' f' g' i' j' P' Q' = pack_b_b_u_u_p_p X f g i j P Q.
  apply pack_b_b_u_u_p_p_inj X' X f' f g' g i' i j' j P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_u_u_p_p_eta: forall S, struct_b_b_u_u_p_p S -> S = pack_b_b_u_u_p_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let i. assume _. let j. assume _. let P. let Q.
prove pack_b_b_u_u_p_p X f g i j P Q = pack_b_b_u_u_p_p (pack_b_b_u_u_p_p X f g i j P Q 0) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 1)) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 2)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 3)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 4)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 5)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 6)).
rewrite <- pack_b_b_u_u_p_p_0_eq2 X f g i j P Q.
apply pack_b_b_u_u_p_p_ext.
- exact pack_b_b_u_u_p_p_1_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_2_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_3_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_4_eq2 X f g i j P Q.
- let x. assume Hx.
  rewrite <- pack_b_b_u_u_p_p_5_eq2 X f g i j P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_u_p_p_6_eq2 X f g i j P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_p_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_u_p_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' i' j' P' Q' = Phi X f g i j P Q)
  ->
  unpack_b_b_u_u_p_p_i (pack_b_b_u_u_p_p X f g i j P Q) Phi = Phi X f g i j P Q.
let Phi X f g i j P Q.
assume HPhi.
prove Phi (pack_b_b_u_u_p_p X f g i j P Q 0) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 1)) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 2)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 3)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 4)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 5)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 6)) = Phi X f g i j P Q.
rewrite <- pack_b_b_u_u_p_p_0_eq2 X f g i j P Q.
prove Phi X (decode_b (pack_b_b_u_u_p_p X f g i j P Q 1)) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 2)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 3)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 4)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 5)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 6)) = Phi X f g i j P Q.
apply HPhi.
- exact pack_b_b_u_u_p_p_1_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_2_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_3_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_4_eq2 X f g i j P Q.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_u_p_p X f g i j P Q 5) x.
  rewrite <- pack_b_b_u_u_p_p_5_eq2 X f g i j P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_u_u_p_p X f g i j P Q 6) x.
  rewrite <- pack_b_b_u_u_p_p_6_eq2 X f g i j P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_p_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_u_p_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' i' j' P' Q' = Phi X f g i j P Q)
  ->
  unpack_b_b_u_u_p_p_o (pack_b_b_u_u_p_p X f g i j P Q) Phi = Phi X f g i j P Q.
let Phi X f g i j P Q.
assume HPhi.
prove Phi (pack_b_b_u_u_p_p X f g i j P Q 0) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 1)) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 2)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 3)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 4)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 5)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 6)) = Phi X f g i j P Q.
rewrite <- pack_b_b_u_u_p_p_0_eq2 X f g i j P Q.
prove Phi X (decode_b (pack_b_b_u_u_p_p X f g i j P Q 1)) (decode_b (pack_b_b_u_u_p_p X f g i j P Q 2)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 3)) (decode_u (pack_b_b_u_u_p_p X f g i j P Q 4)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 5)) (decode_p (pack_b_b_u_u_p_p X f g i j P Q 6)) = Phi X f g i j P Q.
apply HPhi.
- exact pack_b_b_u_u_p_p_1_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_2_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_3_eq2 X f g i j P Q.
- exact pack_b_b_u_u_p_p_4_eq2 X f g i j P Q.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_u_p_p X f g i j P Q 5) x.
  rewrite <- pack_b_b_u_u_p_p_5_eq2 X f g i j P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_u_u_p_p X f g i j P Q 6) x.
  rewrite <- pack_b_b_u_u_p_p_6_eq2 X f g i j P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_u_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> set := fun X f g i j P c => (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c).

Theorem pack_b_b_u_u_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> X = S 0.
let S X f g i j P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_u_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, X = pack_b_b_u_u_p_e X f g i j P c 0.
let X f g i j P c. apply pack_b_b_u_u_p_e_0_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i j P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_u_u_p_e X f g i j P c 1) x y.
let X f g i j P c. apply pack_b_b_u_u_p_e_1_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i j P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_u_u_p_e X f g i j P c 2) x y.
let X f g i j P c. apply pack_b_b_u_u_p_e_2_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i j P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_u_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_u_u_p_e X f g i j P c 3) x.
let X f g i j P c. apply pack_b_b_u_u_p_e_3_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> forall x :e X, j x = decode_u (S 4) x.
let S X f g i j P c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_u_u_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x :e X, j x = decode_u (pack_b_b_u_u_p_e X f g i j P c 4) x.
let X f g i j P c. apply pack_b_b_u_u_p_e_4_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> forall x :e X, P x = decode_p (S 5) x.
let S X f g i j P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_u_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_u_u_p_e X f g i j P c 5) x.
let X f g i j P c. apply pack_b_b_u_u_p_e_5_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, S = pack_b_b_u_u_p_e X f g i j P c -> c = S 6.
let S X f g i j P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_u_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, c = pack_b_b_u_u_p_e X f g i j P c 6.
let X f g i j P c. apply pack_b_b_u_u_p_e_6_eq (pack_b_b_u_u_p_e X f g i j P c) X f g i j P c. reflexivity.
Qed.

Theorem pack_b_b_u_u_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall c c':set, pack_b_b_u_u_p_e X f g i j P c = pack_b_b_u_u_p_e X' f' g' i' j' P' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' f f' g g' i i' j j' P P' c c'. assume H1.
claim L0: X' = pack_b_b_u_u_p_e X f g i j P c 0.
{ exact pack_b_b_u_u_p_e_0_eq (pack_b_b_u_u_p_e X f g i j P c) X' f' g' i' j' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_u_p_e_0_eq2 X f g i j P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_u_p_e_1_eq2 X f g i j P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_e_1_eq2 X' f' g' i' j' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_u_p_e_2_eq2 X f g i j P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_e_2_eq2 X' f' g' i' j' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_u_p_e_3_eq2 X f g i j P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_e_3_eq2 X' f' g' i' j' P' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_u_u_p_e_4_eq2 X f g i j P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_e_4_eq2 X' f' g' i' j' P' c' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_u_p_e_5_eq2 X f g i j P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_e_5_eq2 X' f' g' i' j' P' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_u_u_p_e_6_eq2 X f g i j P c.
  rewrite H1. symmetry.
  exact pack_b_b_u_u_p_e_6_eq2 X' f' g' i' j' P' c'.
Qed.

Theorem pack_b_b_u_u_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_u_u_p_e X f g i j P c = pack_b_b_u_u_p_e X f' g' i' j' P' c.
let X f f' g g' i i' j j' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,encode_p X P,c) = (X,encode_b X f',encode_b X g',encode_u X i',encode_u X j',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_u_u_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall c:set, c :e X -> q (pack_b_b_u_u_p_e X f g i j P c)) -> q S.

Theorem pack_struct_b_b_u_u_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall c:set, c :e X -> struct_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let j. assume Hj. let P c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg i Hi j Hj P c Hc.
Qed.

Theorem pack_struct_b_b_u_u_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c) -> forall x y :e X, f x y :e X.
let X f g i j P c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_e X f g i j P c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_p_e X' f' g' i' j' P' c' = pack_b_b_u_u_p_e X f g i j P c.
  apply pack_b_b_u_u_p_e_inj X' X f' f g' g i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c) -> forall x y :e X, g x y :e X.
let X f g i j P c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_e X f g i j P c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_p_e X' f' g' i' j' P' c' = pack_b_b_u_u_p_e X f g i j P c.
  apply pack_b_b_u_u_p_e_inj X' X f' f g' g i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c) -> forall x :e X, i x :e X.
let X f g i j P c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_e X f g i j P c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_p_e X' f' g' i' j' P' c' = pack_b_b_u_u_p_e X f g i j P c.
  apply pack_b_b_u_u_p_e_inj X' X f' f g' g i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c) -> forall x :e X, j x :e X.
let X f g i j P c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_e X f g i j P c -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_p_e X' f' g' i' j' P' c' = pack_b_b_u_u_p_e X f g i j P c.
  apply pack_b_b_u_u_p_e_inj X' X f' f g' g i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set, struct_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c) -> c :e X.
let X f g i j P c. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_e X f g i j P c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_u_p_e X' f' g' i' j' P' c' = pack_b_b_u_u_p_e X f g i j P c.
  apply pack_b_b_u_u_p_e_inj X' X f' f g' g i' i j' j P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_u_u_p_e_eta: forall S, struct_b_b_u_u_p_e S -> S = pack_b_b_u_u_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_u_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let j. assume _. let P. let c. assume _.
prove pack_b_b_u_u_p_e X f g i j P c = pack_b_b_u_u_p_e (pack_b_b_u_u_p_e X f g i j P c 0) (decode_b (pack_b_b_u_u_p_e X f g i j P c 1)) (decode_b (pack_b_b_u_u_p_e X f g i j P c 2)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 3)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 4)) (decode_p (pack_b_b_u_u_p_e X f g i j P c 5)) (pack_b_b_u_u_p_e X f g i j P c 6).
rewrite <- pack_b_b_u_u_p_e_0_eq2 X f g i j P c.
rewrite <- pack_b_b_u_u_p_e_6_eq2 X f g i j P c.
apply pack_b_b_u_u_p_e_ext.
- exact pack_b_b_u_u_p_e_1_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_2_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_3_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_4_eq2 X f g i j P c.
- let x. assume Hx.
  rewrite <- pack_b_b_u_u_p_e_5_eq2 X f g i j P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_u_u_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' j' P' c = Phi X f g i j P c)
  ->
  unpack_b_b_u_u_p_e_i (pack_b_b_u_u_p_e X f g i j P c) Phi = Phi X f g i j P c.
let Phi X f g i j P c.
assume HPhi.
prove Phi (pack_b_b_u_u_p_e X f g i j P c 0) (decode_b (pack_b_b_u_u_p_e X f g i j P c 1)) (decode_b (pack_b_b_u_u_p_e X f g i j P c 2)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 3)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 4)) (decode_p (pack_b_b_u_u_p_e X f g i j P c 5)) (pack_b_b_u_u_p_e X f g i j P c 6) = Phi X f g i j P c.
rewrite <- pack_b_b_u_u_p_e_0_eq2 X f g i j P c.
prove Phi X (decode_b (pack_b_b_u_u_p_e X f g i j P c 1)) (decode_b (pack_b_b_u_u_p_e X f g i j P c 2)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 3)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 4)) (decode_p (pack_b_b_u_u_p_e X f g i j P c 5)) (pack_b_b_u_u_p_e X f g i j P c 6) = Phi X f g i j P c.
rewrite <- pack_b_b_u_u_p_e_6_eq2 X f g i j P c.
apply HPhi.
- exact pack_b_b_u_u_p_e_1_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_2_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_3_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_4_eq2 X f g i j P c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_u_p_e X f g i j P c 5) x.
  rewrite <- pack_b_b_u_u_p_e_5_eq2 X f g i j P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_u_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_u_u_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' j' P' c = Phi X f g i j P c)
  ->
  unpack_b_b_u_u_p_e_o (pack_b_b_u_u_p_e X f g i j P c) Phi = Phi X f g i j P c.
let Phi X f g i j P c.
assume HPhi.
prove Phi (pack_b_b_u_u_p_e X f g i j P c 0) (decode_b (pack_b_b_u_u_p_e X f g i j P c 1)) (decode_b (pack_b_b_u_u_p_e X f g i j P c 2)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 3)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 4)) (decode_p (pack_b_b_u_u_p_e X f g i j P c 5)) (pack_b_b_u_u_p_e X f g i j P c 6) = Phi X f g i j P c.
rewrite <- pack_b_b_u_u_p_e_0_eq2 X f g i j P c.
prove Phi X (decode_b (pack_b_b_u_u_p_e X f g i j P c 1)) (decode_b (pack_b_b_u_u_p_e X f g i j P c 2)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 3)) (decode_u (pack_b_b_u_u_p_e X f g i j P c 4)) (decode_p (pack_b_b_u_u_p_e X f g i j P c 5)) (pack_b_b_u_u_p_e X f g i j P c 6) = Phi X f g i j P c.
rewrite <- pack_b_b_u_u_p_e_6_eq2 X f g i j P c.
apply HPhi.
- exact pack_b_b_u_u_p_e_1_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_2_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_3_eq2 X f g i j P c.
- exact pack_b_b_u_u_p_e_4_eq2 X f g i j P c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_u_p_e X f g i j P c 5) x.
  rewrite <- pack_b_b_u_u_p_e_5_eq2 X f g i j P c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_u_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> set := fun X f g i j c d => (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d).

Theorem pack_b_b_u_u_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> X = S 0.
let S X f g i j c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_u_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, X = pack_b_b_u_u_e_e X f g i j c d 0.
let X f g i j c d. apply pack_b_b_u_u_e_e_0_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i j c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_u_u_e_e X f g i j c d 1) x y.
let X f g i j c d. apply pack_b_b_u_u_e_e_1_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i j c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_u_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_u_u_e_e X f g i j c d 2) x y.
let X f g i j c d. apply pack_b_b_u_u_e_e_2_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i j c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_u_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_b_u_u_e_e X f g i j c d 3) x.
let X f g i j c d. apply pack_b_b_u_u_e_e_3_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> forall x :e X, j x = decode_u (S 4) x.
let S X f g i j c d. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_b_b_u_u_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, forall x :e X, j x = decode_u (pack_b_b_u_u_e_e X f g i j c d 4) x.
let X f g i j c d. apply pack_b_b_u_u_e_e_4_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> c = S 5.
let S X f g i j c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_u_u_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, c = pack_b_b_u_u_e_e X f g i j c d 5.
let X f g i j c d. apply pack_b_b_u_u_e_e_5_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, S = pack_b_b_u_u_e_e X f g i j c d -> d = S 6.
let S X f g i j c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_u_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, d = pack_b_b_u_u_e_e X f g i j c d 6.
let X f g i j c d. apply pack_b_b_u_u_e_e_6_eq (pack_b_b_u_u_e_e X f g i j c d) X f g i j c d. reflexivity.
Qed.

Theorem pack_b_b_u_u_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall c c':set, forall d d':set, pack_b_b_u_u_e_e X f g i j c d = pack_b_b_u_u_e_e X' f' g' i' j' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ c = c' /\ d = d'.
let X X' f f' g g' i i' j j' c c' d d'. assume H1.
claim L0: X' = pack_b_b_u_u_e_e X f g i j c d 0.
{ exact pack_b_b_u_u_e_e_0_eq (pack_b_b_u_u_e_e X f g i j c d) X' f' g' i' j' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_u_e_e_0_eq2 X f g i j c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_u_e_e_1_eq2 X f g i j c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_e_e_1_eq2 X' f' g' i' j' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_u_e_e_2_eq2 X f g i j c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_e_e_2_eq2 X' f' g' i' j' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_u_e_e_3_eq2 X f g i j c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_e_e_3_eq2 X' f' g' i' j' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_b_b_u_u_e_e_4_eq2 X f g i j c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_u_e_e_4_eq2 X' f' g' i' j' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_b_u_u_e_e_5_eq2 X f g i j c d.
  rewrite H1. symmetry.
  exact pack_b_b_u_u_e_e_5_eq2 X' f' g' i' j' c' d'.
- prove d = d'.
  rewrite pack_b_b_u_u_e_e_6_eq2 X f g i j c d.
  rewrite H1. symmetry.
  exact pack_b_b_u_u_e_e_6_eq2 X' f' g' i' j' c' d'.
Qed.

Theorem pack_b_b_u_u_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall j j':set -> set, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 pack_b_b_u_u_e_e X f g i j c d = pack_b_b_u_u_e_e X f' g' i' j' c d.
let X f f' g g' i i' j j' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_u X j,c,d) = (X,encode_b X f',encode_b X g',encode_u X i',encode_u X j',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_u_u_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_u_u_e_e X f g i j c d)) -> q S.

Theorem pack_struct_b_b_u_u_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let j. assume Hj. let c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg i Hi j Hj c Hc d Hd.
Qed.

Theorem pack_struct_b_b_u_u_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d) -> forall x y :e X, f x y :e X.
let X f g i j c d. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e X f g i j c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_u_e_e X' f' g' i' j' c' d' = pack_b_b_u_u_e_e X f g i j c d.
  apply pack_b_b_u_u_e_e_inj X' X f' f g' g i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d) -> forall x y :e X, g x y :e X.
let X f g i j c d. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e X f g i j c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_u_e_e X' f' g' i' j' c' d' = pack_b_b_u_u_e_e X f g i j c d.
  apply pack_b_b_u_u_e_e_inj X' X f' f g' g i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_e_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d) -> forall x :e X, i x :e X.
let X f g i j c d. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e X f g i j c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_u_e_e X' f' g' i' j' c' d' = pack_b_b_u_u_e_e X f g i j c d.
  apply pack_b_b_u_u_e_e_inj X' X f' f g' g i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_e_e_E4: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d) -> forall x :e X, j x :e X.
let X f g i j c d. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e X f g i j c d -> forall x :e X, j x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_u_e_e X' f' g' i' j' c' d' = pack_b_b_u_u_e_e X f g i j c d.
  apply pack_b_b_u_u_e_e_inj X' X f' f g' g i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d) -> c :e X.
let X f g i j c d. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e X f g i j c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_u_e_e X' f' g' i' j' c' d' = pack_b_b_u_u_e_e X f g i j c d.
  apply pack_b_b_u_u_e_e_inj X' X f' f g' g i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_u_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set, struct_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d) -> d :e X.
let X f g i j c d. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e X f g i j c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let j'. assume Hj'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_u_e_e X' f' g' i' j' c' d' = pack_b_b_u_u_e_e X f g i j c d.
  apply pack_b_b_u_u_e_e_inj X' X f' f g' g i' i j' j c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i Hj'j Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_u_u_e_e_eta: forall S, struct_b_b_u_u_e_e S -> S = pack_b_b_u_u_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_u_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_u (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let j. assume _. let c. assume _. let d. assume _.
prove pack_b_b_u_u_e_e X f g i j c d = pack_b_b_u_u_e_e (pack_b_b_u_u_e_e X f g i j c d 0) (decode_b (pack_b_b_u_u_e_e X f g i j c d 1)) (decode_b (pack_b_b_u_u_e_e X f g i j c d 2)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 3)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 4)) (pack_b_b_u_u_e_e X f g i j c d 5) (pack_b_b_u_u_e_e X f g i j c d 6).
rewrite <- pack_b_b_u_u_e_e_0_eq2 X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_5_eq2 X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_6_eq2 X f g i j c d.
apply pack_b_b_u_u_e_e_ext.
- exact pack_b_b_u_u_e_e_1_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_2_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_3_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_4_eq2 X f g i j c d.
Qed.


Definition unpack_b_b_u_u_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (S 5) (S 6).

Theorem unpack_b_b_u_u_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) -> Phi X f' g' i' j' c d = Phi X f g i j c d)
  ->
  unpack_b_b_u_u_e_e_i (pack_b_b_u_u_e_e X f g i j c d) Phi = Phi X f g i j c d.
let Phi X f g i j c d.
assume HPhi.
prove Phi (pack_b_b_u_u_e_e X f g i j c d 0) (decode_b (pack_b_b_u_u_e_e X f g i j c d 1)) (decode_b (pack_b_b_u_u_e_e X f g i j c d 2)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 3)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 4)) (pack_b_b_u_u_e_e X f g i j c d 5) (pack_b_b_u_u_e_e X f g i j c d 6) = Phi X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_0_eq2 X f g i j c d.
prove Phi X (decode_b (pack_b_b_u_u_e_e X f g i j c d 1)) (decode_b (pack_b_b_u_u_e_e X f g i j c d 2)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 3)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 4)) (pack_b_b_u_u_e_e X f g i j c d 5) (pack_b_b_u_u_e_e X f g i j c d 6) = Phi X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_5_eq2 X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_6_eq2 X f g i j c d.
apply HPhi.
- exact pack_b_b_u_u_e_e_1_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_2_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_3_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_4_eq2 X f g i j c d.
Qed.


Definition unpack_b_b_u_u_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_u (S 4)) (S 5) (S 6).

Theorem unpack_b_b_u_u_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall j:set -> set, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) -> Phi X f' g' i' j' c d = Phi X f g i j c d)
  ->
  unpack_b_b_u_u_e_e_o (pack_b_b_u_u_e_e X f g i j c d) Phi = Phi X f g i j c d.
let Phi X f g i j c d.
assume HPhi.
prove Phi (pack_b_b_u_u_e_e X f g i j c d 0) (decode_b (pack_b_b_u_u_e_e X f g i j c d 1)) (decode_b (pack_b_b_u_u_e_e X f g i j c d 2)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 3)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 4)) (pack_b_b_u_u_e_e X f g i j c d 5) (pack_b_b_u_u_e_e X f g i j c d 6) = Phi X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_0_eq2 X f g i j c d.
prove Phi X (decode_b (pack_b_b_u_u_e_e X f g i j c d 1)) (decode_b (pack_b_b_u_u_e_e X f g i j c d 2)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 3)) (decode_u (pack_b_b_u_u_e_e X f g i j c d 4)) (pack_b_b_u_u_e_e X f g i j c d 5) (pack_b_b_u_u_e_e X f g i j c d 6) = Phi X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_5_eq2 X f g i j c d.
rewrite <- pack_b_b_u_u_e_e_6_eq2 X f g i j c d.
apply HPhi.
- exact pack_b_b_u_u_e_e_1_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_2_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_3_eq2 X f g i j c d.
- exact pack_b_b_u_u_e_e_4_eq2 X f g i j c d.
Qed.


Definition pack_b_b_u_r_r_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set := fun X f g i R T P => (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P).

Theorem pack_b_b_u_r_r_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> X = S 0.
let S X f g i R T P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_r_r_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, X = pack_b_b_u_r_r_p X f g i R T P 0.
let X f g i R T P. apply pack_b_b_u_r_r_p_0_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_u_r_r_p X f g i R T P 1) x y.
let X f g i R T P. apply pack_b_b_u_r_r_p_1_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_u_r_r_p X f g i R T P 2) x y.
let X f g i R T P. apply pack_b_b_u_r_r_p_2_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i R T P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_r_r_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x :e X, i x = decode_u (pack_b_b_u_r_r_p X f g i R T P 3) x.
let X f g i R T P. apply pack_b_b_u_r_r_p_3_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_u_r_r_p X f g i R T P 4) x y.
let X f g i R T P. apply pack_b_b_u_r_r_p_4_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> forall x y :e X, T x y = decode_r (S 5) x y.
let S X f g i R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x y :e X, T x y = decode_r (pack_b_b_u_r_r_p X f g i R T P 5) x y.
let X f g i R T P. apply pack_b_b_u_r_r_p_5_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_b_b_u_r_r_p X f g i R T P -> forall x :e X, P x = decode_p (S 6) x.
let S X f g i R T P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_r_r_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall x :e X, P x = decode_p (pack_b_b_u_r_r_p X f g i R T P 6) x.
let X f g i R T P. apply pack_b_b_u_r_r_p_6_eq (pack_b_b_u_r_r_p X f g i R T P) X f g i R T P. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, pack_b_b_u_r_r_p X f g i R T P = pack_b_b_u_r_r_p X' f' g' i' R' T' P' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x).
let X X' f f' g g' i i' R R' T T' P P'. assume H1.
claim L0: X' = pack_b_b_u_r_r_p X f g i R T P 0.
{ exact pack_b_b_u_r_r_p_0_eq (pack_b_b_u_r_r_p X f g i R T P) X' f' g' i' R' T' P' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_r_r_p_0_eq2 X f g i R T P. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_r_r_p_1_eq2 X f g i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_p_1_eq2 X' f' g' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_r_r_p_2_eq2 X f g i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_p_2_eq2 X' f' g' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_r_r_p_3_eq2 X f g i R T P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_p_3_eq2 X' f' g' i' R' T' P' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_r_r_p_4_eq2 X f g i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_p_4_eq2 X' f' g' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_u_r_r_p_5_eq2 X f g i R T P x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_p_5_eq2 X' f' g' i' R' T' P' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_r_r_p_6_eq2 X f g i R T P x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_p_6_eq2 X' f' g' i' R' T' P' x Lx.
Qed.

Theorem pack_b_b_u_r_r_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_u_r_r_p X f g i R T P = pack_b_b_u_r_r_p X f' g' i' R' T' P'.
let X f f' g g' i i' R R' T T' P P'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,encode_p X P) = (X,encode_b X f',encode_b X g',encode_u X i',encode_r X R',encode_r X T',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_u_r_r_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, q (pack_b_b_u_r_r_p X f g i R T P)) -> q S.

Theorem pack_struct_b_b_u_r_r_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_u_r_r_p (pack_b_b_u_r_r_p X f g i R T P).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let R T P q. assume Hq.
exact Hq X f Hf g Hg i Hi R T P.
Qed.

Theorem pack_struct_b_b_u_r_r_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_u_r_r_p (pack_b_b_u_r_r_p X f g i R T P) -> forall x y :e X, f x y :e X.
let X f g i R T P. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_p X f g i R T P -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let P'.
  assume Heq: pack_b_b_u_r_r_p X' f' g' i' R' T' P' = pack_b_b_u_r_r_p X f g i R T P.
  apply pack_b_b_u_r_r_p_inj X' X f' f g' g i' i R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_r_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_u_r_r_p (pack_b_b_u_r_r_p X f g i R T P) -> forall x y :e X, g x y :e X.
let X f g i R T P. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_p X f g i R T P -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let P'.
  assume Heq: pack_b_b_u_r_r_p X' f' g' i' R' T' P' = pack_b_b_u_r_r_p X f g i R T P.
  apply pack_b_b_u_r_r_p_inj X' X f' f g' g i' i R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_r_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_b_b_u_r_r_p (pack_b_b_u_r_r_p X f g i R T P) -> forall x :e X, i x :e X.
let X f g i R T P. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_p X f g i R T P -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let P'.
  assume Heq: pack_b_b_u_r_r_p X' f' g' i' R' T' P' = pack_b_b_u_r_r_p X f g i R T P.
  apply pack_b_b_u_r_r_p_inj X' X f' f g' g i' i R' R T' T P' P Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T HP'P.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_u_r_r_p_eta: forall S, struct_b_b_u_r_r_p S -> S = pack_b_b_u_r_r_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_r (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let i. assume _. let R. let T. let P.
prove pack_b_b_u_r_r_p X f g i R T P = pack_b_b_u_r_r_p (pack_b_b_u_r_r_p X f g i R T P 0) (decode_b (pack_b_b_u_r_r_p X f g i R T P 1)) (decode_b (pack_b_b_u_r_r_p X f g i R T P 2)) (decode_u (pack_b_b_u_r_r_p X f g i R T P 3)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 4)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 5)) (decode_p (pack_b_b_u_r_r_p X f g i R T P 6)).
rewrite <- pack_b_b_u_r_r_p_0_eq2 X f g i R T P.
apply pack_b_b_u_r_r_p_ext.
- exact pack_b_b_u_r_r_p_1_eq2 X f g i R T P.
- exact pack_b_b_u_r_r_p_2_eq2 X f g i R T P.
- exact pack_b_b_u_r_r_p_3_eq2 X f g i R T P.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_r_p_4_eq2 X f g i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_r_p_5_eq2 X f g i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_r_r_p_6_eq2 X f g i R T P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_r_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_r_r_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' R' T' P' = Phi X f g i R T P)
  ->
  unpack_b_b_u_r_r_p_i (pack_b_b_u_r_r_p X f g i R T P) Phi = Phi X f g i R T P.
let Phi X f g i R T P.
assume HPhi.
prove Phi (pack_b_b_u_r_r_p X f g i R T P 0) (decode_b (pack_b_b_u_r_r_p X f g i R T P 1)) (decode_b (pack_b_b_u_r_r_p X f g i R T P 2)) (decode_u (pack_b_b_u_r_r_p X f g i R T P 3)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 4)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 5)) (decode_p (pack_b_b_u_r_r_p X f g i R T P 6)) = Phi X f g i R T P.
rewrite <- pack_b_b_u_r_r_p_0_eq2 X f g i R T P.
prove Phi X (decode_b (pack_b_b_u_r_r_p X f g i R T P 1)) (decode_b (pack_b_b_u_r_r_p X f g i R T P 2)) (decode_u (pack_b_b_u_r_r_p X f g i R T P 3)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 4)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 5)) (decode_p (pack_b_b_u_r_r_p X f g i R T P 6)) = Phi X f g i R T P.
apply HPhi.
- exact pack_b_b_u_r_r_p_1_eq2 X f g i R T P.
- exact pack_b_b_u_r_r_p_2_eq2 X f g i R T P.
- exact pack_b_b_u_r_r_p_3_eq2 X f g i R T P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_r_p X f g i R T P 4) x y.
  rewrite <- pack_b_b_u_r_r_p_4_eq2 X f g i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_u_r_r_p X f g i R T P 5) x y.
  rewrite <- pack_b_b_u_r_r_p_5_eq2 X f g i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_r_r_p X f g i R T P 6) x.
  rewrite <- pack_b_b_u_r_r_p_6_eq2 X f g i R T P x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_r_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_r_r_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' R' T' P' = Phi X f g i R T P)
  ->
  unpack_b_b_u_r_r_p_o (pack_b_b_u_r_r_p X f g i R T P) Phi = Phi X f g i R T P.
let Phi X f g i R T P.
assume HPhi.
prove Phi (pack_b_b_u_r_r_p X f g i R T P 0) (decode_b (pack_b_b_u_r_r_p X f g i R T P 1)) (decode_b (pack_b_b_u_r_r_p X f g i R T P 2)) (decode_u (pack_b_b_u_r_r_p X f g i R T P 3)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 4)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 5)) (decode_p (pack_b_b_u_r_r_p X f g i R T P 6)) = Phi X f g i R T P.
rewrite <- pack_b_b_u_r_r_p_0_eq2 X f g i R T P.
prove Phi X (decode_b (pack_b_b_u_r_r_p X f g i R T P 1)) (decode_b (pack_b_b_u_r_r_p X f g i R T P 2)) (decode_u (pack_b_b_u_r_r_p X f g i R T P 3)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 4)) (decode_r (pack_b_b_u_r_r_p X f g i R T P 5)) (decode_p (pack_b_b_u_r_r_p X f g i R T P 6)) = Phi X f g i R T P.
apply HPhi.
- exact pack_b_b_u_r_r_p_1_eq2 X f g i R T P.
- exact pack_b_b_u_r_r_p_2_eq2 X f g i R T P.
- exact pack_b_b_u_r_r_p_3_eq2 X f g i R T P.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_r_p X f g i R T P 4) x y.
  rewrite <- pack_b_b_u_r_r_p_4_eq2 X f g i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_u_r_r_p X f g i R T P 5) x y.
  rewrite <- pack_b_b_u_r_r_p_5_eq2 X f g i R T P x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_r_r_p X f g i R T P 6) x.
  rewrite <- pack_b_b_u_r_r_p_6_eq2 X f g i R T P x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_r_r_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set := fun X f g i R T c => (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c).

Theorem pack_b_b_u_r_r_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> X = S 0.
let S X f g i R T c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_r_r_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, X = pack_b_b_u_r_r_e X f g i R T c 0.
let X f g i R T c. apply pack_b_b_u_r_r_e_0_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_u_r_r_e X f g i R T c 1) x y.
let X f g i R T c. apply pack_b_b_u_r_r_e_1_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_u_r_r_e X f g i R T c 2) x y.
let X f g i R T c. apply pack_b_b_u_r_r_e_2_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i R T c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_r_r_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_u_r_r_e X f g i R T c 3) x.
let X f g i R T c. apply pack_b_b_u_r_r_e_3_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_u_r_r_e X f g i R T c 4) x y.
let X f g i R T c. apply pack_b_b_u_r_r_e_4_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> forall x y :e X, T x y = decode_r (S 5) x y.
let S X f g i R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 5) x y.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_r_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_b_b_u_r_r_e X f g i R T c 5) x y.
let X f g i R T c. apply pack_b_b_u_r_r_e_5_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_b_b_u_r_r_e X f g i R T c -> c = S 6.
let S X f g i R T c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_r_r_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c = pack_b_b_u_r_r_e X f g i R T c 6.
let X f g i R T c. apply pack_b_b_u_r_r_e_6_eq (pack_b_b_u_r_r_e X f g i R T c) X f g i R T c. reflexivity.
Qed.

Theorem pack_b_b_u_r_r_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, pack_b_b_u_r_r_e X f g i R T c = pack_b_b_u_r_r_e X' f' g' i' R' T' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c'.
let X X' f f' g g' i i' R R' T T' c c'. assume H1.
claim L0: X' = pack_b_b_u_r_r_e X f g i R T c 0.
{ exact pack_b_b_u_r_r_e_0_eq (pack_b_b_u_r_r_e X f g i R T c) X' f' g' i' R' T' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_r_r_e_0_eq2 X f g i R T c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_r_r_e_1_eq2 X f g i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_e_1_eq2 X' f' g' i' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_r_r_e_2_eq2 X f g i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_e_2_eq2 X' f' g' i' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_r_r_e_3_eq2 X f g i R T c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_e_3_eq2 X' f' g' i' R' T' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_r_r_e_4_eq2 X f g i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_e_4_eq2 X' f' g' i' R' T' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_u_r_r_e_5_eq2 X f g i R T c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_e_5_eq2 X' f' g' i' R' T' c' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_u_r_r_e_6_eq2 X f g i R T c.
  rewrite H1. symmetry.
  exact pack_b_b_u_r_r_e_6_eq2 X' f' g' i' R' T' c'.
Qed.

Theorem pack_b_b_u_r_r_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_b_b_u_r_r_e X f g i R T c = pack_b_b_u_r_r_e X f' g' i' R' T' c.
let X f f' g g' i i' R R' T T' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_r X T,c) = (X,encode_b X f',encode_b X g',encode_u X i',encode_r X R',encode_r X T',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_u_r_r_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> q (pack_b_b_u_r_r_e X f g i R T c)) -> q S.

Theorem pack_struct_b_b_u_r_r_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> struct_b_b_u_r_r_e (pack_b_b_u_r_r_e X f g i R T c).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let R T c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg i Hi R T c Hc.
Qed.

Theorem pack_struct_b_b_u_r_r_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_u_r_r_e (pack_b_b_u_r_r_e X f g i R T c) -> forall x y :e X, f x y :e X.
let X f g i R T c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_e X f g i R T c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_r_e X' f' g' i' R' T' c' = pack_b_b_u_r_r_e X f g i R T c.
  apply pack_b_b_u_r_r_e_inj X' X f' f g' g i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_r_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_u_r_r_e (pack_b_b_u_r_r_e X f g i R T c) -> forall x y :e X, g x y :e X.
let X f g i R T c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_e X f g i R T c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_r_e X' f' g' i' R' T' c' = pack_b_b_u_r_r_e X f g i R T c.
  apply pack_b_b_u_r_r_e_inj X' X f' f g' g i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_r_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_u_r_r_e (pack_b_b_u_r_r_e X f g i R T c) -> forall x :e X, i x :e X.
let X f g i R T c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_e X f g i R T c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_r_e X' f' g' i' R' T' c' = pack_b_b_u_r_r_e X f g i R T c.
  apply pack_b_b_u_r_r_e_inj X' X f' f g' g i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_r_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, struct_b_b_u_r_r_e (pack_b_b_u_r_r_e X f g i R T c) -> c :e X.
let X f g i R T c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_e X f g i R T c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_r_e X' f' g' i' R' T' c' = pack_b_b_u_r_r_e X f g i R T c.
  apply pack_b_b_u_r_r_e_inj X' X f' f g' g i' i R' R T' T c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HT'T Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_u_r_r_e_eta: forall S, struct_b_b_u_r_r_e S -> S = pack_b_b_u_r_r_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_r_r_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_r (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let R. let T. let c. assume _.
prove pack_b_b_u_r_r_e X f g i R T c = pack_b_b_u_r_r_e (pack_b_b_u_r_r_e X f g i R T c 0) (decode_b (pack_b_b_u_r_r_e X f g i R T c 1)) (decode_b (pack_b_b_u_r_r_e X f g i R T c 2)) (decode_u (pack_b_b_u_r_r_e X f g i R T c 3)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 4)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 5)) (pack_b_b_u_r_r_e X f g i R T c 6).
rewrite <- pack_b_b_u_r_r_e_0_eq2 X f g i R T c.
rewrite <- pack_b_b_u_r_r_e_6_eq2 X f g i R T c.
apply pack_b_b_u_r_r_e_ext.
- exact pack_b_b_u_r_r_e_1_eq2 X f g i R T c.
- exact pack_b_b_u_r_r_e_2_eq2 X f g i R T c.
- exact pack_b_b_u_r_r_e_3_eq2 X f g i R T c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_r_e_4_eq2 X f g i R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_r_e_5_eq2 X f g i R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_r_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_u_r_r_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' i' R' T' c = Phi X f g i R T c)
  ->
  unpack_b_b_u_r_r_e_i (pack_b_b_u_r_r_e X f g i R T c) Phi = Phi X f g i R T c.
let Phi X f g i R T c.
assume HPhi.
prove Phi (pack_b_b_u_r_r_e X f g i R T c 0) (decode_b (pack_b_b_u_r_r_e X f g i R T c 1)) (decode_b (pack_b_b_u_r_r_e X f g i R T c 2)) (decode_u (pack_b_b_u_r_r_e X f g i R T c 3)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 4)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 5)) (pack_b_b_u_r_r_e X f g i R T c 6) = Phi X f g i R T c.
rewrite <- pack_b_b_u_r_r_e_0_eq2 X f g i R T c.
prove Phi X (decode_b (pack_b_b_u_r_r_e X f g i R T c 1)) (decode_b (pack_b_b_u_r_r_e X f g i R T c 2)) (decode_u (pack_b_b_u_r_r_e X f g i R T c 3)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 4)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 5)) (pack_b_b_u_r_r_e X f g i R T c 6) = Phi X f g i R T c.
rewrite <- pack_b_b_u_r_r_e_6_eq2 X f g i R T c.
apply HPhi.
- exact pack_b_b_u_r_r_e_1_eq2 X f g i R T c.
- exact pack_b_b_u_r_r_e_2_eq2 X f g i R T c.
- exact pack_b_b_u_r_r_e_3_eq2 X f g i R T c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_r_e X f g i R T c 4) x y.
  rewrite <- pack_b_b_u_r_r_e_4_eq2 X f g i R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_u_r_r_e X f g i R T c 5) x y.
  rewrite <- pack_b_b_u_r_r_e_5_eq2 X f g i R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_r_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_r (S 5)) (S 6).

Theorem unpack_b_b_u_r_r_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' i' R' T' c = Phi X f g i R T c)
  ->
  unpack_b_b_u_r_r_e_o (pack_b_b_u_r_r_e X f g i R T c) Phi = Phi X f g i R T c.
let Phi X f g i R T c.
assume HPhi.
prove Phi (pack_b_b_u_r_r_e X f g i R T c 0) (decode_b (pack_b_b_u_r_r_e X f g i R T c 1)) (decode_b (pack_b_b_u_r_r_e X f g i R T c 2)) (decode_u (pack_b_b_u_r_r_e X f g i R T c 3)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 4)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 5)) (pack_b_b_u_r_r_e X f g i R T c 6) = Phi X f g i R T c.
rewrite <- pack_b_b_u_r_r_e_0_eq2 X f g i R T c.
prove Phi X (decode_b (pack_b_b_u_r_r_e X f g i R T c 1)) (decode_b (pack_b_b_u_r_r_e X f g i R T c 2)) (decode_u (pack_b_b_u_r_r_e X f g i R T c 3)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 4)) (decode_r (pack_b_b_u_r_r_e X f g i R T c 5)) (pack_b_b_u_r_r_e X f g i R T c 6) = Phi X f g i R T c.
rewrite <- pack_b_b_u_r_r_e_6_eq2 X f g i R T c.
apply HPhi.
- exact pack_b_b_u_r_r_e_1_eq2 X f g i R T c.
- exact pack_b_b_u_r_r_e_2_eq2 X f g i R T c.
- exact pack_b_b_u_r_r_e_3_eq2 X f g i R T c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_r_e X f g i R T c 4) x y.
  rewrite <- pack_b_b_u_r_r_e_4_eq2 X f g i R T c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_u_r_r_e X f g i R T c 5) x y.
  rewrite <- pack_b_b_u_r_r_e_5_eq2 X f g i R T c x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_u_r_p_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X f g i R P Q => (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q).

Theorem pack_b_b_u_r_p_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> X = S 0.
let S X f g i R P Q. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_r_p_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_b_b_u_r_p_p X f g i R P Q 0.
let X f g i R P Q. apply pack_b_b_u_r_p_p_0_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_p_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_u_r_p_p X f g i R P Q 1) x y.
let X f g i R P Q. apply pack_b_b_u_r_p_p_1_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_p_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_u_r_p_p X f g i R P Q 2) x y.
let X f g i R P Q. apply pack_b_b_u_r_p_p_2_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_r_p_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_b_b_u_r_p_p X f g i R P Q 3) x.
let X f g i R P Q. apply pack_b_b_u_r_p_p_3_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g i R P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_p_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_u_r_p_p X f g i R P Q 4) x y.
let X f g i R P Q. apply pack_b_b_u_r_p_p_4_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X f g i R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_r_p_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_b_b_u_r_p_p X f g i R P Q 5) x.
let X f g i R P Q. apply pack_b_b_u_r_p_p_5_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_u_r_p_p X f g i R P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X f g i R P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_u_r_p_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_b_b_u_r_p_p X f g i R P Q 6) x.
let X f g i R P Q. apply pack_b_b_u_r_p_p_6_eq (pack_b_b_u_r_p_p X f g i R P Q) X f g i R P Q. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_b_b_u_r_p_p X f g i R P Q = pack_b_b_u_r_p_p X' f' g' i' R' P' Q' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' f f' g g' i i' R R' P P' Q Q'. assume H1.
claim L0: X' = pack_b_b_u_r_p_p X f g i R P Q 0.
{ exact pack_b_b_u_r_p_p_0_eq (pack_b_b_u_r_p_p X f g i R P Q) X' f' g' i' R' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_r_p_p_0_eq2 X f g i R P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_r_p_p_1_eq2 X f g i R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_p_1_eq2 X' f' g' i' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_r_p_p_2_eq2 X f g i R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_p_2_eq2 X' f' g' i' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_r_p_p_3_eq2 X f g i R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_p_3_eq2 X' f' g' i' R' P' Q' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_r_p_p_4_eq2 X f g i R P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_p_4_eq2 X' f' g' i' R' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_r_p_p_5_eq2 X f g i R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_p_5_eq2 X' f' g' i' R' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_u_r_p_p_6_eq2 X f g i R P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_p_6_eq2 X' f' g' i' R' P' Q' x Lx.
Qed.

Theorem pack_b_b_u_r_p_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_u_r_p_p X f g i R P Q = pack_b_b_u_r_p_p X f' g' i' R' P' Q'.
let X f f' g g' i i' R R' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,encode_p X Q) = (X,encode_b X f',encode_b X g',encode_u X i',encode_r X R',encode_p X P',encode_p X Q').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_u_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_b_b_u_r_p_p X f g i R P Q)) -> q S.

Theorem pack_struct_b_b_u_r_p_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_r_p_p (pack_b_b_u_r_p_p X f g i R P Q).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let R P Q q. assume Hq.
exact Hq X f Hf g Hg i Hi R P Q.
Qed.

Theorem pack_struct_b_b_u_r_p_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_r_p_p (pack_b_b_u_r_p_p X f g i R P Q) -> forall x y :e X, f x y :e X.
let X f g i R P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_p X f g i R P Q -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let Q'.
  assume Heq: pack_b_b_u_r_p_p X' f' g' i' R' P' Q' = pack_b_b_u_r_p_p X f g i R P Q.
  apply pack_b_b_u_r_p_p_inj X' X f' f g' g i' i R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_p_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_r_p_p (pack_b_b_u_r_p_p X f g i R P Q) -> forall x y :e X, g x y :e X.
let X f g i R P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_p X f g i R P Q -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let Q'.
  assume Heq: pack_b_b_u_r_p_p X' f' g' i' R' P' Q' = pack_b_b_u_r_p_p X f g i R P Q.
  apply pack_b_b_u_r_p_p_inj X' X f' f g' g i' i R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_p_p_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_u_r_p_p (pack_b_b_u_r_p_p X f g i R P Q) -> forall x :e X, i x :e X.
let X f g i R P Q. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_p X f g i R P Q -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let Q'.
  assume Heq: pack_b_b_u_r_p_p X' f' g' i' R' P' Q' = pack_b_b_u_r_p_p X f g i R P Q.
  apply pack_b_b_u_r_p_p_inj X' X f' f g' g i' i R' R P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_b_b_u_r_p_p_eta: forall S, struct_b_b_u_r_p_p S -> S = pack_b_b_u_r_p_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let i. assume _. let R. let P. let Q.
prove pack_b_b_u_r_p_p X f g i R P Q = pack_b_b_u_r_p_p (pack_b_b_u_r_p_p X f g i R P Q 0) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 1)) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 2)) (decode_u (pack_b_b_u_r_p_p X f g i R P Q 3)) (decode_r (pack_b_b_u_r_p_p X f g i R P Q 4)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 5)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 6)).
rewrite <- pack_b_b_u_r_p_p_0_eq2 X f g i R P Q.
apply pack_b_b_u_r_p_p_ext.
- exact pack_b_b_u_r_p_p_1_eq2 X f g i R P Q.
- exact pack_b_b_u_r_p_p_2_eq2 X f g i R P Q.
- exact pack_b_b_u_r_p_p_3_eq2 X f g i R P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_p_p_4_eq2 X f g i R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_r_p_p_5_eq2 X f g i R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_r_p_p_6_eq2 X f g i R P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_p_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_r_p_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' i' R' P' Q' = Phi X f g i R P Q)
  ->
  unpack_b_b_u_r_p_p_i (pack_b_b_u_r_p_p X f g i R P Q) Phi = Phi X f g i R P Q.
let Phi X f g i R P Q.
assume HPhi.
prove Phi (pack_b_b_u_r_p_p X f g i R P Q 0) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 1)) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 2)) (decode_u (pack_b_b_u_r_p_p X f g i R P Q 3)) (decode_r (pack_b_b_u_r_p_p X f g i R P Q 4)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 5)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 6)) = Phi X f g i R P Q.
rewrite <- pack_b_b_u_r_p_p_0_eq2 X f g i R P Q.
prove Phi X (decode_b (pack_b_b_u_r_p_p X f g i R P Q 1)) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 2)) (decode_u (pack_b_b_u_r_p_p X f g i R P Q 3)) (decode_r (pack_b_b_u_r_p_p X f g i R P Q 4)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 5)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 6)) = Phi X f g i R P Q.
apply HPhi.
- exact pack_b_b_u_r_p_p_1_eq2 X f g i R P Q.
- exact pack_b_b_u_r_p_p_2_eq2 X f g i R P Q.
- exact pack_b_b_u_r_p_p_3_eq2 X f g i R P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_p_p X f g i R P Q 4) x y.
  rewrite <- pack_b_b_u_r_p_p_4_eq2 X f g i R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_r_p_p X f g i R P Q 5) x.
  rewrite <- pack_b_b_u_r_p_p_5_eq2 X f g i R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_u_r_p_p X f g i R P Q 6) x.
  rewrite <- pack_b_b_u_r_p_p_6_eq2 X f g i R P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_p_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_u_r_p_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' i' R' P' Q' = Phi X f g i R P Q)
  ->
  unpack_b_b_u_r_p_p_o (pack_b_b_u_r_p_p X f g i R P Q) Phi = Phi X f g i R P Q.
let Phi X f g i R P Q.
assume HPhi.
prove Phi (pack_b_b_u_r_p_p X f g i R P Q 0) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 1)) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 2)) (decode_u (pack_b_b_u_r_p_p X f g i R P Q 3)) (decode_r (pack_b_b_u_r_p_p X f g i R P Q 4)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 5)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 6)) = Phi X f g i R P Q.
rewrite <- pack_b_b_u_r_p_p_0_eq2 X f g i R P Q.
prove Phi X (decode_b (pack_b_b_u_r_p_p X f g i R P Q 1)) (decode_b (pack_b_b_u_r_p_p X f g i R P Q 2)) (decode_u (pack_b_b_u_r_p_p X f g i R P Q 3)) (decode_r (pack_b_b_u_r_p_p X f g i R P Q 4)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 5)) (decode_p (pack_b_b_u_r_p_p X f g i R P Q 6)) = Phi X f g i R P Q.
apply HPhi.
- exact pack_b_b_u_r_p_p_1_eq2 X f g i R P Q.
- exact pack_b_b_u_r_p_p_2_eq2 X f g i R P Q.
- exact pack_b_b_u_r_p_p_3_eq2 X f g i R P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_p_p X f g i R P Q 4) x y.
  rewrite <- pack_b_b_u_r_p_p_4_eq2 X f g i R P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_r_p_p X f g i R P Q 5) x.
  rewrite <- pack_b_b_u_r_p_p_5_eq2 X f g i R P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_u_r_p_p X f g i R P Q 6) x.
  rewrite <- pack_b_b_u_r_p_p_6_eq2 X f g i R P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_r_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X f g i R P c => (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c).

Theorem pack_b_b_u_r_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> X = S 0.
let S X f g i R P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_r_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_b_b_u_r_p_e X f g i R P c 0.
let X f g i R P c. apply pack_b_b_u_r_p_e_0_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_u_r_p_e X f g i R P c 1) x y.
let X f g i R P c. apply pack_b_b_u_r_p_e_1_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_u_r_p_e X f g i R P c 2) x y.
let X f g i R P c. apply pack_b_b_u_r_p_e_2_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i R P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_r_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_u_r_p_e X f g i R P c 3) x.
let X f g i R P c. apply pack_b_b_u_r_p_e_3_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g i R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_u_r_p_e X f g i R P c 4) x y.
let X f g i R P c. apply pack_b_b_u_r_p_e_4_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> forall x :e X, P x = decode_p (S 5) x.
let S X f g i R P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_r_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_u_r_p_e X f g i R P c 5) x.
let X f g i R P c. apply pack_b_b_u_r_p_e_5_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_u_r_p_e X f g i R P c -> c = S 6.
let S X f g i R P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_r_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_b_b_u_r_p_e X f g i R P c 6.
let X f g i R P c. apply pack_b_b_u_r_p_e_6_eq (pack_b_b_u_r_p_e X f g i R P c) X f g i R P c. reflexivity.
Qed.

Theorem pack_b_b_u_r_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_b_b_u_r_p_e X f g i R P c = pack_b_b_u_r_p_e X' f' g' i' R' P' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' f f' g g' i i' R R' P P' c c'. assume H1.
claim L0: X' = pack_b_b_u_r_p_e X f g i R P c 0.
{ exact pack_b_b_u_r_p_e_0_eq (pack_b_b_u_r_p_e X f g i R P c) X' f' g' i' R' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_r_p_e_0_eq2 X f g i R P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_r_p_e_1_eq2 X f g i R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_e_1_eq2 X' f' g' i' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_r_p_e_2_eq2 X f g i R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_e_2_eq2 X' f' g' i' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_r_p_e_3_eq2 X f g i R P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_e_3_eq2 X' f' g' i' R' P' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_r_p_e_4_eq2 X f g i R P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_e_4_eq2 X' f' g' i' R' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_r_p_e_5_eq2 X f g i R P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_e_5_eq2 X' f' g' i' R' P' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_u_r_p_e_6_eq2 X f g i R P c.
  rewrite H1. symmetry.
  exact pack_b_b_u_r_p_e_6_eq2 X' f' g' i' R' P' c'.
Qed.

Theorem pack_b_b_u_r_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_u_r_p_e X f g i R P c = pack_b_b_u_r_p_e X f' g' i' R' P' c.
let X f f' g g' i i' R R' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,encode_p X P,c) = (X,encode_b X f',encode_b X g',encode_u X i',encode_r X R',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_u_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_b_b_u_r_p_e X f g i R P c)) -> q S.

Theorem pack_struct_b_b_u_r_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_b_b_u_r_p_e (pack_b_b_u_r_p_e X f g i R P c).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let R P c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg i Hi R P c Hc.
Qed.

Theorem pack_struct_b_b_u_r_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_u_r_p_e (pack_b_b_u_r_p_e X f g i R P c) -> forall x y :e X, f x y :e X.
let X f g i R P c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_e X f g i R P c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_p_e X' f' g' i' R' P' c' = pack_b_b_u_r_p_e X f g i R P c.
  apply pack_b_b_u_r_p_e_inj X' X f' f g' g i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_u_r_p_e (pack_b_b_u_r_p_e X f g i R P c) -> forall x y :e X, g x y :e X.
let X f g i R P c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_e X f g i R P c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_p_e X' f' g' i' R' P' c' = pack_b_b_u_r_p_e X f g i R P c.
  apply pack_b_b_u_r_p_e_inj X' X f' f g' g i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_p_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_u_r_p_e (pack_b_b_u_r_p_e X f g i R P c) -> forall x :e X, i x :e X.
let X f g i R P c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_e X f g i R P c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_p_e X' f' g' i' R' P' c' = pack_b_b_u_r_p_e X f g i R P c.
  apply pack_b_b_u_r_p_e_inj X' X f' f g' g i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_u_r_p_e (pack_b_b_u_r_p_e X f g i R P c) -> c :e X.
let X f g i R P c. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_e X f g i R P c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_r_p_e X' f' g' i' R' P' c' = pack_b_b_u_r_p_e X f g i R P c.
  apply pack_b_b_u_r_p_e_inj X' X f' f g' g i' i R' R P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_u_r_p_e_eta: forall S, struct_b_b_u_r_p_e S -> S = pack_b_b_u_r_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_r_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let R. let P. let c. assume _.
prove pack_b_b_u_r_p_e X f g i R P c = pack_b_b_u_r_p_e (pack_b_b_u_r_p_e X f g i R P c 0) (decode_b (pack_b_b_u_r_p_e X f g i R P c 1)) (decode_b (pack_b_b_u_r_p_e X f g i R P c 2)) (decode_u (pack_b_b_u_r_p_e X f g i R P c 3)) (decode_r (pack_b_b_u_r_p_e X f g i R P c 4)) (decode_p (pack_b_b_u_r_p_e X f g i R P c 5)) (pack_b_b_u_r_p_e X f g i R P c 6).
rewrite <- pack_b_b_u_r_p_e_0_eq2 X f g i R P c.
rewrite <- pack_b_b_u_r_p_e_6_eq2 X f g i R P c.
apply pack_b_b_u_r_p_e_ext.
- exact pack_b_b_u_r_p_e_1_eq2 X f g i R P c.
- exact pack_b_b_u_r_p_e_2_eq2 X f g i R P c.
- exact pack_b_b_u_r_p_e_3_eq2 X f g i R P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_p_e_4_eq2 X f g i R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_r_p_e_5_eq2 X f g i R P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_u_r_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' R' P' c = Phi X f g i R P c)
  ->
  unpack_b_b_u_r_p_e_i (pack_b_b_u_r_p_e X f g i R P c) Phi = Phi X f g i R P c.
let Phi X f g i R P c.
assume HPhi.
prove Phi (pack_b_b_u_r_p_e X f g i R P c 0) (decode_b (pack_b_b_u_r_p_e X f g i R P c 1)) (decode_b (pack_b_b_u_r_p_e X f g i R P c 2)) (decode_u (pack_b_b_u_r_p_e X f g i R P c 3)) (decode_r (pack_b_b_u_r_p_e X f g i R P c 4)) (decode_p (pack_b_b_u_r_p_e X f g i R P c 5)) (pack_b_b_u_r_p_e X f g i R P c 6) = Phi X f g i R P c.
rewrite <- pack_b_b_u_r_p_e_0_eq2 X f g i R P c.
prove Phi X (decode_b (pack_b_b_u_r_p_e X f g i R P c 1)) (decode_b (pack_b_b_u_r_p_e X f g i R P c 2)) (decode_u (pack_b_b_u_r_p_e X f g i R P c 3)) (decode_r (pack_b_b_u_r_p_e X f g i R P c 4)) (decode_p (pack_b_b_u_r_p_e X f g i R P c 5)) (pack_b_b_u_r_p_e X f g i R P c 6) = Phi X f g i R P c.
rewrite <- pack_b_b_u_r_p_e_6_eq2 X f g i R P c.
apply HPhi.
- exact pack_b_b_u_r_p_e_1_eq2 X f g i R P c.
- exact pack_b_b_u_r_p_e_2_eq2 X f g i R P c.
- exact pack_b_b_u_r_p_e_3_eq2 X f g i R P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_p_e X f g i R P c 4) x y.
  rewrite <- pack_b_b_u_r_p_e_4_eq2 X f g i R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_r_p_e X f g i R P c 5) x.
  rewrite <- pack_b_b_u_r_p_e_5_eq2 X f g i R P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_u_r_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' R' P' c = Phi X f g i R P c)
  ->
  unpack_b_b_u_r_p_e_o (pack_b_b_u_r_p_e X f g i R P c) Phi = Phi X f g i R P c.
let Phi X f g i R P c.
assume HPhi.
prove Phi (pack_b_b_u_r_p_e X f g i R P c 0) (decode_b (pack_b_b_u_r_p_e X f g i R P c 1)) (decode_b (pack_b_b_u_r_p_e X f g i R P c 2)) (decode_u (pack_b_b_u_r_p_e X f g i R P c 3)) (decode_r (pack_b_b_u_r_p_e X f g i R P c 4)) (decode_p (pack_b_b_u_r_p_e X f g i R P c 5)) (pack_b_b_u_r_p_e X f g i R P c 6) = Phi X f g i R P c.
rewrite <- pack_b_b_u_r_p_e_0_eq2 X f g i R P c.
prove Phi X (decode_b (pack_b_b_u_r_p_e X f g i R P c 1)) (decode_b (pack_b_b_u_r_p_e X f g i R P c 2)) (decode_u (pack_b_b_u_r_p_e X f g i R P c 3)) (decode_r (pack_b_b_u_r_p_e X f g i R P c 4)) (decode_p (pack_b_b_u_r_p_e X f g i R P c 5)) (pack_b_b_u_r_p_e X f g i R P c 6) = Phi X f g i R P c.
rewrite <- pack_b_b_u_r_p_e_6_eq2 X f g i R P c.
apply HPhi.
- exact pack_b_b_u_r_p_e_1_eq2 X f g i R P c.
- exact pack_b_b_u_r_p_e_2_eq2 X f g i R P c.
- exact pack_b_b_u_r_p_e_3_eq2 X f g i R P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_p_e X f g i R P c 4) x y.
  rewrite <- pack_b_b_u_r_p_e_4_eq2 X f g i R P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_r_p_e X f g i R P c 5) x.
  rewrite <- pack_b_b_u_r_p_e_5_eq2 X f g i R P c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_r_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> set := fun X f g i R c d => (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d).

Theorem pack_b_b_u_r_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> X = S 0.
let S X f g i R c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_r_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, X = pack_b_b_u_r_e_e X f g i R c d 0.
let X f g i R c d. apply pack_b_b_u_r_e_e_0_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_u_r_e_e X f g i R c d 1) x y.
let X f g i R c d. apply pack_b_b_u_r_e_e_1_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_u_r_e_e X f g i R c d 2) x y.
let X f g i R c d. apply pack_b_b_u_r_e_e_2_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i R c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_r_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_b_u_r_e_e X f g i R c d 3) x.
let X f g i R c d. apply pack_b_b_u_r_e_e_3_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> forall x y :e X, R x y = decode_r (S 4) x y.
let S X f g i R c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_u_r_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_b_u_r_e_e X f g i R c d 4) x y.
let X f g i R c d. apply pack_b_b_u_r_e_e_4_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> c = S 5.
let S X f g i R c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_u_r_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, c = pack_b_b_u_r_e_e X f g i R c d 5.
let X f g i R c d. apply pack_b_b_u_r_e_e_5_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_u_r_e_e X f g i R c d -> d = S 6.
let S X f g i R c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_r_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, d = pack_b_b_u_r_e_e X f g i R c d 6.
let X f g i R c d. apply pack_b_b_u_r_e_e_6_eq (pack_b_b_u_r_e_e X f g i R c d) X f g i R c d. reflexivity.
Qed.

Theorem pack_b_b_u_r_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall c c':set, forall d d':set, pack_b_b_u_r_e_e X f g i R c d = pack_b_b_u_r_e_e X' f' g' i' R' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ c = c' /\ d = d'.
let X X' f f' g g' i i' R R' c c' d d'. assume H1.
claim L0: X' = pack_b_b_u_r_e_e X f g i R c d 0.
{ exact pack_b_b_u_r_e_e_0_eq (pack_b_b_u_r_e_e X f g i R c d) X' f' g' i' R' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_r_e_e_0_eq2 X f g i R c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_r_e_e_1_eq2 X f g i R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_e_e_1_eq2 X' f' g' i' R' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_r_e_e_2_eq2 X f g i R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_e_e_2_eq2 X' f' g' i' R' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_r_e_e_3_eq2 X f g i R c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_e_e_3_eq2 X' f' g' i' R' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_u_r_e_e_4_eq2 X f g i R c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_r_e_e_4_eq2 X' f' g' i' R' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_u_r_e_e_5_eq2 X f g i R c d.
  rewrite H1. symmetry.
  exact pack_b_b_u_r_e_e_5_eq2 X' f' g' i' R' c' d'.
- prove d = d'.
  rewrite pack_b_b_u_r_e_e_6_eq2 X f g i R c d.
  rewrite H1. symmetry.
  exact pack_b_b_u_r_e_e_6_eq2 X' f' g' i' R' c' d'.
Qed.

Theorem pack_b_b_u_r_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_b_u_r_e_e X f g i R c d = pack_b_b_u_r_e_e X f' g' i' R' c d.
let X f f' g g' i i' R R' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_r X R,c,d) = (X,encode_b X f',encode_b X g',encode_u X i',encode_r X R',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_u_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_u_r_e_e X f g i R c d)) -> q S.

Theorem pack_struct_b_b_u_r_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let R c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg i Hi R c Hc d Hd.
Qed.

Theorem pack_struct_b_b_u_r_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d) -> forall x y :e X, f x y :e X.
let X f g i R c d. assume H1. apply H1 (fun z => z = pack_b_b_u_r_e_e X f g i R c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_r_e_e X' f' g' i' R' c' d' = pack_b_b_u_r_e_e X f g i R c d.
  apply pack_b_b_u_r_e_e_inj X' X f' f g' g i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d) -> forall x y :e X, g x y :e X.
let X f g i R c d. assume H1. apply H1 (fun z => z = pack_b_b_u_r_e_e X f g i R c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_r_e_e X' f' g' i' R' c' d' = pack_b_b_u_r_e_e X f g i R c d.
  apply pack_b_b_u_r_e_e_inj X' X f' f g' g i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_e_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d) -> forall x :e X, i x :e X.
let X f g i R c d. assume H1. apply H1 (fun z => z = pack_b_b_u_r_e_e X f g i R c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_r_e_e X' f' g' i' R' c' d' = pack_b_b_u_r_e_e X f g i R c d.
  apply pack_b_b_u_r_e_e_inj X' X f' f g' g i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d) -> c :e X.
let X f g i R c d. assume H1. apply H1 (fun z => z = pack_b_b_u_r_e_e X f g i R c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_r_e_e X' f' g' i' R' c' d' = pack_b_b_u_r_e_e X f g i R c d.
  apply pack_b_b_u_r_e_e_inj X' X f' f g' g i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_r_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set, struct_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d) -> d :e X.
let X f g i R c d. assume H1. apply H1 (fun z => z = pack_b_b_u_r_e_e X f g i R c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let R'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_r_e_e X' f' g' i' R' c' d' = pack_b_b_u_r_e_e X f g i R c d.
  apply pack_b_b_u_r_e_e_inj X' X f' f g' g i' i R' R c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HR'R Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_u_r_e_e_eta: forall S, struct_b_b_u_r_e_e S -> S = pack_b_b_u_r_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_r_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let R. let c. assume _. let d. assume _.
prove pack_b_b_u_r_e_e X f g i R c d = pack_b_b_u_r_e_e (pack_b_b_u_r_e_e X f g i R c d 0) (decode_b (pack_b_b_u_r_e_e X f g i R c d 1)) (decode_b (pack_b_b_u_r_e_e X f g i R c d 2)) (decode_u (pack_b_b_u_r_e_e X f g i R c d 3)) (decode_r (pack_b_b_u_r_e_e X f g i R c d 4)) (pack_b_b_u_r_e_e X f g i R c d 5) (pack_b_b_u_r_e_e X f g i R c d 6).
rewrite <- pack_b_b_u_r_e_e_0_eq2 X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_5_eq2 X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_6_eq2 X f g i R c d.
apply pack_b_b_u_r_e_e_ext.
- exact pack_b_b_u_r_e_e_1_eq2 X f g i R c d.
- exact pack_b_b_u_r_e_e_2_eq2 X f g i R c d.
- exact pack_b_b_u_r_e_e_3_eq2 X f g i R c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_u_r_e_e_4_eq2 X f g i R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_b_u_r_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' i' R' c d = Phi X f g i R c d)
  ->
  unpack_b_b_u_r_e_e_i (pack_b_b_u_r_e_e X f g i R c d) Phi = Phi X f g i R c d.
let Phi X f g i R c d.
assume HPhi.
prove Phi (pack_b_b_u_r_e_e X f g i R c d 0) (decode_b (pack_b_b_u_r_e_e X f g i R c d 1)) (decode_b (pack_b_b_u_r_e_e X f g i R c d 2)) (decode_u (pack_b_b_u_r_e_e X f g i R c d 3)) (decode_r (pack_b_b_u_r_e_e X f g i R c d 4)) (pack_b_b_u_r_e_e X f g i R c d 5) (pack_b_b_u_r_e_e X f g i R c d 6) = Phi X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_0_eq2 X f g i R c d.
prove Phi X (decode_b (pack_b_b_u_r_e_e X f g i R c d 1)) (decode_b (pack_b_b_u_r_e_e X f g i R c d 2)) (decode_u (pack_b_b_u_r_e_e X f g i R c d 3)) (decode_r (pack_b_b_u_r_e_e X f g i R c d 4)) (pack_b_b_u_r_e_e X f g i R c d 5) (pack_b_b_u_r_e_e X f g i R c d 6) = Phi X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_5_eq2 X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_6_eq2 X f g i R c d.
apply HPhi.
- exact pack_b_b_u_r_e_e_1_eq2 X f g i R c d.
- exact pack_b_b_u_r_e_e_2_eq2 X f g i R c d.
- exact pack_b_b_u_r_e_e_3_eq2 X f g i R c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_e_e X f g i R c d 4) x y.
  rewrite <- pack_b_b_u_r_e_e_4_eq2 X f g i R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_r_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_b_u_r_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f' g' i' R' c d = Phi X f g i R c d)
  ->
  unpack_b_b_u_r_e_e_o (pack_b_b_u_r_e_e X f g i R c d) Phi = Phi X f g i R c d.
let Phi X f g i R c d.
assume HPhi.
prove Phi (pack_b_b_u_r_e_e X f g i R c d 0) (decode_b (pack_b_b_u_r_e_e X f g i R c d 1)) (decode_b (pack_b_b_u_r_e_e X f g i R c d 2)) (decode_u (pack_b_b_u_r_e_e X f g i R c d 3)) (decode_r (pack_b_b_u_r_e_e X f g i R c d 4)) (pack_b_b_u_r_e_e X f g i R c d 5) (pack_b_b_u_r_e_e X f g i R c d 6) = Phi X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_0_eq2 X f g i R c d.
prove Phi X (decode_b (pack_b_b_u_r_e_e X f g i R c d 1)) (decode_b (pack_b_b_u_r_e_e X f g i R c d 2)) (decode_u (pack_b_b_u_r_e_e X f g i R c d 3)) (decode_r (pack_b_b_u_r_e_e X f g i R c d 4)) (pack_b_b_u_r_e_e X f g i R c d 5) (pack_b_b_u_r_e_e X f g i R c d 6) = Phi X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_5_eq2 X f g i R c d.
rewrite <- pack_b_b_u_r_e_e_6_eq2 X f g i R c d.
apply HPhi.
- exact pack_b_b_u_r_e_e_1_eq2 X f g i R c d.
- exact pack_b_b_u_r_e_e_2_eq2 X f g i R c d.
- exact pack_b_b_u_r_e_e_3_eq2 X f g i R c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_u_r_e_e X f g i R c d 4) x y.
  rewrite <- pack_b_b_u_r_e_e_4_eq2 X f g i R c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_u_p_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set := fun X f g i P Q c => (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c).

Theorem pack_b_b_u_p_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> X = S 0.
let S X f g i P Q c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_p_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_b_b_u_p_p_e X f g i P Q c 0.
let X f g i P Q c. apply pack_b_b_u_p_p_e_0_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_p_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_u_p_p_e X f g i P Q c 1) x y.
let X f g i P Q c. apply pack_b_b_u_p_p_e_1_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_p_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_u_p_p_e X f g i P Q c 2) x y.
let X f g i P Q c. apply pack_b_b_u_p_p_e_2_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_p_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_b_u_p_p_e X f g i P Q c 3) x.
let X f g i P Q c. apply pack_b_b_u_p_p_e_3_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X f g i P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_p_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_u_p_p_e X f g i P Q c 4) x.
let X f g i P Q c. apply pack_b_b_u_p_p_e_4_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X f g i P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_u_p_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_b_b_u_p_p_e X f g i P Q c 5) x.
let X f g i P Q c. apply pack_b_b_u_p_p_e_5_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_u_p_p_e X f g i P Q c -> c = S 6.
let S X f g i P Q c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_p_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_b_b_u_p_p_e X f g i P Q c 6.
let X f g i P Q c. apply pack_b_b_u_p_p_e_6_eq (pack_b_b_u_p_p_e X f g i P Q c) X f g i P Q c. reflexivity.
Qed.

Theorem pack_b_b_u_p_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_b_b_u_p_p_e X f g i P Q c = pack_b_b_u_p_p_e X' f' g' i' P' Q' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' f f' g g' i i' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_b_b_u_p_p_e X f g i P Q c 0.
{ exact pack_b_b_u_p_p_e_0_eq (pack_b_b_u_p_p_e X f g i P Q c) X' f' g' i' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_p_p_e_0_eq2 X f g i P Q c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_p_p_e_1_eq2 X f g i P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_p_e_1_eq2 X' f' g' i' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_p_p_e_2_eq2 X f g i P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_p_e_2_eq2 X' f' g' i' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_p_p_e_3_eq2 X f g i P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_p_e_3_eq2 X' f' g' i' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_p_p_e_4_eq2 X f g i P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_p_e_4_eq2 X' f' g' i' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_u_p_p_e_5_eq2 X f g i P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_p_e_5_eq2 X' f' g' i' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_u_p_p_e_6_eq2 X f g i P Q c.
  rewrite H1. symmetry.
  exact pack_b_b_u_p_p_e_6_eq2 X' f' g' i' P' Q' c'.
Qed.

Theorem pack_b_b_u_p_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_u_p_p_e X f g i P Q c = pack_b_b_u_p_p_e X f' g' i' P' Q' c.
let X f f' g g' i i' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,encode_p X Q,c) = (X,encode_b X f',encode_b X g',encode_u X i',encode_p X P',encode_p X Q',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_u_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_b_b_u_p_p_e X f g i P Q c)) -> q S.

Theorem pack_struct_b_b_u_p_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_b_b_u_p_p_e (pack_b_b_u_p_p_e X f g i P Q c).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let P Q c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg i Hi P Q c Hc.
Qed.

Theorem pack_struct_b_b_u_p_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_u_p_p_e (pack_b_b_u_p_p_e X f g i P Q c) -> forall x y :e X, f x y :e X.
let X f g i P Q c. assume H1. apply H1 (fun z => z = pack_b_b_u_p_p_e X f g i P Q c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_p_p_e X' f' g' i' P' Q' c' = pack_b_b_u_p_p_e X f g i P Q c.
  apply pack_b_b_u_p_p_e_inj X' X f' f g' g i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_u_p_p_e (pack_b_b_u_p_p_e X f g i P Q c) -> forall x y :e X, g x y :e X.
let X f g i P Q c. assume H1. apply H1 (fun z => z = pack_b_b_u_p_p_e X f g i P Q c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_p_p_e X' f' g' i' P' Q' c' = pack_b_b_u_p_p_e X f g i P Q c.
  apply pack_b_b_u_p_p_e_inj X' X f' f g' g i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_p_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_u_p_p_e (pack_b_b_u_p_p_e X f g i P Q c) -> forall x :e X, i x :e X.
let X f g i P Q c. assume H1. apply H1 (fun z => z = pack_b_b_u_p_p_e X f g i P Q c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_p_p_e X' f' g' i' P' Q' c' = pack_b_b_u_p_p_e X f g i P Q c.
  apply pack_b_b_u_p_p_e_inj X' X f' f g' g i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_u_p_p_e (pack_b_b_u_p_p_e X f g i P Q c) -> c :e X.
let X f g i P Q c. assume H1. apply H1 (fun z => z = pack_b_b_u_p_p_e X f g i P Q c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_u_p_p_e X' f' g' i' P' Q' c' = pack_b_b_u_p_p_e X f g i P Q c.
  apply pack_b_b_u_p_p_e_inj X' X f' f g' g i' i P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_u_p_p_e_eta: forall S, struct_b_b_u_p_p_e S -> S = pack_b_b_u_p_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_p_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let P. let Q. let c. assume _.
prove pack_b_b_u_p_p_e X f g i P Q c = pack_b_b_u_p_p_e (pack_b_b_u_p_p_e X f g i P Q c 0) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 1)) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 2)) (decode_u (pack_b_b_u_p_p_e X f g i P Q c 3)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 4)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 5)) (pack_b_b_u_p_p_e X f g i P Q c 6).
rewrite <- pack_b_b_u_p_p_e_0_eq2 X f g i P Q c.
rewrite <- pack_b_b_u_p_p_e_6_eq2 X f g i P Q c.
apply pack_b_b_u_p_p_e_ext.
- exact pack_b_b_u_p_p_e_1_eq2 X f g i P Q c.
- exact pack_b_b_u_p_p_e_2_eq2 X f g i P Q c.
- exact pack_b_b_u_p_p_e_3_eq2 X f g i P Q c.
- let x. assume Hx.
  rewrite <- pack_b_b_u_p_p_e_4_eq2 X f g i P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_u_p_p_e_5_eq2 X f g i P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_p_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_u_p_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' i' P' Q' c = Phi X f g i P Q c)
  ->
  unpack_b_b_u_p_p_e_i (pack_b_b_u_p_p_e X f g i P Q c) Phi = Phi X f g i P Q c.
let Phi X f g i P Q c.
assume HPhi.
prove Phi (pack_b_b_u_p_p_e X f g i P Q c 0) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 1)) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 2)) (decode_u (pack_b_b_u_p_p_e X f g i P Q c 3)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 4)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 5)) (pack_b_b_u_p_p_e X f g i P Q c 6) = Phi X f g i P Q c.
rewrite <- pack_b_b_u_p_p_e_0_eq2 X f g i P Q c.
prove Phi X (decode_b (pack_b_b_u_p_p_e X f g i P Q c 1)) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 2)) (decode_u (pack_b_b_u_p_p_e X f g i P Q c 3)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 4)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 5)) (pack_b_b_u_p_p_e X f g i P Q c 6) = Phi X f g i P Q c.
rewrite <- pack_b_b_u_p_p_e_6_eq2 X f g i P Q c.
apply HPhi.
- exact pack_b_b_u_p_p_e_1_eq2 X f g i P Q c.
- exact pack_b_b_u_p_p_e_2_eq2 X f g i P Q c.
- exact pack_b_b_u_p_p_e_3_eq2 X f g i P Q c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_p_p_e X f g i P Q c 4) x.
  rewrite <- pack_b_b_u_p_p_e_4_eq2 X f g i P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_u_p_p_e X f g i P Q c 5) x.
  rewrite <- pack_b_b_u_p_p_e_5_eq2 X f g i P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_p_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_u_p_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' i' P' Q' c = Phi X f g i P Q c)
  ->
  unpack_b_b_u_p_p_e_o (pack_b_b_u_p_p_e X f g i P Q c) Phi = Phi X f g i P Q c.
let Phi X f g i P Q c.
assume HPhi.
prove Phi (pack_b_b_u_p_p_e X f g i P Q c 0) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 1)) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 2)) (decode_u (pack_b_b_u_p_p_e X f g i P Q c 3)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 4)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 5)) (pack_b_b_u_p_p_e X f g i P Q c 6) = Phi X f g i P Q c.
rewrite <- pack_b_b_u_p_p_e_0_eq2 X f g i P Q c.
prove Phi X (decode_b (pack_b_b_u_p_p_e X f g i P Q c 1)) (decode_b (pack_b_b_u_p_p_e X f g i P Q c 2)) (decode_u (pack_b_b_u_p_p_e X f g i P Q c 3)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 4)) (decode_p (pack_b_b_u_p_p_e X f g i P Q c 5)) (pack_b_b_u_p_p_e X f g i P Q c 6) = Phi X f g i P Q c.
rewrite <- pack_b_b_u_p_p_e_6_eq2 X f g i P Q c.
apply HPhi.
- exact pack_b_b_u_p_p_e_1_eq2 X f g i P Q c.
- exact pack_b_b_u_p_p_e_2_eq2 X f g i P Q c.
- exact pack_b_b_u_p_p_e_3_eq2 X f g i P Q c.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_p_p_e X f g i P Q c 4) x.
  rewrite <- pack_b_b_u_p_p_e_4_eq2 X f g i P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_u_p_p_e X f g i P Q c 5) x.
  rewrite <- pack_b_b_u_p_p_e_5_eq2 X f g i P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_u_p_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> set := fun X f g i P c d => (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d).

Theorem pack_b_b_u_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> X = S 0.
let S X f g i P c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_u_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, X = pack_b_b_u_p_e_e X f g i P c d 0.
let X f g i P c d. apply pack_b_b_u_p_e_e_0_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_u_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_u_p_e_e X f g i P c d 1) x y.
let X f g i P c d. apply pack_b_b_u_p_e_e_1_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_u_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_u_p_e_e X f g i P c d 2) x y.
let X f g i P c d. apply pack_b_b_u_p_e_e_2_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i P c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_b_u_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_b_u_p_e_e X f g i P c d 3) x.
let X f g i P c d. apply pack_b_b_u_p_e_e_3_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X f g i P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_u_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_b_u_p_e_e X f g i P c d 4) x.
let X f g i P c d. apply pack_b_b_u_p_e_e_4_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> c = S 5.
let S X f g i P c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_u_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, c = pack_b_b_u_p_e_e X f g i P c d 5.
let X f g i P c d. apply pack_b_b_u_p_e_e_5_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_u_p_e_e X f g i P c d -> d = S 6.
let S X f g i P c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_u_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, d = pack_b_b_u_p_e_e X f g i P c d 6.
let X f g i P c d. apply pack_b_b_u_p_e_e_6_eq (pack_b_b_u_p_e_e X f g i P c d) X f g i P c d. reflexivity.
Qed.

Theorem pack_b_b_u_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall c c':set, forall d d':set, pack_b_b_u_p_e_e X f g i P c d = pack_b_b_u_p_e_e X' f' g' i' P' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' f f' g g' i i' P P' c c' d d'. assume H1.
claim L0: X' = pack_b_b_u_p_e_e X f g i P c d 0.
{ exact pack_b_b_u_p_e_e_0_eq (pack_b_b_u_p_e_e X f g i P c d) X' f' g' i' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_u_p_e_e_0_eq2 X f g i P c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_u_p_e_e_1_eq2 X f g i P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_e_e_1_eq2 X' f' g' i' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_u_p_e_e_2_eq2 X f g i P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_e_e_2_eq2 X' f' g' i' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_b_u_p_e_e_3_eq2 X f g i P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_e_e_3_eq2 X' f' g' i' P' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_u_p_e_e_4_eq2 X f g i P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_u_p_e_e_4_eq2 X' f' g' i' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_b_u_p_e_e_5_eq2 X f g i P c d.
  rewrite H1. symmetry.
  exact pack_b_b_u_p_e_e_5_eq2 X' f' g' i' P' c' d'.
- prove d = d'.
  rewrite pack_b_b_u_p_e_e_6_eq2 X f g i P c d.
  rewrite H1. symmetry.
  exact pack_b_b_u_p_e_e_6_eq2 X' f' g' i' P' c' d'.
Qed.

Theorem pack_b_b_u_p_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_u_p_e_e X f g i P c d = pack_b_b_u_p_e_e X f' g' i' P' c d.
let X f f' g g' i i' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_u X i,encode_p X P,c,d) = (X,encode_b X f',encode_b X g',encode_u X i',encode_p X P',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_u_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_u_p_e_e X f g i P c d)) -> q S.

Theorem pack_struct_b_b_u_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d).
let X f. assume Hf. let g. assume Hg. let i. assume Hi. let P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg i Hi P c Hc d Hd.
Qed.

Theorem pack_struct_b_b_u_p_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d) -> forall x y :e X, f x y :e X.
let X f g i P c d. assume H1. apply H1 (fun z => z = pack_b_b_u_p_e_e X f g i P c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_p_e_e X' f' g' i' P' c' d' = pack_b_b_u_p_e_e X f g i P c d.
  apply pack_b_b_u_p_e_e_inj X' X f' f g' g i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d) -> forall x y :e X, g x y :e X.
let X f g i P c d. assume H1. apply H1 (fun z => z = pack_b_b_u_p_e_e X f g i P c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_p_e_e X' f' g' i' P' c' d' = pack_b_b_u_p_e_e X f g i P c d.
  apply pack_b_b_u_p_e_e_inj X' X f' f g' g i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_e_e_E3: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d) -> forall x :e X, i x :e X.
let X f g i P c d. assume H1. apply H1 (fun z => z = pack_b_b_u_p_e_e X f g i P c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_p_e_e X' f' g' i' P' c' d' = pack_b_b_u_p_e_e X f g i P c d.
  apply pack_b_b_u_p_e_e_inj X' X f' f g' g i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d) -> c :e X.
let X f g i P c d. assume H1. apply H1 (fun z => z = pack_b_b_u_p_e_e X f g i P c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_p_e_e X' f' g' i' P' c' d' = pack_b_b_u_p_e_e X f g i P c d.
  apply pack_b_b_u_p_e_e_inj X' X f' f g' g i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_u_p_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d) -> d :e X.
let X f g i P c d. assume H1. apply H1 (fun z => z = pack_b_b_u_p_e_e X f g i P c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let i'. assume Hi'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_u_p_e_e X' f' g' i' P' c' d' = pack_b_b_u_p_e_e X f g i P c d.
  apply pack_b_b_u_p_e_e_inj X' X f' f g' g i' i P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g Hi'i HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_u_p_e_e_eta: forall S, struct_b_b_u_p_e_e S -> S = pack_b_b_u_p_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_u_p_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_u (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let i. assume _. let P. let c. assume _. let d. assume _.
prove pack_b_b_u_p_e_e X f g i P c d = pack_b_b_u_p_e_e (pack_b_b_u_p_e_e X f g i P c d 0) (decode_b (pack_b_b_u_p_e_e X f g i P c d 1)) (decode_b (pack_b_b_u_p_e_e X f g i P c d 2)) (decode_u (pack_b_b_u_p_e_e X f g i P c d 3)) (decode_p (pack_b_b_u_p_e_e X f g i P c d 4)) (pack_b_b_u_p_e_e X f g i P c d 5) (pack_b_b_u_p_e_e X f g i P c d 6).
rewrite <- pack_b_b_u_p_e_e_0_eq2 X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_5_eq2 X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_6_eq2 X f g i P c d.
apply pack_b_b_u_p_e_e_ext.
- exact pack_b_b_u_p_e_e_1_eq2 X f g i P c d.
- exact pack_b_b_u_p_e_e_2_eq2 X f g i P c d.
- exact pack_b_b_u_p_e_e_3_eq2 X f g i P c d.
- let x. assume Hx.
  rewrite <- pack_b_b_u_p_e_e_4_eq2 X f g i P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_u_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' P' c d = Phi X f g i P c d)
  ->
  unpack_b_b_u_p_e_e_i (pack_b_b_u_p_e_e X f g i P c d) Phi = Phi X f g i P c d.
let Phi X f g i P c d.
assume HPhi.
prove Phi (pack_b_b_u_p_e_e X f g i P c d 0) (decode_b (pack_b_b_u_p_e_e X f g i P c d 1)) (decode_b (pack_b_b_u_p_e_e X f g i P c d 2)) (decode_u (pack_b_b_u_p_e_e X f g i P c d 3)) (decode_p (pack_b_b_u_p_e_e X f g i P c d 4)) (pack_b_b_u_p_e_e X f g i P c d 5) (pack_b_b_u_p_e_e X f g i P c d 6) = Phi X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_0_eq2 X f g i P c d.
prove Phi X (decode_b (pack_b_b_u_p_e_e X f g i P c d 1)) (decode_b (pack_b_b_u_p_e_e X f g i P c d 2)) (decode_u (pack_b_b_u_p_e_e X f g i P c d 3)) (decode_p (pack_b_b_u_p_e_e X f g i P c d 4)) (pack_b_b_u_p_e_e X f g i P c d 5) (pack_b_b_u_p_e_e X f g i P c d 6) = Phi X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_5_eq2 X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_6_eq2 X f g i P c d.
apply HPhi.
- exact pack_b_b_u_p_e_e_1_eq2 X f g i P c d.
- exact pack_b_b_u_p_e_e_2_eq2 X f g i P c d.
- exact pack_b_b_u_p_e_e_3_eq2 X f g i P c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_p_e_e X f g i P c d 4) x.
  rewrite <- pack_b_b_u_p_e_e_4_eq2 X f g i P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_u_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_u_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' i' P' c d = Phi X f g i P c d)
  ->
  unpack_b_b_u_p_e_e_o (pack_b_b_u_p_e_e X f g i P c d) Phi = Phi X f g i P c d.
let Phi X f g i P c d.
assume HPhi.
prove Phi (pack_b_b_u_p_e_e X f g i P c d 0) (decode_b (pack_b_b_u_p_e_e X f g i P c d 1)) (decode_b (pack_b_b_u_p_e_e X f g i P c d 2)) (decode_u (pack_b_b_u_p_e_e X f g i P c d 3)) (decode_p (pack_b_b_u_p_e_e X f g i P c d 4)) (pack_b_b_u_p_e_e X f g i P c d 5) (pack_b_b_u_p_e_e X f g i P c d 6) = Phi X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_0_eq2 X f g i P c d.
prove Phi X (decode_b (pack_b_b_u_p_e_e X f g i P c d 1)) (decode_b (pack_b_b_u_p_e_e X f g i P c d 2)) (decode_u (pack_b_b_u_p_e_e X f g i P c d 3)) (decode_p (pack_b_b_u_p_e_e X f g i P c d 4)) (pack_b_b_u_p_e_e X f g i P c d 5) (pack_b_b_u_p_e_e X f g i P c d 6) = Phi X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_5_eq2 X f g i P c d.
rewrite <- pack_b_b_u_p_e_e_6_eq2 X f g i P c d.
apply HPhi.
- exact pack_b_b_u_p_e_e_1_eq2 X f g i P c d.
- exact pack_b_b_u_p_e_e_2_eq2 X f g i P c d.
- exact pack_b_b_u_p_e_e_3_eq2 X f g i P c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_u_p_e_e X f g i P c d 4) x.
  rewrite <- pack_b_b_u_p_e_e_4_eq2 X f g i P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_r_r_p_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X f g R T P Q => (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q).

Theorem pack_b_b_r_r_p_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> X = S 0.
let S X f g R T P Q. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_r_r_p_p_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_b_b_r_r_p_p X f g R T P Q 0.
let X f g R T P Q. apply pack_b_b_r_r_p_p_0_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_p_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_b_b_r_r_p_p X f g R T P Q 1) x y.
let X f g R T P Q. apply pack_b_b_r_r_p_p_1_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_p_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, g x y = decode_b (pack_b_b_r_r_p_p X f g R T P Q 2) x y.
let X f g R T P Q. apply pack_b_b_r_r_p_p_2_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f g R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_p_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_b_b_r_r_p_p X f g R T P Q 3) x y.
let X f g R T P Q. apply pack_b_b_r_r_p_p_3_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X f g R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_p_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, T x y = decode_r (pack_b_b_r_r_p_p X f g R T P Q 4) x y.
let X f g R T P Q. apply pack_b_b_r_r_p_p_4_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X f g R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_r_r_p_p_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_b_b_r_r_p_p X f g R T P Q 5) x.
let X f g R T P Q. apply pack_b_b_r_r_p_p_5_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_b_r_r_p_p X f g R T P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X f g R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_r_r_p_p_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_b_b_r_r_p_p X f g R T P Q 6) x.
let X f g R T P Q. apply pack_b_b_r_r_p_p_6_eq (pack_b_b_r_r_p_p X f g R T P Q) X f g R T P Q. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_p_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_b_b_r_r_p_p X f g R T P Q = pack_b_b_r_r_p_p X' f' g' R' T' P' Q' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' f f' g g' R R' T T' P P' Q Q'. assume H1.
claim L0: X' = pack_b_b_r_r_p_p X f g R T P Q 0.
{ exact pack_b_b_r_r_p_p_0_eq (pack_b_b_r_r_p_p X f g R T P Q) X' f' g' R' T' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_r_r_p_p_0_eq2 X f g R T P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_r_r_p_p_1_eq2 X f g R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_p_1_eq2 X' f' g' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_r_r_p_p_2_eq2 X f g R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_p_2_eq2 X' f' g' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_r_r_p_p_3_eq2 X f g R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_p_3_eq2 X' f' g' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_r_r_p_p_4_eq2 X f g R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_p_4_eq2 X' f' g' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_r_r_p_p_5_eq2 X f g R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_p_5_eq2 X' f' g' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_r_r_p_p_6_eq2 X f g R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_p_6_eq2 X' f' g' R' T' P' Q' x Lx.
Qed.

Theorem pack_b_b_r_r_p_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_r_r_p_p X f g R T P Q = pack_b_b_r_r_p_p X f' g' R' T' P' Q'.
let X f f' g g' R R' T T' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) = (X,encode_b X f',encode_b X g',encode_r X R',encode_r X T',encode_p X P',encode_p X Q').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_b_r_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_b_b_r_r_p_p X f g R T P Q)) -> q S.

Theorem pack_struct_b_b_r_r_p_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_r_r_p_p (pack_b_b_r_r_p_p X f g R T P Q).
let X f. assume Hf. let g. assume Hg. let R T P Q q. assume Hq.
exact Hq X f Hf g Hg R T P Q.
Qed.

Theorem pack_struct_b_b_r_r_p_p_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_r_r_p_p (pack_b_b_r_r_p_p X f g R T P Q) -> forall x y :e X, f x y :e X.
let X f g R T P Q. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_p X f g R T P Q -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_b_b_r_r_p_p X' f' g' R' T' P' Q' = pack_b_b_r_r_p_p X f g R T P Q.
  apply pack_b_b_r_r_p_p_inj X' X f' f g' g R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_r_p_p_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_b_r_r_p_p (pack_b_b_r_r_p_p X f g R T P Q) -> forall x y :e X, g x y :e X.
let X f g R T P Q. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_p X f g R T P Q -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_b_b_r_r_p_p X' f' g' R' T' P' Q' = pack_b_b_r_r_p_p X f g R T P Q.
  apply pack_b_b_r_r_p_p_inj X' X f' f g' g R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem struct_b_b_r_r_p_p_eta: forall S, struct_b_b_r_r_p_p S -> S = pack_b_b_r_r_p_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_p (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let f. assume _. let g. assume _. let R. let T. let P. let Q.
prove pack_b_b_r_r_p_p X f g R T P Q = pack_b_b_r_r_p_p (pack_b_b_r_r_p_p X f g R T P Q 0) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 1)) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 2)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 3)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 4)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 5)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 6)).
rewrite <- pack_b_b_r_r_p_p_0_eq2 X f g R T P Q.
apply pack_b_b_r_r_p_p_ext.
- exact pack_b_b_r_r_p_p_1_eq2 X f g R T P Q.
- exact pack_b_b_r_r_p_p_2_eq2 X f g R T P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_r_p_p_3_eq2 X f g R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_r_p_p_4_eq2 X f g R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_r_r_p_p_5_eq2 X f g R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_r_r_p_p_6_eq2 X f g R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_r_p_p_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_r_r_p_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' R' T' P' Q' = Phi X f g R T P Q)
  ->
  unpack_b_b_r_r_p_p_i (pack_b_b_r_r_p_p X f g R T P Q) Phi = Phi X f g R T P Q.
let Phi X f g R T P Q.
assume HPhi.
prove Phi (pack_b_b_r_r_p_p X f g R T P Q 0) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 1)) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 2)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 3)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 4)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 5)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 6)) = Phi X f g R T P Q.
rewrite <- pack_b_b_r_r_p_p_0_eq2 X f g R T P Q.
prove Phi X (decode_b (pack_b_b_r_r_p_p X f g R T P Q 1)) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 2)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 3)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 4)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 5)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 6)) = Phi X f g R T P Q.
apply HPhi.
- exact pack_b_b_r_r_p_p_1_eq2 X f g R T P Q.
- exact pack_b_b_r_r_p_p_2_eq2 X f g R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_r_p_p X f g R T P Q 3) x y.
  rewrite <- pack_b_b_r_r_p_p_3_eq2 X f g R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_r_r_p_p X f g R T P Q 4) x y.
  rewrite <- pack_b_b_r_r_p_p_4_eq2 X f g R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_r_p_p X f g R T P Q 5) x.
  rewrite <- pack_b_b_r_r_p_p_5_eq2 X f g R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_r_r_p_p X f g R T P Q 6) x.
  rewrite <- pack_b_b_r_r_p_p_6_eq2 X f g R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_r_p_p_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_b_r_r_p_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' R' T' P' Q' = Phi X f g R T P Q)
  ->
  unpack_b_b_r_r_p_p_o (pack_b_b_r_r_p_p X f g R T P Q) Phi = Phi X f g R T P Q.
let Phi X f g R T P Q.
assume HPhi.
prove Phi (pack_b_b_r_r_p_p X f g R T P Q 0) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 1)) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 2)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 3)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 4)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 5)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 6)) = Phi X f g R T P Q.
rewrite <- pack_b_b_r_r_p_p_0_eq2 X f g R T P Q.
prove Phi X (decode_b (pack_b_b_r_r_p_p X f g R T P Q 1)) (decode_b (pack_b_b_r_r_p_p X f g R T P Q 2)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 3)) (decode_r (pack_b_b_r_r_p_p X f g R T P Q 4)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 5)) (decode_p (pack_b_b_r_r_p_p X f g R T P Q 6)) = Phi X f g R T P Q.
apply HPhi.
- exact pack_b_b_r_r_p_p_1_eq2 X f g R T P Q.
- exact pack_b_b_r_r_p_p_2_eq2 X f g R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_r_p_p X f g R T P Q 3) x y.
  rewrite <- pack_b_b_r_r_p_p_3_eq2 X f g R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_r_r_p_p X f g R T P Q 4) x y.
  rewrite <- pack_b_b_r_r_p_p_4_eq2 X f g R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_r_p_p X f g R T P Q 5) x.
  rewrite <- pack_b_b_r_r_p_p_5_eq2 X f g R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_r_r_p_p X f g R T P Q 6) x.
  rewrite <- pack_b_b_r_r_p_p_6_eq2 X f g R T P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_r_r_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X f g R T P c => (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c).

Theorem pack_b_b_r_r_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> X = S 0.
let S X f g R T P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_r_r_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_b_b_r_r_p_e X f g R T P c 0.
let X f g R T P c. apply pack_b_b_r_r_p_e_0_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_r_r_p_e X f g R T P c 1) x y.
let X f g R T P c. apply pack_b_b_r_r_p_e_1_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_r_r_p_e X f g R T P c 2) x y.
let X f g R T P c. apply pack_b_b_r_r_p_e_2_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f g R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_r_r_p_e X f g R T P c 3) x y.
let X f g R T P c. apply pack_b_b_r_r_p_e_3_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X f g R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_b_b_r_r_p_e X f g R T P c 4) x y.
let X f g R T P c. apply pack_b_b_r_r_p_e_4_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> forall x :e X, P x = decode_p (S 5) x.
let S X f g R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_r_r_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_r_r_p_e X f g R T P c 5) x.
let X f g R T P c. apply pack_b_b_r_r_p_e_5_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_b_r_r_p_e X f g R T P c -> c = S 6.
let S X f g R T P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_r_r_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_b_b_r_r_p_e X f g R T P c 6.
let X f g R T P c. apply pack_b_b_r_r_p_e_6_eq (pack_b_b_r_r_p_e X f g R T P c) X f g R T P c. reflexivity.
Qed.

Theorem pack_b_b_r_r_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_b_b_r_r_p_e X f g R T P c = pack_b_b_r_r_p_e X' f' g' R' T' P' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' f f' g g' R R' T T' P P' c c'. assume H1.
claim L0: X' = pack_b_b_r_r_p_e X f g R T P c 0.
{ exact pack_b_b_r_r_p_e_0_eq (pack_b_b_r_r_p_e X f g R T P c) X' f' g' R' T' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_r_r_p_e_0_eq2 X f g R T P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_r_r_p_e_1_eq2 X f g R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_e_1_eq2 X' f' g' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_r_r_p_e_2_eq2 X f g R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_e_2_eq2 X' f' g' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_r_r_p_e_3_eq2 X f g R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_e_3_eq2 X' f' g' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_r_r_p_e_4_eq2 X f g R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_e_4_eq2 X' f' g' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_r_r_p_e_5_eq2 X f g R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_e_5_eq2 X' f' g' R' T' P' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_r_r_p_e_6_eq2 X f g R T P c.
  rewrite H1. symmetry.
  exact pack_b_b_r_r_p_e_6_eq2 X' f' g' R' T' P' c'.
Qed.

Theorem pack_b_b_r_r_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_r_r_p_e X f g R T P c = pack_b_b_r_r_p_e X f' g' R' T' P' c.
let X f f' g g' R R' T T' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,encode_p X P,c) = (X,encode_b X f',encode_b X g',encode_r X R',encode_r X T',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_r_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_b_b_r_r_p_e X f g R T P c)) -> q S.

Theorem pack_struct_b_b_r_r_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_b_b_r_r_p_e (pack_b_b_r_r_p_e X f g R T P c).
let X f. assume Hf. let g. assume Hg. let R T P c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg R T P c Hc.
Qed.

Theorem pack_struct_b_b_r_r_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_r_r_p_e (pack_b_b_r_r_p_e X f g R T P c) -> forall x y :e X, f x y :e X.
let X f g R T P c. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_e X f g R T P c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_r_r_p_e X' f' g' R' T' P' c' = pack_b_b_r_r_p_e X f g R T P c.
  apply pack_b_b_r_r_p_e_inj X' X f' f g' g R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_r_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_r_r_p_e (pack_b_b_r_r_p_e X f g R T P c) -> forall x y :e X, g x y :e X.
let X f g R T P c. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_e X f g R T P c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_r_r_p_e X' f' g' R' T' P' c' = pack_b_b_r_r_p_e X f g R T P c.
  apply pack_b_b_r_r_p_e_inj X' X f' f g' g R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_r_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_b_r_r_p_e (pack_b_b_r_r_p_e X f g R T P c) -> c :e X.
let X f g R T P c. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_e X f g R T P c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_b_r_r_p_e X' f' g' R' T' P' c' = pack_b_b_r_r_p_e X f g R T P c.
  apply pack_b_b_r_r_p_e_inj X' X f' f g' g R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_r_r_p_e_eta: forall S, struct_b_b_r_r_p_e S -> S = pack_b_b_r_r_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_r_r_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let R. let T. let P. let c. assume _.
prove pack_b_b_r_r_p_e X f g R T P c = pack_b_b_r_r_p_e (pack_b_b_r_r_p_e X f g R T P c 0) (decode_b (pack_b_b_r_r_p_e X f g R T P c 1)) (decode_b (pack_b_b_r_r_p_e X f g R T P c 2)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 3)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 4)) (decode_p (pack_b_b_r_r_p_e X f g R T P c 5)) (pack_b_b_r_r_p_e X f g R T P c 6).
rewrite <- pack_b_b_r_r_p_e_0_eq2 X f g R T P c.
rewrite <- pack_b_b_r_r_p_e_6_eq2 X f g R T P c.
apply pack_b_b_r_r_p_e_ext.
- exact pack_b_b_r_r_p_e_1_eq2 X f g R T P c.
- exact pack_b_b_r_r_p_e_2_eq2 X f g R T P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_r_p_e_3_eq2 X f g R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_r_p_e_4_eq2 X f g R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_r_r_p_e_5_eq2 X f g R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_r_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_r_r_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' R' T' P' c = Phi X f g R T P c)
  ->
  unpack_b_b_r_r_p_e_i (pack_b_b_r_r_p_e X f g R T P c) Phi = Phi X f g R T P c.
let Phi X f g R T P c.
assume HPhi.
prove Phi (pack_b_b_r_r_p_e X f g R T P c 0) (decode_b (pack_b_b_r_r_p_e X f g R T P c 1)) (decode_b (pack_b_b_r_r_p_e X f g R T P c 2)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 3)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 4)) (decode_p (pack_b_b_r_r_p_e X f g R T P c 5)) (pack_b_b_r_r_p_e X f g R T P c 6) = Phi X f g R T P c.
rewrite <- pack_b_b_r_r_p_e_0_eq2 X f g R T P c.
prove Phi X (decode_b (pack_b_b_r_r_p_e X f g R T P c 1)) (decode_b (pack_b_b_r_r_p_e X f g R T P c 2)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 3)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 4)) (decode_p (pack_b_b_r_r_p_e X f g R T P c 5)) (pack_b_b_r_r_p_e X f g R T P c 6) = Phi X f g R T P c.
rewrite <- pack_b_b_r_r_p_e_6_eq2 X f g R T P c.
apply HPhi.
- exact pack_b_b_r_r_p_e_1_eq2 X f g R T P c.
- exact pack_b_b_r_r_p_e_2_eq2 X f g R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_r_p_e X f g R T P c 3) x y.
  rewrite <- pack_b_b_r_r_p_e_3_eq2 X f g R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_r_r_p_e X f g R T P c 4) x y.
  rewrite <- pack_b_b_r_r_p_e_4_eq2 X f g R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_r_p_e X f g R T P c 5) x.
  rewrite <- pack_b_b_r_r_p_e_5_eq2 X f g R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_r_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_r_r_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' R' T' P' c = Phi X f g R T P c)
  ->
  unpack_b_b_r_r_p_e_o (pack_b_b_r_r_p_e X f g R T P c) Phi = Phi X f g R T P c.
let Phi X f g R T P c.
assume HPhi.
prove Phi (pack_b_b_r_r_p_e X f g R T P c 0) (decode_b (pack_b_b_r_r_p_e X f g R T P c 1)) (decode_b (pack_b_b_r_r_p_e X f g R T P c 2)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 3)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 4)) (decode_p (pack_b_b_r_r_p_e X f g R T P c 5)) (pack_b_b_r_r_p_e X f g R T P c 6) = Phi X f g R T P c.
rewrite <- pack_b_b_r_r_p_e_0_eq2 X f g R T P c.
prove Phi X (decode_b (pack_b_b_r_r_p_e X f g R T P c 1)) (decode_b (pack_b_b_r_r_p_e X f g R T P c 2)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 3)) (decode_r (pack_b_b_r_r_p_e X f g R T P c 4)) (decode_p (pack_b_b_r_r_p_e X f g R T P c 5)) (pack_b_b_r_r_p_e X f g R T P c 6) = Phi X f g R T P c.
rewrite <- pack_b_b_r_r_p_e_6_eq2 X f g R T P c.
apply HPhi.
- exact pack_b_b_r_r_p_e_1_eq2 X f g R T P c.
- exact pack_b_b_r_r_p_e_2_eq2 X f g R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_r_p_e X f g R T P c 3) x y.
  rewrite <- pack_b_b_r_r_p_e_3_eq2 X f g R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_r_r_p_e X f g R T P c 4) x y.
  rewrite <- pack_b_b_r_r_p_e_4_eq2 X f g R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_r_p_e X f g R T P c 5) x.
  rewrite <- pack_b_b_r_r_p_e_5_eq2 X f g R T P c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_r_r_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set := fun X f g R T c d => (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d).

Theorem pack_b_b_r_r_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> X = S 0.
let S X f g R T c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_r_r_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, X = pack_b_b_r_r_e_e X f g R T c d 0.
let X f g R T c d. apply pack_b_b_r_r_e_e_0_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_r_r_e_e X f g R T c d 1) x y.
let X f g R T c d. apply pack_b_b_r_r_e_e_1_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_r_r_e_e X f g R T c d 2) x y.
let X f g R T c d. apply pack_b_b_r_r_e_e_2_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f g R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_b_r_r_e_e X f g R T c d 3) x y.
let X f g R T c d. apply pack_b_b_r_r_e_e_3_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X f g R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_b_r_r_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, T x y = decode_r (pack_b_b_r_r_e_e X f g R T c d 4) x y.
let X f g R T c d. apply pack_b_b_r_r_e_e_4_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> c = S 5.
let S X f g R T c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_r_r_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, c = pack_b_b_r_r_e_e X f g R T c d 5.
let X f g R T c d. apply pack_b_b_r_r_e_e_5_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_b_r_r_e_e X f g R T c d -> d = S 6.
let S X f g R T c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_r_r_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, d = pack_b_b_r_r_e_e X f g R T c d 6.
let X f g R T c d. apply pack_b_b_r_r_e_e_6_eq (pack_b_b_r_r_e_e X f g R T c d) X f g R T c d. reflexivity.
Qed.

Theorem pack_b_b_r_r_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, forall d d':set, pack_b_b_r_r_e_e X f g R T c d = pack_b_b_r_r_e_e X' f' g' R' T' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c' /\ d = d'.
let X X' f f' g g' R R' T T' c c' d d'. assume H1.
claim L0: X' = pack_b_b_r_r_e_e X f g R T c d 0.
{ exact pack_b_b_r_r_e_e_0_eq (pack_b_b_r_r_e_e X f g R T c d) X' f' g' R' T' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_r_r_e_e_0_eq2 X f g R T c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_r_r_e_e_1_eq2 X f g R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_e_e_1_eq2 X' f' g' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_r_r_e_e_2_eq2 X f g R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_e_e_2_eq2 X' f' g' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_r_r_e_e_3_eq2 X f g R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_e_e_3_eq2 X' f' g' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_b_r_r_e_e_4_eq2 X f g R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_r_e_e_4_eq2 X' f' g' R' T' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_b_r_r_e_e_5_eq2 X f g R T c d.
  rewrite H1. symmetry.
  exact pack_b_b_r_r_e_e_5_eq2 X' f' g' R' T' c' d'.
- prove d = d'.
  rewrite pack_b_b_r_r_e_e_6_eq2 X f g R T c d.
  rewrite H1. symmetry.
  exact pack_b_b_r_r_e_e_6_eq2 X' f' g' R' T' c' d'.
Qed.

Theorem pack_b_b_r_r_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_b_b_r_r_e_e X f g R T c d = pack_b_b_r_r_e_e X f' g' R' T' c d.
let X f f' g g' R R' T T' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_r X R,encode_r X T,c,d) = (X,encode_b X f',encode_b X g',encode_r X R',encode_r X T',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_r_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_r_r_e_e X f g R T c d)) -> q S.

Theorem pack_struct_b_b_r_r_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_r_r_e_e (pack_b_b_r_r_e_e X f g R T c d).
let X f. assume Hf. let g. assume Hg. let R T c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg R T c Hc d Hd.
Qed.

Theorem pack_struct_b_b_r_r_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_b_r_r_e_e (pack_b_b_r_r_e_e X f g R T c d) -> forall x y :e X, f x y :e X.
let X f g R T c d. assume H1. apply H1 (fun z => z = pack_b_b_r_r_e_e X f g R T c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_r_e_e X' f' g' R' T' c' d' = pack_b_b_r_r_e_e X f g R T c d.
  apply pack_b_b_r_r_e_e_inj X' X f' f g' g R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_r_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_b_r_r_e_e (pack_b_b_r_r_e_e X f g R T c d) -> forall x y :e X, g x y :e X.
let X f g R T c d. assume H1. apply H1 (fun z => z = pack_b_b_r_r_e_e X f g R T c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_r_e_e X' f' g' R' T' c' d' = pack_b_b_r_r_e_e X f g R T c d.
  apply pack_b_b_r_r_e_e_inj X' X f' f g' g R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_r_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_b_r_r_e_e (pack_b_b_r_r_e_e X f g R T c d) -> c :e X.
let X f g R T c d. assume H1. apply H1 (fun z => z = pack_b_b_r_r_e_e X f g R T c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_r_e_e X' f' g' R' T' c' d' = pack_b_b_r_r_e_e X f g R T c d.
  apply pack_b_b_r_r_e_e_inj X' X f' f g' g R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_r_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_b_r_r_e_e (pack_b_b_r_r_e_e X f g R T c d) -> d :e X.
let X f g R T c d. assume H1. apply H1 (fun z => z = pack_b_b_r_r_e_e X f g R T c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_r_e_e X' f' g' R' T' c' d' = pack_b_b_r_r_e_e X f g R T c d.
  apply pack_b_b_r_r_e_e_inj X' X f' f g' g R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_r_r_e_e_eta: forall S, struct_b_b_r_r_e_e S -> S = pack_b_b_r_r_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_r_r_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let R. let T. let c. assume _. let d. assume _.
prove pack_b_b_r_r_e_e X f g R T c d = pack_b_b_r_r_e_e (pack_b_b_r_r_e_e X f g R T c d 0) (decode_b (pack_b_b_r_r_e_e X f g R T c d 1)) (decode_b (pack_b_b_r_r_e_e X f g R T c d 2)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 3)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 4)) (pack_b_b_r_r_e_e X f g R T c d 5) (pack_b_b_r_r_e_e X f g R T c d 6).
rewrite <- pack_b_b_r_r_e_e_0_eq2 X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_5_eq2 X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_6_eq2 X f g R T c d.
apply pack_b_b_r_r_e_e_ext.
- exact pack_b_b_r_r_e_e_1_eq2 X f g R T c d.
- exact pack_b_b_r_r_e_e_2_eq2 X f g R T c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_r_e_e_3_eq2 X f g R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_r_e_e_4_eq2 X f g R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_r_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_b_r_r_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' R' T' c d = Phi X f g R T c d)
  ->
  unpack_b_b_r_r_e_e_i (pack_b_b_r_r_e_e X f g R T c d) Phi = Phi X f g R T c d.
let Phi X f g R T c d.
assume HPhi.
prove Phi (pack_b_b_r_r_e_e X f g R T c d 0) (decode_b (pack_b_b_r_r_e_e X f g R T c d 1)) (decode_b (pack_b_b_r_r_e_e X f g R T c d 2)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 3)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 4)) (pack_b_b_r_r_e_e X f g R T c d 5) (pack_b_b_r_r_e_e X f g R T c d 6) = Phi X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_0_eq2 X f g R T c d.
prove Phi X (decode_b (pack_b_b_r_r_e_e X f g R T c d 1)) (decode_b (pack_b_b_r_r_e_e X f g R T c d 2)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 3)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 4)) (pack_b_b_r_r_e_e X f g R T c d 5) (pack_b_b_r_r_e_e X f g R T c d 6) = Phi X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_5_eq2 X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_6_eq2 X f g R T c d.
apply HPhi.
- exact pack_b_b_r_r_e_e_1_eq2 X f g R T c d.
- exact pack_b_b_r_r_e_e_2_eq2 X f g R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_r_e_e X f g R T c d 3) x y.
  rewrite <- pack_b_b_r_r_e_e_3_eq2 X f g R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_r_r_e_e X f g R T c d 4) x y.
  rewrite <- pack_b_b_r_r_e_e_4_eq2 X f g R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_r_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_b_r_r_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' g' R' T' c d = Phi X f g R T c d)
  ->
  unpack_b_b_r_r_e_e_o (pack_b_b_r_r_e_e X f g R T c d) Phi = Phi X f g R T c d.
let Phi X f g R T c d.
assume HPhi.
prove Phi (pack_b_b_r_r_e_e X f g R T c d 0) (decode_b (pack_b_b_r_r_e_e X f g R T c d 1)) (decode_b (pack_b_b_r_r_e_e X f g R T c d 2)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 3)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 4)) (pack_b_b_r_r_e_e X f g R T c d 5) (pack_b_b_r_r_e_e X f g R T c d 6) = Phi X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_0_eq2 X f g R T c d.
prove Phi X (decode_b (pack_b_b_r_r_e_e X f g R T c d 1)) (decode_b (pack_b_b_r_r_e_e X f g R T c d 2)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 3)) (decode_r (pack_b_b_r_r_e_e X f g R T c d 4)) (pack_b_b_r_r_e_e X f g R T c d 5) (pack_b_b_r_r_e_e X f g R T c d 6) = Phi X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_5_eq2 X f g R T c d.
rewrite <- pack_b_b_r_r_e_e_6_eq2 X f g R T c d.
apply HPhi.
- exact pack_b_b_r_r_e_e_1_eq2 X f g R T c d.
- exact pack_b_b_r_r_e_e_2_eq2 X f g R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_r_e_e X f g R T c d 3) x y.
  rewrite <- pack_b_b_r_r_e_e_3_eq2 X f g R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_b_r_r_e_e X f g R T c d 4) x y.
  rewrite <- pack_b_b_r_r_e_e_4_eq2 X f g R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_b_r_p_p_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set := fun X f g R P Q c => (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c).

Theorem pack_b_b_r_p_p_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> X = S 0.
let S X f g R P Q c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_r_p_p_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_b_b_r_p_p_e X f g R P Q c 0.
let X f g R P Q c. apply pack_b_b_r_p_p_e_0_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_r_p_p_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_b_r_p_p_e X f g R P Q c 1) x y.
let X f g R P Q c. apply pack_b_b_r_p_p_e_1_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_r_p_p_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, g x y = decode_b (pack_b_b_r_p_p_e X f g R P Q c 2) x y.
let X f g R P Q c. apply pack_b_b_r_p_p_e_2_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f g R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_r_p_p_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_b_r_p_p_e X f g R P Q c 3) x y.
let X f g R P Q c. apply pack_b_b_r_p_p_e_3_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X f g R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_r_p_p_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_b_r_p_p_e X f g R P Q c 4) x.
let X f g R P Q c. apply pack_b_b_r_p_p_e_4_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X f g R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_r_p_p_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_b_b_r_p_p_e X f g R P Q c 5) x.
let X f g R P Q c. apply pack_b_b_r_p_p_e_5_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_b_r_p_p_e X f g R P Q c -> c = S 6.
let S X f g R P Q c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_r_p_p_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_b_b_r_p_p_e X f g R P Q c 6.
let X f g R P Q c. apply pack_b_b_r_p_p_e_6_eq (pack_b_b_r_p_p_e X f g R P Q c) X f g R P Q c. reflexivity.
Qed.

Theorem pack_b_b_r_p_p_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_b_b_r_p_p_e X f g R P Q c = pack_b_b_r_p_p_e X' f' g' R' P' Q' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' f f' g g' R R' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_b_b_r_p_p_e X f g R P Q c 0.
{ exact pack_b_b_r_p_p_e_0_eq (pack_b_b_r_p_p_e X f g R P Q c) X' f' g' R' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_r_p_p_e_0_eq2 X f g R P Q c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_r_p_p_e_1_eq2 X f g R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_p_e_1_eq2 X' f' g' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_r_p_p_e_2_eq2 X f g R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_p_e_2_eq2 X' f' g' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_r_p_p_e_3_eq2 X f g R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_p_e_3_eq2 X' f' g' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_r_p_p_e_4_eq2 X f g R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_p_e_4_eq2 X' f' g' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_r_p_p_e_5_eq2 X f g R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_p_e_5_eq2 X' f' g' R' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_b_b_r_p_p_e_6_eq2 X f g R P Q c.
  rewrite H1. symmetry.
  exact pack_b_b_r_p_p_e_6_eq2 X' f' g' R' P' Q' c'.
Qed.

Theorem pack_b_b_r_p_p_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_r_p_p_e X f g R P Q c = pack_b_b_r_p_p_e X f' g' R' P' Q' c.
let X f f' g g' R R' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,encode_p X Q,c) = (X,encode_b X f',encode_b X g',encode_r X R',encode_p X P',encode_p X Q',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_b_r_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_b_b_r_p_p_e X f g R P Q c)) -> q S.

Theorem pack_struct_b_b_r_p_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_b_b_r_p_p_e (pack_b_b_r_p_p_e X f g R P Q c).
let X f. assume Hf. let g. assume Hg. let R P Q c. assume Hc. let q. assume Hq.
exact Hq X f Hf g Hg R P Q c Hc.
Qed.

Theorem pack_struct_b_b_r_p_p_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_r_p_p_e (pack_b_b_r_p_p_e X f g R P Q c) -> forall x y :e X, f x y :e X.
let X f g R P Q c. assume H1. apply H1 (fun z => z = pack_b_b_r_p_p_e X f g R P Q c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_r_p_p_e X' f' g' R' P' Q' c' = pack_b_b_r_p_p_e X f g R P Q c.
  apply pack_b_b_r_p_p_e_inj X' X f' f g' g R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_p_p_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_r_p_p_e (pack_b_b_r_p_p_e X f g R P Q c) -> forall x y :e X, g x y :e X.
let X f g R P Q c. assume H1. apply H1 (fun z => z = pack_b_b_r_p_p_e X f g R P Q c -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_r_p_p_e X' f' g' R' P' Q' c' = pack_b_b_r_p_p_e X f g R P Q c.
  apply pack_b_b_r_p_p_e_inj X' X f' f g' g R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_p_p_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_b_r_p_p_e (pack_b_b_r_p_p_e X f g R P Q c) -> c :e X.
let X f g R P Q c. assume H1. apply H1 (fun z => z = pack_b_b_r_p_p_e X f g R P Q c -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_b_r_p_p_e X' f' g' R' P' Q' c' = pack_b_b_r_p_p_e X f g R P Q c.
  apply pack_b_b_r_p_p_e_inj X' X f' f g' g R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_b_r_p_p_e_eta: forall S, struct_b_b_r_p_p_e S -> S = pack_b_b_r_p_p_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_r_p_p_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let g. assume _. let R. let P. let Q. let c. assume _.
prove pack_b_b_r_p_p_e X f g R P Q c = pack_b_b_r_p_p_e (pack_b_b_r_p_p_e X f g R P Q c 0) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 1)) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 2)) (decode_r (pack_b_b_r_p_p_e X f g R P Q c 3)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 4)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 5)) (pack_b_b_r_p_p_e X f g R P Q c 6).
rewrite <- pack_b_b_r_p_p_e_0_eq2 X f g R P Q c.
rewrite <- pack_b_b_r_p_p_e_6_eq2 X f g R P Q c.
apply pack_b_b_r_p_p_e_ext.
- exact pack_b_b_r_p_p_e_1_eq2 X f g R P Q c.
- exact pack_b_b_r_p_p_e_2_eq2 X f g R P Q c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_p_p_e_3_eq2 X f g R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_r_p_p_e_4_eq2 X f g R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_r_p_p_e_5_eq2 X f g R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_p_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_r_p_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' R' P' Q' c = Phi X f g R P Q c)
  ->
  unpack_b_b_r_p_p_e_i (pack_b_b_r_p_p_e X f g R P Q c) Phi = Phi X f g R P Q c.
let Phi X f g R P Q c.
assume HPhi.
prove Phi (pack_b_b_r_p_p_e X f g R P Q c 0) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 1)) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 2)) (decode_r (pack_b_b_r_p_p_e X f g R P Q c 3)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 4)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 5)) (pack_b_b_r_p_p_e X f g R P Q c 6) = Phi X f g R P Q c.
rewrite <- pack_b_b_r_p_p_e_0_eq2 X f g R P Q c.
prove Phi X (decode_b (pack_b_b_r_p_p_e X f g R P Q c 1)) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 2)) (decode_r (pack_b_b_r_p_p_e X f g R P Q c 3)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 4)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 5)) (pack_b_b_r_p_p_e X f g R P Q c 6) = Phi X f g R P Q c.
rewrite <- pack_b_b_r_p_p_e_6_eq2 X f g R P Q c.
apply HPhi.
- exact pack_b_b_r_p_p_e_1_eq2 X f g R P Q c.
- exact pack_b_b_r_p_p_e_2_eq2 X f g R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_p_p_e X f g R P Q c 3) x y.
  rewrite <- pack_b_b_r_p_p_e_3_eq2 X f g R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_p_p_e X f g R P Q c 4) x.
  rewrite <- pack_b_b_r_p_p_e_4_eq2 X f g R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_r_p_p_e X f g R P Q c 5) x.
  rewrite <- pack_b_b_r_p_p_e_5_eq2 X f g R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_p_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_b_r_p_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' R' P' Q' c = Phi X f g R P Q c)
  ->
  unpack_b_b_r_p_p_e_o (pack_b_b_r_p_p_e X f g R P Q c) Phi = Phi X f g R P Q c.
let Phi X f g R P Q c.
assume HPhi.
prove Phi (pack_b_b_r_p_p_e X f g R P Q c 0) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 1)) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 2)) (decode_r (pack_b_b_r_p_p_e X f g R P Q c 3)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 4)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 5)) (pack_b_b_r_p_p_e X f g R P Q c 6) = Phi X f g R P Q c.
rewrite <- pack_b_b_r_p_p_e_0_eq2 X f g R P Q c.
prove Phi X (decode_b (pack_b_b_r_p_p_e X f g R P Q c 1)) (decode_b (pack_b_b_r_p_p_e X f g R P Q c 2)) (decode_r (pack_b_b_r_p_p_e X f g R P Q c 3)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 4)) (decode_p (pack_b_b_r_p_p_e X f g R P Q c 5)) (pack_b_b_r_p_p_e X f g R P Q c 6) = Phi X f g R P Q c.
rewrite <- pack_b_b_r_p_p_e_6_eq2 X f g R P Q c.
apply HPhi.
- exact pack_b_b_r_p_p_e_1_eq2 X f g R P Q c.
- exact pack_b_b_r_p_p_e_2_eq2 X f g R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_p_p_e X f g R P Q c 3) x y.
  rewrite <- pack_b_b_r_p_p_e_3_eq2 X f g R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_p_p_e X f g R P Q c 4) x.
  rewrite <- pack_b_b_r_p_p_e_4_eq2 X f g R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_r_p_p_e X f g R P Q c 5) x.
  rewrite <- pack_b_b_r_p_p_e_5_eq2 X f g R P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_r_p_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set := fun X f g R P c d => (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d).

Theorem pack_b_b_r_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> X = S 0.
let S X f g R P c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_r_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, X = pack_b_b_r_p_e_e X f g R P c d 0.
let X f g R P c d. apply pack_b_b_r_p_e_e_0_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_r_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_r_p_e_e X f g R P c d 1) x y.
let X f g R P c d. apply pack_b_b_r_p_e_e_1_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_r_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_r_p_e_e X f g R P c d 2) x y.
let X f g R P c d. apply pack_b_b_r_p_e_e_2_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f g R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_b_r_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_b_r_p_e_e X f g R P c d 3) x y.
let X f g R P c d. apply pack_b_b_r_p_e_e_3_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X f g R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_r_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_b_r_p_e_e X f g R P c d 4) x.
let X f g R P c d. apply pack_b_b_r_p_e_e_4_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> c = S 5.
let S X f g R P c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_r_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, c = pack_b_b_r_p_e_e X f g R P c d 5.
let X f g R P c d. apply pack_b_b_r_p_e_e_5_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_b_r_p_e_e X f g R P c d -> d = S 6.
let S X f g R P c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_r_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, d = pack_b_b_r_p_e_e X f g R P c d 6.
let X f g R P c d. apply pack_b_b_r_p_e_e_6_eq (pack_b_b_r_p_e_e X f g R P c d) X f g R P c d. reflexivity.
Qed.

Theorem pack_b_b_r_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, forall d d':set, pack_b_b_r_p_e_e X f g R P c d = pack_b_b_r_p_e_e X' f' g' R' P' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' f f' g g' R R' P P' c c' d d'. assume H1.
claim L0: X' = pack_b_b_r_p_e_e X f g R P c d 0.
{ exact pack_b_b_r_p_e_e_0_eq (pack_b_b_r_p_e_e X f g R P c d) X' f' g' R' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_r_p_e_e_0_eq2 X f g R P c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_r_p_e_e_1_eq2 X f g R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_e_e_1_eq2 X' f' g' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_r_p_e_e_2_eq2 X f g R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_e_e_2_eq2 X' f' g' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_b_r_p_e_e_3_eq2 X f g R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_e_e_3_eq2 X' f' g' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_r_p_e_e_4_eq2 X f g R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_r_p_e_e_4_eq2 X' f' g' R' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_b_r_p_e_e_5_eq2 X f g R P c d.
  rewrite H1. symmetry.
  exact pack_b_b_r_p_e_e_5_eq2 X' f' g' R' P' c' d'.
- prove d = d'.
  rewrite pack_b_b_r_p_e_e_6_eq2 X f g R P c d.
  rewrite H1. symmetry.
  exact pack_b_b_r_p_e_e_6_eq2 X' f' g' R' P' c' d'.
Qed.

Theorem pack_b_b_r_p_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_r_p_e_e X f g R P c d = pack_b_b_r_p_e_e X f' g' R' P' c d.
let X f f' g g' R R' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_r X R,encode_p X P,c,d) = (X,encode_b X f',encode_b X g',encode_r X R',encode_p X P',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_r_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_r_p_e_e X f g R P c d)) -> q S.

Theorem pack_struct_b_b_r_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_r_p_e_e (pack_b_b_r_p_e_e X f g R P c d).
let X f. assume Hf. let g. assume Hg. let R P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg R P c Hc d Hd.
Qed.

Theorem pack_struct_b_b_r_p_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_r_p_e_e (pack_b_b_r_p_e_e X f g R P c d) -> forall x y :e X, f x y :e X.
let X f g R P c d. assume H1. apply H1 (fun z => z = pack_b_b_r_p_e_e X f g R P c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_p_e_e X' f' g' R' P' c' d' = pack_b_b_r_p_e_e X f g R P c d.
  apply pack_b_b_r_p_e_e_inj X' X f' f g' g R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_p_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_r_p_e_e (pack_b_b_r_p_e_e X f g R P c d) -> forall x y :e X, g x y :e X.
let X f g R P c d. assume H1. apply H1 (fun z => z = pack_b_b_r_p_e_e X f g R P c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_p_e_e X' f' g' R' P' c' d' = pack_b_b_r_p_e_e X f g R P c d.
  apply pack_b_b_r_p_e_e_inj X' X f' f g' g R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_p_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_r_p_e_e (pack_b_b_r_p_e_e X f g R P c d) -> c :e X.
let X f g R P c d. assume H1. apply H1 (fun z => z = pack_b_b_r_p_e_e X f g R P c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_p_e_e X' f' g' R' P' c' d' = pack_b_b_r_p_e_e X f g R P c d.
  apply pack_b_b_r_p_e_e_inj X' X f' f g' g R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_r_p_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_b_r_p_e_e (pack_b_b_r_p_e_e X f g R P c d) -> d :e X.
let X f g R P c d. assume H1. apply H1 (fun z => z = pack_b_b_r_p_e_e X f g R P c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_r_p_e_e X' f' g' R' P' c' d' = pack_b_b_r_p_e_e X f g R P c d.
  apply pack_b_b_r_p_e_e_inj X' X f' f g' g R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_r_p_e_e_eta: forall S, struct_b_b_r_p_e_e S -> S = pack_b_b_r_p_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_r_p_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_r (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let R. let P. let c. assume _. let d. assume _.
prove pack_b_b_r_p_e_e X f g R P c d = pack_b_b_r_p_e_e (pack_b_b_r_p_e_e X f g R P c d 0) (decode_b (pack_b_b_r_p_e_e X f g R P c d 1)) (decode_b (pack_b_b_r_p_e_e X f g R P c d 2)) (decode_r (pack_b_b_r_p_e_e X f g R P c d 3)) (decode_p (pack_b_b_r_p_e_e X f g R P c d 4)) (pack_b_b_r_p_e_e X f g R P c d 5) (pack_b_b_r_p_e_e X f g R P c d 6).
rewrite <- pack_b_b_r_p_e_e_0_eq2 X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_5_eq2 X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_6_eq2 X f g R P c d.
apply pack_b_b_r_p_e_e_ext.
- exact pack_b_b_r_p_e_e_1_eq2 X f g R P c d.
- exact pack_b_b_r_p_e_e_2_eq2 X f g R P c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_b_r_p_e_e_3_eq2 X f g R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_r_p_e_e_4_eq2 X f g R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_r_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' R' P' c d = Phi X f g R P c d)
  ->
  unpack_b_b_r_p_e_e_i (pack_b_b_r_p_e_e X f g R P c d) Phi = Phi X f g R P c d.
let Phi X f g R P c d.
assume HPhi.
prove Phi (pack_b_b_r_p_e_e X f g R P c d 0) (decode_b (pack_b_b_r_p_e_e X f g R P c d 1)) (decode_b (pack_b_b_r_p_e_e X f g R P c d 2)) (decode_r (pack_b_b_r_p_e_e X f g R P c d 3)) (decode_p (pack_b_b_r_p_e_e X f g R P c d 4)) (pack_b_b_r_p_e_e X f g R P c d 5) (pack_b_b_r_p_e_e X f g R P c d 6) = Phi X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_0_eq2 X f g R P c d.
prove Phi X (decode_b (pack_b_b_r_p_e_e X f g R P c d 1)) (decode_b (pack_b_b_r_p_e_e X f g R P c d 2)) (decode_r (pack_b_b_r_p_e_e X f g R P c d 3)) (decode_p (pack_b_b_r_p_e_e X f g R P c d 4)) (pack_b_b_r_p_e_e X f g R P c d 5) (pack_b_b_r_p_e_e X f g R P c d 6) = Phi X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_5_eq2 X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_6_eq2 X f g R P c d.
apply HPhi.
- exact pack_b_b_r_p_e_e_1_eq2 X f g R P c d.
- exact pack_b_b_r_p_e_e_2_eq2 X f g R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_p_e_e X f g R P c d 3) x y.
  rewrite <- pack_b_b_r_p_e_e_3_eq2 X f g R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_p_e_e X f g R P c d 4) x.
  rewrite <- pack_b_b_r_p_e_e_4_eq2 X f g R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_r_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_r_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' g' R' P' c d = Phi X f g R P c d)
  ->
  unpack_b_b_r_p_e_e_o (pack_b_b_r_p_e_e X f g R P c d) Phi = Phi X f g R P c d.
let Phi X f g R P c d.
assume HPhi.
prove Phi (pack_b_b_r_p_e_e X f g R P c d 0) (decode_b (pack_b_b_r_p_e_e X f g R P c d 1)) (decode_b (pack_b_b_r_p_e_e X f g R P c d 2)) (decode_r (pack_b_b_r_p_e_e X f g R P c d 3)) (decode_p (pack_b_b_r_p_e_e X f g R P c d 4)) (pack_b_b_r_p_e_e X f g R P c d 5) (pack_b_b_r_p_e_e X f g R P c d 6) = Phi X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_0_eq2 X f g R P c d.
prove Phi X (decode_b (pack_b_b_r_p_e_e X f g R P c d 1)) (decode_b (pack_b_b_r_p_e_e X f g R P c d 2)) (decode_r (pack_b_b_r_p_e_e X f g R P c d 3)) (decode_p (pack_b_b_r_p_e_e X f g R P c d 4)) (pack_b_b_r_p_e_e X f g R P c d 5) (pack_b_b_r_p_e_e X f g R P c d 6) = Phi X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_5_eq2 X f g R P c d.
rewrite <- pack_b_b_r_p_e_e_6_eq2 X f g R P c d.
apply HPhi.
- exact pack_b_b_r_p_e_e_1_eq2 X f g R P c d.
- exact pack_b_b_r_p_e_e_2_eq2 X f g R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_b_r_p_e_e X f g R P c d 3) x y.
  rewrite <- pack_b_b_r_p_e_e_3_eq2 X f g R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_r_p_e_e X f g R P c d 4) x.
  rewrite <- pack_b_b_r_p_e_e_4_eq2 X f g R P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_b_p_p_e_e : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X f g P Q c d => (X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d).

Theorem pack_b_b_p_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> X = S 0.
let S X f g P Q c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_b_p_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_b_b_p_p_e_e X f g P Q c d 0.
let X f g P Q c d. apply pack_b_b_p_p_e_e_0_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_b_p_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_b_p_p_e_e X f g P Q c d 1) x y.
let X f g P Q c d. apply pack_b_b_p_p_e_e_1_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_b_b_p_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, g x y = decode_b (pack_b_b_p_p_e_e X f g P Q c d 2) x y.
let X f g P Q c d. apply pack_b_b_p_p_e_e_2_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X f g P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_b_p_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_b_p_p_e_e X f g P Q c d 3) x.
let X f g P Q c d. apply pack_b_b_p_p_e_e_3_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X f g P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_b_p_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_b_b_p_p_e_e X f g P Q c d 4) x.
let X f g P Q c d. apply pack_b_b_p_p_e_e_4_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> c = S 5.
let S X f g P Q c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_b_p_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_b_b_p_p_e_e X f g P Q c d 5.
let X f g P Q c d. apply pack_b_b_p_p_e_e_5_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_b_p_p_e_e X f g P Q c d -> d = S 6.
let S X f g P Q c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_b_p_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_b_b_p_p_e_e X f g P Q c d 6.
let X f g P Q c d. apply pack_b_b_p_p_e_e_6_eq (pack_b_b_p_p_e_e X f g P Q c d) X f g P Q c d. reflexivity.
Qed.

Theorem pack_b_b_p_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall g g':set -> set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_b_b_p_p_e_e X f g P Q c d = pack_b_b_p_p_e_e X' f' g' P' Q' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, g x y = g' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' f f' g g' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_b_b_p_p_e_e X f g P Q c d 0.
{ exact pack_b_b_p_p_e_e_0_eq (pack_b_b_p_p_e_e X f g P Q c d) X' f' g' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_b_p_p_e_e_0_eq2 X f g P Q c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_b_p_p_e_e_1_eq2 X f g P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_p_p_e_e_1_eq2 X' f' g' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove g x y = g' x y.
  rewrite pack_b_b_p_p_e_e_2_eq2 X f g P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_b_p_p_e_e_2_eq2 X' f' g' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_b_p_p_e_e_3_eq2 X f g P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_p_p_e_e_3_eq2 X' f' g' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_b_p_p_e_e_4_eq2 X f g P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_b_p_p_e_e_4_eq2 X' f' g' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_b_p_p_e_e_5_eq2 X f g P Q c d.
  rewrite H1. symmetry.
  exact pack_b_b_p_p_e_e_5_eq2 X' f' g' P' Q' c' d'.
- prove d = d'.
  rewrite pack_b_b_p_p_e_e_6_eq2 X f g P Q c d.
  rewrite H1. symmetry.
  exact pack_b_b_p_p_e_e_6_eq2 X' f' g' P' Q' c' d'.
Qed.

Theorem pack_b_b_p_p_e_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_b_p_p_e_e X f g P Q c d = pack_b_b_p_p_e_e X f' g' P' Q' c d.
let X f f' g g' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_b X g,encode_p X P,encode_p X Q,c,d) = (X,encode_b X f',encode_b X g',encode_p X P',encode_p X Q',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_b_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_b_p_p_e_e X f g P Q c d)) -> q S.

Theorem pack_struct_b_b_p_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall g:set -> set -> set, (forall x y :e X, g x y :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_b_p_p_e_e (pack_b_b_p_p_e_e X f g P Q c d).
let X f. assume Hf. let g. assume Hg. let P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf g Hg P Q c Hc d Hd.
Qed.

Theorem pack_struct_b_b_p_p_e_e_E1: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_b_p_p_e_e (pack_b_b_p_p_e_e X f g P Q c d) -> forall x y :e X, f x y :e X.
let X f g P Q c d. assume H1. apply H1 (fun z => z = pack_b_b_p_p_e_e X f g P Q c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_p_p_e_e X' f' g' P' Q' c' d' = pack_b_b_p_p_e_e X f g P Q c d.
  apply pack_b_b_p_p_e_e_inj X' X f' f g' g P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_p_p_e_e_E2: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_b_p_p_e_e (pack_b_b_p_p_e_e X f g P Q c d) -> forall x y :e X, g x y :e X.
let X f g P Q c d. assume H1. apply H1 (fun z => z = pack_b_b_p_p_e_e X f g P Q c d -> forall x y :e X, g x y :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_p_p_e_e X' f' g' P' Q' c' d' = pack_b_b_p_p_e_e X f g P Q c d.
  apply pack_b_b_p_p_e_e_inj X' X f' f g' g P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hg'g x Hx y Hy.  exact Hg' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_b_p_p_e_e_E5: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_b_p_p_e_e (pack_b_b_p_p_e_e X f g P Q c d) -> c :e X.
let X f g P Q c d. assume H1. apply H1 (fun z => z = pack_b_b_p_p_e_e X f g P Q c d -> c :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_p_p_e_e X' f' g' P' Q' c' d' = pack_b_b_p_p_e_e X f g P Q c d.
  apply pack_b_b_p_p_e_e_inj X' X f' f g' g P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_b_p_p_e_e_E6: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_b_p_p_e_e (pack_b_b_p_p_e_e X f g P Q c d) -> d :e X.
let X f g P Q c d. assume H1. apply H1 (fun z => z = pack_b_b_p_p_e_e X f g P Q c d -> d :e X).
- let X'. let f'. assume Hf'. let g'. assume Hg'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_b_p_p_e_e X' f' g' P' Q' c' d' = pack_b_b_p_p_e_e X f g P Q c d.
  apply pack_b_b_p_p_e_e_inj X' X f' f g' g P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hg'g HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_b_p_p_e_e_eta: forall S, struct_b_b_p_p_e_e S -> S = pack_b_b_p_p_e_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_b_p_p_e_e (z 0) (decode_b (z 1)) (decode_b (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let g. assume _. let P. let Q. let c. assume _. let d. assume _.
prove pack_b_b_p_p_e_e X f g P Q c d = pack_b_b_p_p_e_e (pack_b_b_p_p_e_e X f g P Q c d 0) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 1)) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 2)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 3)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 4)) (pack_b_b_p_p_e_e X f g P Q c d 5) (pack_b_b_p_p_e_e X f g P Q c d 6).
rewrite <- pack_b_b_p_p_e_e_0_eq2 X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_5_eq2 X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_6_eq2 X f g P Q c d.
apply pack_b_b_p_p_e_e_ext.
- exact pack_b_b_p_p_e_e_1_eq2 X f g P Q c d.
- exact pack_b_b_p_p_e_e_2_eq2 X f g P Q c d.
- let x. assume Hx.
  rewrite <- pack_b_b_p_p_e_e_3_eq2 X f g P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_b_p_p_e_e_4_eq2 X f g P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_p_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_p_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' P' Q' c d = Phi X f g P Q c d)
  ->
  unpack_b_b_p_p_e_e_i (pack_b_b_p_p_e_e X f g P Q c d) Phi = Phi X f g P Q c d.
let Phi X f g P Q c d.
assume HPhi.
prove Phi (pack_b_b_p_p_e_e X f g P Q c d 0) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 1)) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 2)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 3)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 4)) (pack_b_b_p_p_e_e X f g P Q c d 5) (pack_b_b_p_p_e_e X f g P Q c d 6) = Phi X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_0_eq2 X f g P Q c d.
prove Phi X (decode_b (pack_b_b_p_p_e_e X f g P Q c d 1)) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 2)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 3)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 4)) (pack_b_b_p_p_e_e X f g P Q c d 5) (pack_b_b_p_p_e_e X f g P Q c d 6) = Phi X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_5_eq2 X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_6_eq2 X f g P Q c d.
apply HPhi.
- exact pack_b_b_p_p_e_e_1_eq2 X f g P Q c d.
- exact pack_b_b_p_p_e_e_2_eq2 X f g P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_p_p_e_e X f g P Q c d 3) x.
  rewrite <- pack_b_b_p_p_e_e_3_eq2 X f g P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_p_p_e_e X f g P Q c d 4) x.
  rewrite <- pack_b_b_p_p_e_e_4_eq2 X f g P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_b_p_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_b_p_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' g' P' Q' c d = Phi X f g P Q c d)
  ->
  unpack_b_b_p_p_e_e_o (pack_b_b_p_p_e_e X f g P Q c d) Phi = Phi X f g P Q c d.
let Phi X f g P Q c d.
assume HPhi.
prove Phi (pack_b_b_p_p_e_e X f g P Q c d 0) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 1)) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 2)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 3)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 4)) (pack_b_b_p_p_e_e X f g P Q c d 5) (pack_b_b_p_p_e_e X f g P Q c d 6) = Phi X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_0_eq2 X f g P Q c d.
prove Phi X (decode_b (pack_b_b_p_p_e_e X f g P Q c d 1)) (decode_b (pack_b_b_p_p_e_e X f g P Q c d 2)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 3)) (decode_p (pack_b_b_p_p_e_e X f g P Q c d 4)) (pack_b_b_p_p_e_e X f g P Q c d 5) (pack_b_b_p_p_e_e X f g P Q c d 6) = Phi X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_5_eq2 X f g P Q c d.
rewrite <- pack_b_b_p_p_e_e_6_eq2 X f g P Q c d.
apply HPhi.
- exact pack_b_b_p_p_e_e_1_eq2 X f g P Q c d.
- exact pack_b_b_p_p_e_e_2_eq2 X f g P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_b_p_p_e_e X f g P Q c d 3) x.
  rewrite <- pack_b_b_p_p_e_e_3_eq2 X f g P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_b_p_p_e_e X f g P Q c d 4) x.
  rewrite <- pack_b_b_p_p_e_e_4_eq2 X f g P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_u_r_r_p_p : set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X f i R T P Q => (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q).

Theorem pack_b_u_r_r_p_p_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> X = S 0.
let S X f i R T P Q. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_u_r_r_p_p_0_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_b_u_r_r_p_p X f i R T P Q 0.
let X f i R T P Q. apply pack_b_u_r_r_p_p_0_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_p_p_1_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, f x y = decode_b (pack_b_u_r_r_p_p X f i R T P Q 1) x y.
let X f i R T P Q. apply pack_b_u_r_r_p_p_1_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> forall x :e X, i x = decode_u (S 2) x.
let S X f i R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_u_r_r_p_p_2_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_b_u_r_r_p_p X f i R T P Q 2) x.
let X f i R T P Q. apply pack_b_u_r_r_p_p_2_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f i R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_p_p_3_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_b_u_r_r_p_p X f i R T P Q 3) x y.
let X f i R T P Q. apply pack_b_u_r_r_p_p_3_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_4_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X f i R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_p_p_4_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, T x y = decode_r (pack_b_u_r_r_p_p X f i R T P Q 4) x y.
let X f i R T P Q. apply pack_b_u_r_r_p_p_4_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_5_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X f i R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_u_r_r_p_p_5_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_b_u_r_r_p_p X f i R T P Q 5) x.
let X f i R T P Q. apply pack_b_u_r_r_p_p_5_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_6_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_b_u_r_r_p_p X f i R T P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X f i R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_u_r_r_p_p_6_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_b_u_r_r_p_p X f i R T P Q 6) x.
let X f i R T P Q. apply pack_b_u_r_r_p_p_6_eq (pack_b_u_r_r_p_p X f i R T P Q) X f i R T P Q. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_p_inj : forall X X', forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_b_u_r_r_p_p X f i R T P Q = pack_b_u_r_r_p_p X' f' i' R' T' P' Q' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' f f' i i' R R' T T' P P' Q Q'. assume H1.
claim L0: X' = pack_b_u_r_r_p_p X f i R T P Q 0.
{ exact pack_b_u_r_r_p_p_0_eq (pack_b_u_r_r_p_p X f i R T P Q) X' f' i' R' T' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_u_r_r_p_p_0_eq2 X f i R T P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_u_r_r_p_p_1_eq2 X f i R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_p_1_eq2 X' f' i' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_u_r_r_p_p_2_eq2 X f i R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_p_2_eq2 X' f' i' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_u_r_r_p_p_3_eq2 X f i R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_p_3_eq2 X' f' i' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_u_r_r_p_p_4_eq2 X f i R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_p_4_eq2 X' f' i' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_u_r_r_p_p_5_eq2 X f i R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_p_5_eq2 X' f' i' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_u_r_r_p_p_6_eq2 X f i R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_p_6_eq2 X' f' i' R' T' P' Q' x Lx.
Qed.

Theorem pack_b_u_r_r_p_p_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_u_r_r_p_p X f i R T P Q = pack_b_u_r_r_p_p X f' i' R' T' P' Q'.
let X f f' i i' R R' T T' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) = (X,encode_b X f',encode_u X i',encode_r X R',encode_r X T',encode_p X P',encode_p X Q').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_b_u_r_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_b_u_r_r_p_p X f i R T P Q)) -> q S.

Theorem pack_struct_b_u_r_r_p_p_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_u_r_r_p_p (pack_b_u_r_r_p_p X f i R T P Q).
let X f. assume Hf. let i. assume Hi. let R T P Q q. assume Hq.
exact Hq X f Hf i Hi R T P Q.
Qed.

Theorem pack_struct_b_u_r_r_p_p_E1: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_u_r_r_p_p (pack_b_u_r_r_p_p X f i R T P Q) -> forall x y :e X, f x y :e X.
let X f i R T P Q. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_p X f i R T P Q -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_b_u_r_r_p_p X' f' i' R' T' P' Q' = pack_b_u_r_r_p_p X f i R T P Q.
  apply pack_b_u_r_r_p_p_inj X' X f' f i' i R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_r_p_p_E2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_b_u_r_r_p_p (pack_b_u_r_r_p_p X f i R T P Q) -> forall x :e X, i x :e X.
let X f i R T P Q. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_p X f i R T P Q -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_b_u_r_r_p_p X' f' i' R' T' P' Q' = pack_b_u_r_r_p_p X f i R T P Q.
  apply pack_b_u_r_r_p_p_inj X' X f' f i' i R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem struct_b_u_r_r_p_p_eta: forall S, struct_b_u_r_r_p_p S -> S = pack_b_u_r_r_p_p (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_p (z 0) (decode_b (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let f. assume _. let i. assume _. let R. let T. let P. let Q.
prove pack_b_u_r_r_p_p X f i R T P Q = pack_b_u_r_r_p_p (pack_b_u_r_r_p_p X f i R T P Q 0) (decode_b (pack_b_u_r_r_p_p X f i R T P Q 1)) (decode_u (pack_b_u_r_r_p_p X f i R T P Q 2)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 3)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 4)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 5)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 6)).
rewrite <- pack_b_u_r_r_p_p_0_eq2 X f i R T P Q.
apply pack_b_u_r_r_p_p_ext.
- exact pack_b_u_r_r_p_p_1_eq2 X f i R T P Q.
- exact pack_b_u_r_r_p_p_2_eq2 X f i R T P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_r_p_p_3_eq2 X f i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_r_p_p_4_eq2 X f i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_r_r_p_p_5_eq2 X f i R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_r_r_p_p_6_eq2 X f i R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_r_p_p_i : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_u_r_r_p_p_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' i' R' T' P' Q' = Phi X f i R T P Q)
  ->
  unpack_b_u_r_r_p_p_i (pack_b_u_r_r_p_p X f i R T P Q) Phi = Phi X f i R T P Q.
let Phi X f i R T P Q.
assume HPhi.
prove Phi (pack_b_u_r_r_p_p X f i R T P Q 0) (decode_b (pack_b_u_r_r_p_p X f i R T P Q 1)) (decode_u (pack_b_u_r_r_p_p X f i R T P Q 2)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 3)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 4)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 5)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 6)) = Phi X f i R T P Q.
rewrite <- pack_b_u_r_r_p_p_0_eq2 X f i R T P Q.
prove Phi X (decode_b (pack_b_u_r_r_p_p X f i R T P Q 1)) (decode_u (pack_b_u_r_r_p_p X f i R T P Q 2)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 3)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 4)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 5)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 6)) = Phi X f i R T P Q.
apply HPhi.
- exact pack_b_u_r_r_p_p_1_eq2 X f i R T P Q.
- exact pack_b_u_r_r_p_p_2_eq2 X f i R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_r_p_p X f i R T P Q 3) x y.
  rewrite <- pack_b_u_r_r_p_p_3_eq2 X f i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_u_r_r_p_p X f i R T P Q 4) x y.
  rewrite <- pack_b_u_r_r_p_p_4_eq2 X f i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_r_p_p X f i R T P Q 5) x.
  rewrite <- pack_b_u_r_r_p_p_5_eq2 X f i R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_u_r_r_p_p X f i R T P Q 6) x.
  rewrite <- pack_b_u_r_r_p_p_6_eq2 X f i R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_r_p_p_o : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_b_u_r_r_p_p_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' i' R' T' P' Q' = Phi X f i R T P Q)
  ->
  unpack_b_u_r_r_p_p_o (pack_b_u_r_r_p_p X f i R T P Q) Phi = Phi X f i R T P Q.
let Phi X f i R T P Q.
assume HPhi.
prove Phi (pack_b_u_r_r_p_p X f i R T P Q 0) (decode_b (pack_b_u_r_r_p_p X f i R T P Q 1)) (decode_u (pack_b_u_r_r_p_p X f i R T P Q 2)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 3)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 4)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 5)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 6)) = Phi X f i R T P Q.
rewrite <- pack_b_u_r_r_p_p_0_eq2 X f i R T P Q.
prove Phi X (decode_b (pack_b_u_r_r_p_p X f i R T P Q 1)) (decode_u (pack_b_u_r_r_p_p X f i R T P Q 2)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 3)) (decode_r (pack_b_u_r_r_p_p X f i R T P Q 4)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 5)) (decode_p (pack_b_u_r_r_p_p X f i R T P Q 6)) = Phi X f i R T P Q.
apply HPhi.
- exact pack_b_u_r_r_p_p_1_eq2 X f i R T P Q.
- exact pack_b_u_r_r_p_p_2_eq2 X f i R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_r_p_p X f i R T P Q 3) x y.
  rewrite <- pack_b_u_r_r_p_p_3_eq2 X f i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_u_r_r_p_p X f i R T P Q 4) x y.
  rewrite <- pack_b_u_r_r_p_p_4_eq2 X f i R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_r_p_p X f i R T P Q 5) x.
  rewrite <- pack_b_u_r_r_p_p_5_eq2 X f i R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_u_r_r_p_p X f i R T P Q 6) x.
  rewrite <- pack_b_u_r_r_p_p_6_eq2 X f i R T P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_b_u_r_r_p_e : set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X f i R T P c => (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c).

Theorem pack_b_u_r_r_p_e_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> X = S 0.
let S X f i R T P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_u_r_r_p_e_0_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_b_u_r_r_p_e X f i R T P c 0.
let X f i R T P c. apply pack_b_u_r_r_p_e_0_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_p_e_1_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_u_r_r_p_e X f i R T P c 1) x y.
let X f i R T P c. apply pack_b_u_r_r_p_e_1_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> forall x :e X, i x = decode_u (S 2) x.
let S X f i R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_u_r_r_p_e_2_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_u_r_r_p_e X f i R T P c 2) x.
let X f i R T P c. apply pack_b_u_r_r_p_e_2_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f i R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_p_e_3_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_u_r_r_p_e X f i R T P c 3) x y.
let X f i R T P c. apply pack_b_u_r_r_p_e_3_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_4_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X f i R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_p_e_4_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_b_u_r_r_p_e X f i R T P c 4) x y.
let X f i R T P c. apply pack_b_u_r_r_p_e_4_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_5_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> forall x :e X, P x = decode_p (S 5) x.
let S X f i R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_u_r_r_p_e_5_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_u_r_r_p_e X f i R T P c 5) x.
let X f i R T P c. apply pack_b_u_r_r_p_e_5_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_6_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_b_u_r_r_p_e X f i R T P c -> c = S 6.
let S X f i R T P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_u_r_r_p_e_6_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_b_u_r_r_p_e X f i R T P c 6.
let X f i R T P c. apply pack_b_u_r_r_p_e_6_eq (pack_b_u_r_r_p_e X f i R T P c) X f i R T P c. reflexivity.
Qed.

Theorem pack_b_u_r_r_p_e_inj : forall X X', forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_b_u_r_r_p_e X f i R T P c = pack_b_u_r_r_p_e X' f' i' R' T' P' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' f f' i i' R R' T T' P P' c c'. assume H1.
claim L0: X' = pack_b_u_r_r_p_e X f i R T P c 0.
{ exact pack_b_u_r_r_p_e_0_eq (pack_b_u_r_r_p_e X f i R T P c) X' f' i' R' T' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_u_r_r_p_e_0_eq2 X f i R T P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_u_r_r_p_e_1_eq2 X f i R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_e_1_eq2 X' f' i' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_u_r_r_p_e_2_eq2 X f i R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_e_2_eq2 X' f' i' R' T' P' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_u_r_r_p_e_3_eq2 X f i R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_e_3_eq2 X' f' i' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_u_r_r_p_e_4_eq2 X f i R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_e_4_eq2 X' f' i' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_u_r_r_p_e_5_eq2 X f i R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_e_5_eq2 X' f' i' R' T' P' c' x Lx.
- prove c = c'.
  rewrite pack_b_u_r_r_p_e_6_eq2 X f i R T P c.
  rewrite H1. symmetry.
  exact pack_b_u_r_r_p_e_6_eq2 X' f' i' R' T' P' c'.
Qed.

Theorem pack_b_u_r_r_p_e_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_u_r_r_p_e X f i R T P c = pack_b_u_r_r_p_e X f' i' R' T' P' c.
let X f f' i i' R R' T T' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,encode_p X P,c) = (X,encode_b X f',encode_u X i',encode_r X R',encode_r X T',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_u_r_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_b_u_r_r_p_e X f i R T P c)) -> q S.

Theorem pack_struct_b_u_r_r_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_b_u_r_r_p_e (pack_b_u_r_r_p_e X f i R T P c).
let X f. assume Hf. let i. assume Hi. let R T P c. assume Hc. let q. assume Hq.
exact Hq X f Hf i Hi R T P c Hc.
Qed.

Theorem pack_struct_b_u_r_r_p_e_E1: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_u_r_r_p_e (pack_b_u_r_r_p_e X f i R T P c) -> forall x y :e X, f x y :e X.
let X f i R T P c. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_e X f i R T P c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_u_r_r_p_e X' f' i' R' T' P' c' = pack_b_u_r_r_p_e X f i R T P c.
  apply pack_b_u_r_r_p_e_inj X' X f' f i' i R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_r_p_e_E2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_u_r_r_p_e (pack_b_u_r_r_p_e X f i R T P c) -> forall x :e X, i x :e X.
let X f i R T P c. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_e X f i R T P c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_u_r_r_p_e X' f' i' R' T' P' c' = pack_b_u_r_r_p_e X f i R T P c.
  apply pack_b_u_r_r_p_e_inj X' X f' f i' i R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_r_p_e_E6: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_b_u_r_r_p_e (pack_b_u_r_r_p_e X f i R T P c) -> c :e X.
let X f i R T P c. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_e X f i R T P c -> c :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_b_u_r_r_p_e X' f' i' R' T' P' c' = pack_b_u_r_r_p_e X f i R T P c.
  apply pack_b_u_r_r_p_e_inj X' X f' f i' i R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_u_r_r_p_e_eta: forall S, struct_b_u_r_r_p_e S -> S = pack_b_u_r_r_p_e (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_u_r_r_p_e (z 0) (decode_b (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let i. assume _. let R. let T. let P. let c. assume _.
prove pack_b_u_r_r_p_e X f i R T P c = pack_b_u_r_r_p_e (pack_b_u_r_r_p_e X f i R T P c 0) (decode_b (pack_b_u_r_r_p_e X f i R T P c 1)) (decode_u (pack_b_u_r_r_p_e X f i R T P c 2)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 3)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 4)) (decode_p (pack_b_u_r_r_p_e X f i R T P c 5)) (pack_b_u_r_r_p_e X f i R T P c 6).
rewrite <- pack_b_u_r_r_p_e_0_eq2 X f i R T P c.
rewrite <- pack_b_u_r_r_p_e_6_eq2 X f i R T P c.
apply pack_b_u_r_r_p_e_ext.
- exact pack_b_u_r_r_p_e_1_eq2 X f i R T P c.
- exact pack_b_u_r_r_p_e_2_eq2 X f i R T P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_r_p_e_3_eq2 X f i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_r_p_e_4_eq2 X f i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_r_r_p_e_5_eq2 X f i R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_r_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_u_r_r_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' i' R' T' P' c = Phi X f i R T P c)
  ->
  unpack_b_u_r_r_p_e_i (pack_b_u_r_r_p_e X f i R T P c) Phi = Phi X f i R T P c.
let Phi X f i R T P c.
assume HPhi.
prove Phi (pack_b_u_r_r_p_e X f i R T P c 0) (decode_b (pack_b_u_r_r_p_e X f i R T P c 1)) (decode_u (pack_b_u_r_r_p_e X f i R T P c 2)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 3)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 4)) (decode_p (pack_b_u_r_r_p_e X f i R T P c 5)) (pack_b_u_r_r_p_e X f i R T P c 6) = Phi X f i R T P c.
rewrite <- pack_b_u_r_r_p_e_0_eq2 X f i R T P c.
prove Phi X (decode_b (pack_b_u_r_r_p_e X f i R T P c 1)) (decode_u (pack_b_u_r_r_p_e X f i R T P c 2)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 3)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 4)) (decode_p (pack_b_u_r_r_p_e X f i R T P c 5)) (pack_b_u_r_r_p_e X f i R T P c 6) = Phi X f i R T P c.
rewrite <- pack_b_u_r_r_p_e_6_eq2 X f i R T P c.
apply HPhi.
- exact pack_b_u_r_r_p_e_1_eq2 X f i R T P c.
- exact pack_b_u_r_r_p_e_2_eq2 X f i R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_r_p_e X f i R T P c 3) x y.
  rewrite <- pack_b_u_r_r_p_e_3_eq2 X f i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_u_r_r_p_e X f i R T P c 4) x y.
  rewrite <- pack_b_u_r_r_p_e_4_eq2 X f i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_r_p_e X f i R T P c 5) x.
  rewrite <- pack_b_u_r_r_p_e_5_eq2 X f i R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_r_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_u_r_r_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' i' R' T' P' c = Phi X f i R T P c)
  ->
  unpack_b_u_r_r_p_e_o (pack_b_u_r_r_p_e X f i R T P c) Phi = Phi X f i R T P c.
let Phi X f i R T P c.
assume HPhi.
prove Phi (pack_b_u_r_r_p_e X f i R T P c 0) (decode_b (pack_b_u_r_r_p_e X f i R T P c 1)) (decode_u (pack_b_u_r_r_p_e X f i R T P c 2)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 3)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 4)) (decode_p (pack_b_u_r_r_p_e X f i R T P c 5)) (pack_b_u_r_r_p_e X f i R T P c 6) = Phi X f i R T P c.
rewrite <- pack_b_u_r_r_p_e_0_eq2 X f i R T P c.
prove Phi X (decode_b (pack_b_u_r_r_p_e X f i R T P c 1)) (decode_u (pack_b_u_r_r_p_e X f i R T P c 2)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 3)) (decode_r (pack_b_u_r_r_p_e X f i R T P c 4)) (decode_p (pack_b_u_r_r_p_e X f i R T P c 5)) (pack_b_u_r_r_p_e X f i R T P c 6) = Phi X f i R T P c.
rewrite <- pack_b_u_r_r_p_e_6_eq2 X f i R T P c.
apply HPhi.
- exact pack_b_u_r_r_p_e_1_eq2 X f i R T P c.
- exact pack_b_u_r_r_p_e_2_eq2 X f i R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_r_p_e X f i R T P c 3) x y.
  rewrite <- pack_b_u_r_r_p_e_3_eq2 X f i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_u_r_r_p_e X f i R T P c 4) x y.
  rewrite <- pack_b_u_r_r_p_e_4_eq2 X f i R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_r_p_e X f i R T P c 5) x.
  rewrite <- pack_b_u_r_r_p_e_5_eq2 X f i R T P c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_u_r_r_e_e : set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set := fun X f i R T c d => (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d).

Theorem pack_b_u_r_r_e_e_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> X = S 0.
let S X f i R T c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_u_r_r_e_e_0_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, X = pack_b_u_r_r_e_e X f i R T c d 0.
let X f i R T c d. apply pack_b_u_r_r_e_e_0_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_e_e_1_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_u_r_r_e_e X f i R T c d 1) x y.
let X f i R T c d. apply pack_b_u_r_r_e_e_1_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> forall x :e X, i x = decode_u (S 2) x.
let S X f i R T c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_u_r_r_e_e_2_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_u_r_r_e_e X f i R T c d 2) x.
let X f i R T c d. apply pack_b_u_r_r_e_e_2_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f i R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_e_e_3_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_u_r_r_e_e X f i R T c d 3) x y.
let X f i R T c d. apply pack_b_u_r_r_e_e_3_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_4_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X f i R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_b_u_r_r_e_e_4_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, T x y = decode_r (pack_b_u_r_r_e_e X f i R T c d 4) x y.
let X f i R T c d. apply pack_b_u_r_r_e_e_4_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_5_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> c = S 5.
let S X f i R T c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_u_r_r_e_e_5_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, c = pack_b_u_r_r_e_e X f i R T c d 5.
let X f i R T c d. apply pack_b_u_r_r_e_e_5_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_6_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_b_u_r_r_e_e X f i R T c d -> d = S 6.
let S X f i R T c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_u_r_r_e_e_6_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, d = pack_b_u_r_r_e_e X f i R T c d 6.
let X f i R T c d. apply pack_b_u_r_r_e_e_6_eq (pack_b_u_r_r_e_e X f i R T c d) X f i R T c d. reflexivity.
Qed.

Theorem pack_b_u_r_r_e_e_inj : forall X X', forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, forall d d':set, pack_b_u_r_r_e_e X f i R T c d = pack_b_u_r_r_e_e X' f' i' R' T' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c' /\ d = d'.
let X X' f f' i i' R R' T T' c c' d d'. assume H1.
claim L0: X' = pack_b_u_r_r_e_e X f i R T c d 0.
{ exact pack_b_u_r_r_e_e_0_eq (pack_b_u_r_r_e_e X f i R T c d) X' f' i' R' T' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_u_r_r_e_e_0_eq2 X f i R T c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_u_r_r_e_e_1_eq2 X f i R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_e_e_1_eq2 X' f' i' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_u_r_r_e_e_2_eq2 X f i R T c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_e_e_2_eq2 X' f' i' R' T' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_u_r_r_e_e_3_eq2 X f i R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_e_e_3_eq2 X' f' i' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_b_u_r_r_e_e_4_eq2 X f i R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_r_e_e_4_eq2 X' f' i' R' T' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_b_u_r_r_e_e_5_eq2 X f i R T c d.
  rewrite H1. symmetry.
  exact pack_b_u_r_r_e_e_5_eq2 X' f' i' R' T' c' d'.
- prove d = d'.
  rewrite pack_b_u_r_r_e_e_6_eq2 X f i R T c d.
  rewrite H1. symmetry.
  exact pack_b_u_r_r_e_e_6_eq2 X' f' i' R' T' c' d'.
Qed.

Theorem pack_b_u_r_r_e_e_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_b_u_r_r_e_e X f i R T c d = pack_b_u_r_r_e_e X f' i' R' T' c d.
let X f f' i i' R R' T T' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_u X i,encode_r X R,encode_r X T,c,d) = (X,encode_b X f',encode_u X i',encode_r X R',encode_r X T',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_u_r_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_u_r_r_e_e X f i R T c d)) -> q S.

Theorem pack_struct_b_u_r_r_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_u_r_r_e_e (pack_b_u_r_r_e_e X f i R T c d).
let X f. assume Hf. let i. assume Hi. let R T c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf i Hi R T c Hc d Hd.
Qed.

Theorem pack_struct_b_u_r_r_e_e_E1: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_u_r_r_e_e (pack_b_u_r_r_e_e X f i R T c d) -> forall x y :e X, f x y :e X.
let X f i R T c d. assume H1. apply H1 (fun z => z = pack_b_u_r_r_e_e X f i R T c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_r_e_e X' f' i' R' T' c' d' = pack_b_u_r_r_e_e X f i R T c d.
  apply pack_b_u_r_r_e_e_inj X' X f' f i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_r_e_e_E2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_u_r_r_e_e (pack_b_u_r_r_e_e X f i R T c d) -> forall x :e X, i x :e X.
let X f i R T c d. assume H1. apply H1 (fun z => z = pack_b_u_r_r_e_e X f i R T c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_r_e_e X' f' i' R' T' c' d' = pack_b_u_r_r_e_e X f i R T c d.
  apply pack_b_u_r_r_e_e_inj X' X f' f i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_r_e_e_E5: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_u_r_r_e_e (pack_b_u_r_r_e_e X f i R T c d) -> c :e X.
let X f i R T c d. assume H1. apply H1 (fun z => z = pack_b_u_r_r_e_e X f i R T c d -> c :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_r_e_e X' f' i' R' T' c' d' = pack_b_u_r_r_e_e X f i R T c d.
  apply pack_b_u_r_r_e_e_inj X' X f' f i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_r_e_e_E6: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_b_u_r_r_e_e (pack_b_u_r_r_e_e X f i R T c d) -> d :e X.
let X f i R T c d. assume H1. apply H1 (fun z => z = pack_b_u_r_r_e_e X f i R T c d -> d :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_r_e_e X' f' i' R' T' c' d' = pack_b_u_r_r_e_e X f i R T c d.
  apply pack_b_u_r_r_e_e_inj X' X f' f i' i R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_u_r_r_e_e_eta: forall S, struct_b_u_r_r_e_e S -> S = pack_b_u_r_r_e_e (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_u_r_r_e_e (z 0) (decode_b (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let f. assume _. let i. assume _. let R. let T. let c. assume _. let d. assume _.
prove pack_b_u_r_r_e_e X f i R T c d = pack_b_u_r_r_e_e (pack_b_u_r_r_e_e X f i R T c d 0) (decode_b (pack_b_u_r_r_e_e X f i R T c d 1)) (decode_u (pack_b_u_r_r_e_e X f i R T c d 2)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 3)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 4)) (pack_b_u_r_r_e_e X f i R T c d 5) (pack_b_u_r_r_e_e X f i R T c d 6).
rewrite <- pack_b_u_r_r_e_e_0_eq2 X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_5_eq2 X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_6_eq2 X f i R T c d.
apply pack_b_u_r_r_e_e_ext.
- exact pack_b_u_r_r_e_e_1_eq2 X f i R T c d.
- exact pack_b_u_r_r_e_e_2_eq2 X f i R T c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_r_e_e_3_eq2 X f i R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_r_e_e_4_eq2 X f i R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_r_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_u_r_r_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' i' R' T' c d = Phi X f i R T c d)
  ->
  unpack_b_u_r_r_e_e_i (pack_b_u_r_r_e_e X f i R T c d) Phi = Phi X f i R T c d.
let Phi X f i R T c d.
assume HPhi.
prove Phi (pack_b_u_r_r_e_e X f i R T c d 0) (decode_b (pack_b_u_r_r_e_e X f i R T c d 1)) (decode_u (pack_b_u_r_r_e_e X f i R T c d 2)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 3)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 4)) (pack_b_u_r_r_e_e X f i R T c d 5) (pack_b_u_r_r_e_e X f i R T c d 6) = Phi X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_0_eq2 X f i R T c d.
prove Phi X (decode_b (pack_b_u_r_r_e_e X f i R T c d 1)) (decode_u (pack_b_u_r_r_e_e X f i R T c d 2)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 3)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 4)) (pack_b_u_r_r_e_e X f i R T c d 5) (pack_b_u_r_r_e_e X f i R T c d 6) = Phi X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_5_eq2 X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_6_eq2 X f i R T c d.
apply HPhi.
- exact pack_b_u_r_r_e_e_1_eq2 X f i R T c d.
- exact pack_b_u_r_r_e_e_2_eq2 X f i R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_r_e_e X f i R T c d 3) x y.
  rewrite <- pack_b_u_r_r_e_e_3_eq2 X f i R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_u_r_r_e_e X f i R T c d 4) x y.
  rewrite <- pack_b_u_r_r_e_e_4_eq2 X f i R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_r_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_b_u_r_r_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X f' i' R' T' c d = Phi X f i R T c d)
  ->
  unpack_b_u_r_r_e_e_o (pack_b_u_r_r_e_e X f i R T c d) Phi = Phi X f i R T c d.
let Phi X f i R T c d.
assume HPhi.
prove Phi (pack_b_u_r_r_e_e X f i R T c d 0) (decode_b (pack_b_u_r_r_e_e X f i R T c d 1)) (decode_u (pack_b_u_r_r_e_e X f i R T c d 2)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 3)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 4)) (pack_b_u_r_r_e_e X f i R T c d 5) (pack_b_u_r_r_e_e X f i R T c d 6) = Phi X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_0_eq2 X f i R T c d.
prove Phi X (decode_b (pack_b_u_r_r_e_e X f i R T c d 1)) (decode_u (pack_b_u_r_r_e_e X f i R T c d 2)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 3)) (decode_r (pack_b_u_r_r_e_e X f i R T c d 4)) (pack_b_u_r_r_e_e X f i R T c d 5) (pack_b_u_r_r_e_e X f i R T c d 6) = Phi X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_5_eq2 X f i R T c d.
rewrite <- pack_b_u_r_r_e_e_6_eq2 X f i R T c d.
apply HPhi.
- exact pack_b_u_r_r_e_e_1_eq2 X f i R T c d.
- exact pack_b_u_r_r_e_e_2_eq2 X f i R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_r_e_e X f i R T c d 3) x y.
  rewrite <- pack_b_u_r_r_e_e_3_eq2 X f i R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_b_u_r_r_e_e X f i R T c d 4) x y.
  rewrite <- pack_b_u_r_r_e_e_4_eq2 X f i R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_b_u_r_p_p_e : set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set := fun X f i R P Q c => (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c).

Theorem pack_b_u_r_p_p_e_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> X = S 0.
let S X f i R P Q c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_u_r_p_p_e_0_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_b_u_r_p_p_e X f i R P Q c 0.
let X f i R P Q c. apply pack_b_u_r_p_p_e_0_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_u_r_p_p_e_1_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, f x y = decode_b (pack_b_u_r_p_p_e X f i R P Q c 1) x y.
let X f i R P Q c. apply pack_b_u_r_p_p_e_1_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> forall x :e X, i x = decode_u (S 2) x.
let S X f i R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_u_r_p_p_e_2_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_b_u_r_p_p_e X f i R P Q c 2) x.
let X f i R P Q c. apply pack_b_u_r_p_p_e_2_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f i R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_u_r_p_p_e_3_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_b_u_r_p_p_e X f i R P Q c 3) x y.
let X f i R P Q c. apply pack_b_u_r_p_p_e_3_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_4_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X f i R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_u_r_p_p_e_4_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_b_u_r_p_p_e X f i R P Q c 4) x.
let X f i R P Q c. apply pack_b_u_r_p_p_e_4_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_5_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X f i R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_u_r_p_p_e_5_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_b_u_r_p_p_e X f i R P Q c 5) x.
let X f i R P Q c. apply pack_b_u_r_p_p_e_5_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_6_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_b_u_r_p_p_e X f i R P Q c -> c = S 6.
let S X f i R P Q c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_u_r_p_p_e_6_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_b_u_r_p_p_e X f i R P Q c 6.
let X f i R P Q c. apply pack_b_u_r_p_p_e_6_eq (pack_b_u_r_p_p_e X f i R P Q c) X f i R P Q c. reflexivity.
Qed.

Theorem pack_b_u_r_p_p_e_inj : forall X X', forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_b_u_r_p_p_e X f i R P Q c = pack_b_u_r_p_p_e X' f' i' R' P' Q' c' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' f f' i i' R R' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_b_u_r_p_p_e X f i R P Q c 0.
{ exact pack_b_u_r_p_p_e_0_eq (pack_b_u_r_p_p_e X f i R P Q c) X' f' i' R' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_u_r_p_p_e_0_eq2 X f i R P Q c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_u_r_p_p_e_1_eq2 X f i R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_p_e_1_eq2 X' f' i' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_u_r_p_p_e_2_eq2 X f i R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_p_e_2_eq2 X' f' i' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_u_r_p_p_e_3_eq2 X f i R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_p_e_3_eq2 X' f' i' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_u_r_p_p_e_4_eq2 X f i R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_p_e_4_eq2 X' f' i' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_u_r_p_p_e_5_eq2 X f i R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_p_e_5_eq2 X' f' i' R' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_b_u_r_p_p_e_6_eq2 X f i R P Q c.
  rewrite H1. symmetry.
  exact pack_b_u_r_p_p_e_6_eq2 X' f' i' R' P' Q' c'.
Qed.

Theorem pack_b_u_r_p_p_e_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_u_r_p_p_e X f i R P Q c = pack_b_u_r_p_p_e X f' i' R' P' Q' c.
let X f f' i i' R R' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c) = (X,encode_b X f',encode_u X i',encode_r X R',encode_p X P',encode_p X Q',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_b_u_r_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_b_u_r_p_p_e X f i R P Q c)) -> q S.

Theorem pack_struct_b_u_r_p_p_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_b_u_r_p_p_e (pack_b_u_r_p_p_e X f i R P Q c).
let X f. assume Hf. let i. assume Hi. let R P Q c. assume Hc. let q. assume Hq.
exact Hq X f Hf i Hi R P Q c Hc.
Qed.

Theorem pack_struct_b_u_r_p_p_e_E1: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_u_r_p_p_e (pack_b_u_r_p_p_e X f i R P Q c) -> forall x y :e X, f x y :e X.
let X f i R P Q c. assume H1. apply H1 (fun z => z = pack_b_u_r_p_p_e X f i R P Q c -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_u_r_p_p_e X' f' i' R' P' Q' c' = pack_b_u_r_p_p_e X f i R P Q c.
  apply pack_b_u_r_p_p_e_inj X' X f' f i' i R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_p_p_e_E2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_u_r_p_p_e (pack_b_u_r_p_p_e X f i R P Q c) -> forall x :e X, i x :e X.
let X f i R P Q c. assume H1. apply H1 (fun z => z = pack_b_u_r_p_p_e X f i R P Q c -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_u_r_p_p_e X' f' i' R' P' Q' c' = pack_b_u_r_p_p_e X f i R P Q c.
  apply pack_b_u_r_p_p_e_inj X' X f' f i' i R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_p_p_e_E6: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_b_u_r_p_p_e (pack_b_u_r_p_p_e X f i R P Q c) -> c :e X.
let X f i R P Q c. assume H1. apply H1 (fun z => z = pack_b_u_r_p_p_e X f i R P Q c -> c :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_b_u_r_p_p_e X' f' i' R' P' Q' c' = pack_b_u_r_p_p_e X f i R P Q c.
  apply pack_b_u_r_p_p_e_inj X' X f' f i' i R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_b_u_r_p_p_e_eta: forall S, struct_b_u_r_p_p_e S -> S = pack_b_u_r_p_p_e (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_u_r_p_p_e (z 0) (decode_b (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let f. assume _. let i. assume _. let R. let P. let Q. let c. assume _.
prove pack_b_u_r_p_p_e X f i R P Q c = pack_b_u_r_p_p_e (pack_b_u_r_p_p_e X f i R P Q c 0) (decode_b (pack_b_u_r_p_p_e X f i R P Q c 1)) (decode_u (pack_b_u_r_p_p_e X f i R P Q c 2)) (decode_r (pack_b_u_r_p_p_e X f i R P Q c 3)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 4)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 5)) (pack_b_u_r_p_p_e X f i R P Q c 6).
rewrite <- pack_b_u_r_p_p_e_0_eq2 X f i R P Q c.
rewrite <- pack_b_u_r_p_p_e_6_eq2 X f i R P Q c.
apply pack_b_u_r_p_p_e_ext.
- exact pack_b_u_r_p_p_e_1_eq2 X f i R P Q c.
- exact pack_b_u_r_p_p_e_2_eq2 X f i R P Q c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_p_p_e_3_eq2 X f i R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_r_p_p_e_4_eq2 X f i R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_r_p_p_e_5_eq2 X f i R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_p_p_e_i : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_u_r_p_p_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' i' R' P' Q' c = Phi X f i R P Q c)
  ->
  unpack_b_u_r_p_p_e_i (pack_b_u_r_p_p_e X f i R P Q c) Phi = Phi X f i R P Q c.
let Phi X f i R P Q c.
assume HPhi.
prove Phi (pack_b_u_r_p_p_e X f i R P Q c 0) (decode_b (pack_b_u_r_p_p_e X f i R P Q c 1)) (decode_u (pack_b_u_r_p_p_e X f i R P Q c 2)) (decode_r (pack_b_u_r_p_p_e X f i R P Q c 3)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 4)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 5)) (pack_b_u_r_p_p_e X f i R P Q c 6) = Phi X f i R P Q c.
rewrite <- pack_b_u_r_p_p_e_0_eq2 X f i R P Q c.
prove Phi X (decode_b (pack_b_u_r_p_p_e X f i R P Q c 1)) (decode_u (pack_b_u_r_p_p_e X f i R P Q c 2)) (decode_r (pack_b_u_r_p_p_e X f i R P Q c 3)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 4)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 5)) (pack_b_u_r_p_p_e X f i R P Q c 6) = Phi X f i R P Q c.
rewrite <- pack_b_u_r_p_p_e_6_eq2 X f i R P Q c.
apply HPhi.
- exact pack_b_u_r_p_p_e_1_eq2 X f i R P Q c.
- exact pack_b_u_r_p_p_e_2_eq2 X f i R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_p_p_e X f i R P Q c 3) x y.
  rewrite <- pack_b_u_r_p_p_e_3_eq2 X f i R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_p_p_e X f i R P Q c 4) x.
  rewrite <- pack_b_u_r_p_p_e_4_eq2 X f i R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_u_r_p_p_e X f i R P Q c 5) x.
  rewrite <- pack_b_u_r_p_p_e_5_eq2 X f i R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_p_p_e_o : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_b_u_r_p_p_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' i' R' P' Q' c = Phi X f i R P Q c)
  ->
  unpack_b_u_r_p_p_e_o (pack_b_u_r_p_p_e X f i R P Q c) Phi = Phi X f i R P Q c.
let Phi X f i R P Q c.
assume HPhi.
prove Phi (pack_b_u_r_p_p_e X f i R P Q c 0) (decode_b (pack_b_u_r_p_p_e X f i R P Q c 1)) (decode_u (pack_b_u_r_p_p_e X f i R P Q c 2)) (decode_r (pack_b_u_r_p_p_e X f i R P Q c 3)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 4)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 5)) (pack_b_u_r_p_p_e X f i R P Q c 6) = Phi X f i R P Q c.
rewrite <- pack_b_u_r_p_p_e_0_eq2 X f i R P Q c.
prove Phi X (decode_b (pack_b_u_r_p_p_e X f i R P Q c 1)) (decode_u (pack_b_u_r_p_p_e X f i R P Q c 2)) (decode_r (pack_b_u_r_p_p_e X f i R P Q c 3)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 4)) (decode_p (pack_b_u_r_p_p_e X f i R P Q c 5)) (pack_b_u_r_p_p_e X f i R P Q c 6) = Phi X f i R P Q c.
rewrite <- pack_b_u_r_p_p_e_6_eq2 X f i R P Q c.
apply HPhi.
- exact pack_b_u_r_p_p_e_1_eq2 X f i R P Q c.
- exact pack_b_u_r_p_p_e_2_eq2 X f i R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_p_p_e X f i R P Q c 3) x y.
  rewrite <- pack_b_u_r_p_p_e_3_eq2 X f i R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_p_p_e X f i R P Q c 4) x.
  rewrite <- pack_b_u_r_p_p_e_4_eq2 X f i R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_u_r_p_p_e X f i R P Q c 5) x.
  rewrite <- pack_b_u_r_p_p_e_5_eq2 X f i R P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_b_u_r_p_e_e : set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set := fun X f i R P c d => (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d).

Theorem pack_b_u_r_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> X = S 0.
let S X f i R P c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_u_r_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, X = pack_b_u_r_p_e_e X f i R P c d 0.
let X f i R P c d. apply pack_b_u_r_p_e_e_0_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_u_r_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_u_r_p_e_e X f i R P c d 1) x y.
let X f i R P c d. apply pack_b_u_r_p_e_e_1_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> forall x :e X, i x = decode_u (S 2) x.
let S X f i R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_u_r_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_u_r_p_e_e X f i R P c d 2) x.
let X f i R P c d. apply pack_b_u_r_p_e_e_2_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f i R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_u_r_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_u_r_p_e_e X f i R P c d 3) x y.
let X f i R P c d. apply pack_b_u_r_p_e_e_3_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X f i R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_u_r_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_u_r_p_e_e X f i R P c d 4) x.
let X f i R P c d. apply pack_b_u_r_p_e_e_4_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> c = S 5.
let S X f i R P c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_u_r_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, c = pack_b_u_r_p_e_e X f i R P c d 5.
let X f i R P c d. apply pack_b_u_r_p_e_e_5_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_b_u_r_p_e_e X f i R P c d -> d = S 6.
let S X f i R P c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_u_r_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, d = pack_b_u_r_p_e_e X f i R P c d 6.
let X f i R P c d. apply pack_b_u_r_p_e_e_6_eq (pack_b_u_r_p_e_e X f i R P c d) X f i R P c d. reflexivity.
Qed.

Theorem pack_b_u_r_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, forall d d':set, pack_b_u_r_p_e_e X f i R P c d = pack_b_u_r_p_e_e X' f' i' R' P' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' f f' i i' R R' P P' c c' d d'. assume H1.
claim L0: X' = pack_b_u_r_p_e_e X f i R P c d 0.
{ exact pack_b_u_r_p_e_e_0_eq (pack_b_u_r_p_e_e X f i R P c d) X' f' i' R' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_u_r_p_e_e_0_eq2 X f i R P c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_u_r_p_e_e_1_eq2 X f i R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_e_e_1_eq2 X' f' i' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_u_r_p_e_e_2_eq2 X f i R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_e_e_2_eq2 X' f' i' R' P' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_u_r_p_e_e_3_eq2 X f i R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_e_e_3_eq2 X' f' i' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_u_r_p_e_e_4_eq2 X f i R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_r_p_e_e_4_eq2 X' f' i' R' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_u_r_p_e_e_5_eq2 X f i R P c d.
  rewrite H1. symmetry.
  exact pack_b_u_r_p_e_e_5_eq2 X' f' i' R' P' c' d'.
- prove d = d'.
  rewrite pack_b_u_r_p_e_e_6_eq2 X f i R P c d.
  rewrite H1. symmetry.
  exact pack_b_u_r_p_e_e_6_eq2 X' f' i' R' P' c' d'.
Qed.

Theorem pack_b_u_r_p_e_e_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_u_r_p_e_e X f i R P c d = pack_b_u_r_p_e_e X f' i' R' P' c d.
let X f f' i i' R R' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_u X i,encode_r X R,encode_p X P,c,d) = (X,encode_b X f',encode_u X i',encode_r X R',encode_p X P',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_u_r_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_u_r_p_e_e X f i R P c d)) -> q S.

Theorem pack_struct_b_u_r_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_u_r_p_e_e (pack_b_u_r_p_e_e X f i R P c d).
let X f. assume Hf. let i. assume Hi. let R P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf i Hi R P c Hc d Hd.
Qed.

Theorem pack_struct_b_u_r_p_e_e_E1: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_u_r_p_e_e (pack_b_u_r_p_e_e X f i R P c d) -> forall x y :e X, f x y :e X.
let X f i R P c d. assume H1. apply H1 (fun z => z = pack_b_u_r_p_e_e X f i R P c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_p_e_e X' f' i' R' P' c' d' = pack_b_u_r_p_e_e X f i R P c d.
  apply pack_b_u_r_p_e_e_inj X' X f' f i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_p_e_e_E2: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_u_r_p_e_e (pack_b_u_r_p_e_e X f i R P c d) -> forall x :e X, i x :e X.
let X f i R P c d. assume H1. apply H1 (fun z => z = pack_b_u_r_p_e_e X f i R P c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_p_e_e X' f' i' R' P' c' d' = pack_b_u_r_p_e_e X f i R P c d.
  apply pack_b_u_r_p_e_e_inj X' X f' f i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_p_e_e_E5: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_u_r_p_e_e (pack_b_u_r_p_e_e X f i R P c d) -> c :e X.
let X f i R P c d. assume H1. apply H1 (fun z => z = pack_b_u_r_p_e_e X f i R P c d -> c :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_p_e_e X' f' i' R' P' c' d' = pack_b_u_r_p_e_e X f i R P c d.
  apply pack_b_u_r_p_e_e_inj X' X f' f i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_u_r_p_e_e_E6: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_b_u_r_p_e_e (pack_b_u_r_p_e_e X f i R P c d) -> d :e X.
let X f i R P c d. assume H1. apply H1 (fun z => z = pack_b_u_r_p_e_e X f i R P c d -> d :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_r_p_e_e X' f' i' R' P' c' d' = pack_b_u_r_p_e_e X f i R P c d.
  apply pack_b_u_r_p_e_e_inj X' X f' f i' i R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_u_r_p_e_e_eta: forall S, struct_b_u_r_p_e_e S -> S = pack_b_u_r_p_e_e (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_u_r_p_e_e (z 0) (decode_b (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let i. assume _. let R. let P. let c. assume _. let d. assume _.
prove pack_b_u_r_p_e_e X f i R P c d = pack_b_u_r_p_e_e (pack_b_u_r_p_e_e X f i R P c d 0) (decode_b (pack_b_u_r_p_e_e X f i R P c d 1)) (decode_u (pack_b_u_r_p_e_e X f i R P c d 2)) (decode_r (pack_b_u_r_p_e_e X f i R P c d 3)) (decode_p (pack_b_u_r_p_e_e X f i R P c d 4)) (pack_b_u_r_p_e_e X f i R P c d 5) (pack_b_u_r_p_e_e X f i R P c d 6).
rewrite <- pack_b_u_r_p_e_e_0_eq2 X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_5_eq2 X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_6_eq2 X f i R P c d.
apply pack_b_u_r_p_e_e_ext.
- exact pack_b_u_r_p_e_e_1_eq2 X f i R P c d.
- exact pack_b_u_r_p_e_e_2_eq2 X f i R P c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_u_r_p_e_e_3_eq2 X f i R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_r_p_e_e_4_eq2 X f i R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_u_r_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' i' R' P' c d = Phi X f i R P c d)
  ->
  unpack_b_u_r_p_e_e_i (pack_b_u_r_p_e_e X f i R P c d) Phi = Phi X f i R P c d.
let Phi X f i R P c d.
assume HPhi.
prove Phi (pack_b_u_r_p_e_e X f i R P c d 0) (decode_b (pack_b_u_r_p_e_e X f i R P c d 1)) (decode_u (pack_b_u_r_p_e_e X f i R P c d 2)) (decode_r (pack_b_u_r_p_e_e X f i R P c d 3)) (decode_p (pack_b_u_r_p_e_e X f i R P c d 4)) (pack_b_u_r_p_e_e X f i R P c d 5) (pack_b_u_r_p_e_e X f i R P c d 6) = Phi X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_0_eq2 X f i R P c d.
prove Phi X (decode_b (pack_b_u_r_p_e_e X f i R P c d 1)) (decode_u (pack_b_u_r_p_e_e X f i R P c d 2)) (decode_r (pack_b_u_r_p_e_e X f i R P c d 3)) (decode_p (pack_b_u_r_p_e_e X f i R P c d 4)) (pack_b_u_r_p_e_e X f i R P c d 5) (pack_b_u_r_p_e_e X f i R P c d 6) = Phi X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_5_eq2 X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_6_eq2 X f i R P c d.
apply HPhi.
- exact pack_b_u_r_p_e_e_1_eq2 X f i R P c d.
- exact pack_b_u_r_p_e_e_2_eq2 X f i R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_p_e_e X f i R P c d 3) x y.
  rewrite <- pack_b_u_r_p_e_e_3_eq2 X f i R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_p_e_e X f i R P c d 4) x.
  rewrite <- pack_b_u_r_p_e_e_4_eq2 X f i R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_r_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_u_r_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f' i' R' P' c d = Phi X f i R P c d)
  ->
  unpack_b_u_r_p_e_e_o (pack_b_u_r_p_e_e X f i R P c d) Phi = Phi X f i R P c d.
let Phi X f i R P c d.
assume HPhi.
prove Phi (pack_b_u_r_p_e_e X f i R P c d 0) (decode_b (pack_b_u_r_p_e_e X f i R P c d 1)) (decode_u (pack_b_u_r_p_e_e X f i R P c d 2)) (decode_r (pack_b_u_r_p_e_e X f i R P c d 3)) (decode_p (pack_b_u_r_p_e_e X f i R P c d 4)) (pack_b_u_r_p_e_e X f i R P c d 5) (pack_b_u_r_p_e_e X f i R P c d 6) = Phi X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_0_eq2 X f i R P c d.
prove Phi X (decode_b (pack_b_u_r_p_e_e X f i R P c d 1)) (decode_u (pack_b_u_r_p_e_e X f i R P c d 2)) (decode_r (pack_b_u_r_p_e_e X f i R P c d 3)) (decode_p (pack_b_u_r_p_e_e X f i R P c d 4)) (pack_b_u_r_p_e_e X f i R P c d 5) (pack_b_u_r_p_e_e X f i R P c d 6) = Phi X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_5_eq2 X f i R P c d.
rewrite <- pack_b_u_r_p_e_e_6_eq2 X f i R P c d.
apply HPhi.
- exact pack_b_u_r_p_e_e_1_eq2 X f i R P c d.
- exact pack_b_u_r_p_e_e_2_eq2 X f i R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_u_r_p_e_e X f i R P c d 3) x y.
  rewrite <- pack_b_u_r_p_e_e_3_eq2 X f i R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_r_p_e_e X f i R P c d 4) x.
  rewrite <- pack_b_u_r_p_e_e_4_eq2 X f i R P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_u_p_p_e_e : set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X f i P Q c d => (X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d).

Theorem pack_b_u_p_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> X = S 0.
let S X f i P Q c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_u_p_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_b_u_p_p_e_e X f i P Q c d 0.
let X f i P Q c d. apply pack_b_u_p_p_e_e_0_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_u_p_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_u_p_p_e_e X f i P Q c d 1) x y.
let X f i P Q c d. apply pack_b_u_p_p_e_e_1_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> forall x :e X, i x = decode_u (S 2) x.
let S X f i P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_b_u_p_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_b_u_p_p_e_e X f i P Q c d 2) x.
let X f i P Q c d. apply pack_b_u_p_p_e_e_2_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X f i P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_u_p_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_u_p_p_e_e X f i P Q c d 3) x.
let X f i P Q c d. apply pack_b_u_p_p_e_e_3_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X f i P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_u_p_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_b_u_p_p_e_e X f i P Q c d 4) x.
let X f i P Q c d. apply pack_b_u_p_p_e_e_4_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> c = S 5.
let S X f i P Q c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_u_p_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_b_u_p_p_e_e X f i P Q c d 5.
let X f i P Q c d. apply pack_b_u_p_p_e_e_5_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_u_p_p_e_e X f i P Q c d -> d = S 6.
let S X f i P Q c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_u_p_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_b_u_p_p_e_e X f i P Q c d 6.
let X f i P Q c d. apply pack_b_u_p_p_e_e_6_eq (pack_b_u_p_p_e_e X f i P Q c d) X f i P Q c d. reflexivity.
Qed.

Theorem pack_b_u_p_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_b_u_p_p_e_e X f i P Q c d = pack_b_u_p_p_e_e X' f' i' P' Q' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x :e X, i x = i' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' f f' i i' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_b_u_p_p_e_e X f i P Q c d 0.
{ exact pack_b_u_p_p_e_e_0_eq (pack_b_u_p_p_e_e X f i P Q c d) X' f' i' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_u_p_p_e_e_0_eq2 X f i P Q c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_u_p_p_e_e_1_eq2 X f i P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_u_p_p_e_e_1_eq2 X' f' i' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_b_u_p_p_e_e_2_eq2 X f i P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_p_p_e_e_2_eq2 X' f' i' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_u_p_p_e_e_3_eq2 X f i P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_p_p_e_e_3_eq2 X' f' i' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_u_p_p_e_e_4_eq2 X f i P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_u_p_p_e_e_4_eq2 X' f' i' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_u_p_p_e_e_5_eq2 X f i P Q c d.
  rewrite H1. symmetry.
  exact pack_b_u_p_p_e_e_5_eq2 X' f' i' P' Q' c' d'.
- prove d = d'.
  rewrite pack_b_u_p_p_e_e_6_eq2 X f i P Q c d.
  rewrite H1. symmetry.
  exact pack_b_u_p_p_e_e_6_eq2 X' f' i' P' Q' c' d'.
Qed.

Theorem pack_b_u_p_p_e_e_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_u_p_p_e_e X f i P Q c d = pack_b_u_p_p_e_e X f' i' P' Q' c d.
let X f f' i i' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_u X i,encode_p X P,encode_p X Q,c,d) = (X,encode_b X f',encode_u X i',encode_p X P',encode_p X Q',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_u_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_u_p_p_e_e X f i P Q c d)) -> q S.

Theorem pack_struct_b_u_p_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall i:set -> set, (forall x :e X, i x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_u_p_p_e_e (pack_b_u_p_p_e_e X f i P Q c d).
let X f. assume Hf. let i. assume Hi. let P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf i Hi P Q c Hc d Hd.
Qed.

Theorem pack_struct_b_u_p_p_e_e_E1: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_u_p_p_e_e (pack_b_u_p_p_e_e X f i P Q c d) -> forall x y :e X, f x y :e X.
let X f i P Q c d. assume H1. apply H1 (fun z => z = pack_b_u_p_p_e_e X f i P Q c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_p_p_e_e X' f' i' P' Q' c' d' = pack_b_u_p_p_e_e X f i P Q c d.
  apply pack_b_u_p_p_e_e_inj X' X f' f i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_u_p_p_e_e_E2: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_u_p_p_e_e (pack_b_u_p_p_e_e X f i P Q c d) -> forall x :e X, i x :e X.
let X f i P Q c d. assume H1. apply H1 (fun z => z = pack_b_u_p_p_e_e X f i P Q c d -> forall x :e X, i x :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_p_p_e_e X' f' i' P' Q' c' d' = pack_b_u_p_p_e_e X f i P Q c d.
  apply pack_b_u_p_p_e_e_inj X' X f' f i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_b_u_p_p_e_e_E5: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_u_p_p_e_e (pack_b_u_p_p_e_e X f i P Q c d) -> c :e X.
let X f i P Q c d. assume H1. apply H1 (fun z => z = pack_b_u_p_p_e_e X f i P Q c d -> c :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_p_p_e_e X' f' i' P' Q' c' d' = pack_b_u_p_p_e_e X f i P Q c d.
  apply pack_b_u_p_p_e_e_inj X' X f' f i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_u_p_p_e_e_E6: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_u_p_p_e_e (pack_b_u_p_p_e_e X f i P Q c d) -> d :e X.
let X f i P Q c d. assume H1. apply H1 (fun z => z = pack_b_u_p_p_e_e X f i P Q c d -> d :e X).
- let X'. let f'. assume Hf'. let i'. assume Hi'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_u_p_p_e_e X' f' i' P' Q' c' d' = pack_b_u_p_p_e_e X f i P Q c d.
  apply pack_b_u_p_p_e_e_inj X' X f' f i' i P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f Hi'i HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_u_p_p_e_e_eta: forall S, struct_b_u_p_p_e_e S -> S = pack_b_u_p_p_e_e (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_u_p_p_e_e (z 0) (decode_b (z 1)) (decode_u (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let i. assume _. let P. let Q. let c. assume _. let d. assume _.
prove pack_b_u_p_p_e_e X f i P Q c d = pack_b_u_p_p_e_e (pack_b_u_p_p_e_e X f i P Q c d 0) (decode_b (pack_b_u_p_p_e_e X f i P Q c d 1)) (decode_u (pack_b_u_p_p_e_e X f i P Q c d 2)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 3)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 4)) (pack_b_u_p_p_e_e X f i P Q c d 5) (pack_b_u_p_p_e_e X f i P Q c d 6).
rewrite <- pack_b_u_p_p_e_e_0_eq2 X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_5_eq2 X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_6_eq2 X f i P Q c d.
apply pack_b_u_p_p_e_e_ext.
- exact pack_b_u_p_p_e_e_1_eq2 X f i P Q c d.
- exact pack_b_u_p_p_e_e_2_eq2 X f i P Q c d.
- let x. assume Hx.
  rewrite <- pack_b_u_p_p_e_e_3_eq2 X f i P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_u_p_p_e_e_4_eq2 X f i P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_p_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_u_p_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' i' P' Q' c d = Phi X f i P Q c d)
  ->
  unpack_b_u_p_p_e_e_i (pack_b_u_p_p_e_e X f i P Q c d) Phi = Phi X f i P Q c d.
let Phi X f i P Q c d.
assume HPhi.
prove Phi (pack_b_u_p_p_e_e X f i P Q c d 0) (decode_b (pack_b_u_p_p_e_e X f i P Q c d 1)) (decode_u (pack_b_u_p_p_e_e X f i P Q c d 2)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 3)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 4)) (pack_b_u_p_p_e_e X f i P Q c d 5) (pack_b_u_p_p_e_e X f i P Q c d 6) = Phi X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_0_eq2 X f i P Q c d.
prove Phi X (decode_b (pack_b_u_p_p_e_e X f i P Q c d 1)) (decode_u (pack_b_u_p_p_e_e X f i P Q c d 2)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 3)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 4)) (pack_b_u_p_p_e_e X f i P Q c d 5) (pack_b_u_p_p_e_e X f i P Q c d 6) = Phi X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_5_eq2 X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_6_eq2 X f i P Q c d.
apply HPhi.
- exact pack_b_u_p_p_e_e_1_eq2 X f i P Q c d.
- exact pack_b_u_p_p_e_e_2_eq2 X f i P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_p_p_e_e X f i P Q c d 3) x.
  rewrite <- pack_b_u_p_p_e_e_3_eq2 X f i P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_u_p_p_e_e X f i P Q c d 4) x.
  rewrite <- pack_b_u_p_p_e_e_4_eq2 X f i P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_u_p_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_u_p_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i':set -> set, (forall x :e X, i x = i' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' i' P' Q' c d = Phi X f i P Q c d)
  ->
  unpack_b_u_p_p_e_e_o (pack_b_u_p_p_e_e X f i P Q c d) Phi = Phi X f i P Q c d.
let Phi X f i P Q c d.
assume HPhi.
prove Phi (pack_b_u_p_p_e_e X f i P Q c d 0) (decode_b (pack_b_u_p_p_e_e X f i P Q c d 1)) (decode_u (pack_b_u_p_p_e_e X f i P Q c d 2)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 3)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 4)) (pack_b_u_p_p_e_e X f i P Q c d 5) (pack_b_u_p_p_e_e X f i P Q c d 6) = Phi X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_0_eq2 X f i P Q c d.
prove Phi X (decode_b (pack_b_u_p_p_e_e X f i P Q c d 1)) (decode_u (pack_b_u_p_p_e_e X f i P Q c d 2)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 3)) (decode_p (pack_b_u_p_p_e_e X f i P Q c d 4)) (pack_b_u_p_p_e_e X f i P Q c d 5) (pack_b_u_p_p_e_e X f i P Q c d 6) = Phi X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_5_eq2 X f i P Q c d.
rewrite <- pack_b_u_p_p_e_e_6_eq2 X f i P Q c d.
apply HPhi.
- exact pack_b_u_p_p_e_e_1_eq2 X f i P Q c d.
- exact pack_b_u_p_p_e_e_2_eq2 X f i P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_u_p_p_e_e X f i P Q c d 3) x.
  rewrite <- pack_b_u_p_p_e_e_3_eq2 X f i P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_u_p_p_e_e X f i P Q c d 4) x.
  rewrite <- pack_b_u_p_p_e_e_4_eq2 X f i P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_b_r_p_p_e_e : set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X f R P Q c d => (X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d).

Theorem pack_b_r_p_p_e_e_0_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> X = S 0.
let S X f R P Q c d. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_b_r_p_p_e_e_0_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_b_r_p_p_e_e X f R P Q c d 0.
let X f R P Q c d. apply pack_b_r_p_p_e_e_0_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_1_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f R P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_b_r_p_p_e_e_1_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, f x y = decode_b (pack_b_r_p_p_e_e X f R P Q c d 1) x y.
let X f R P Q c d. apply pack_b_r_p_p_e_e_1_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_2_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X f R P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_b_r_p_p_e_e_2_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_b_r_p_p_e_e X f R P Q c d 2) x y.
let X f R P Q c d. apply pack_b_r_p_p_e_e_2_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_3_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X f R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_b_r_p_p_e_e_3_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_b_r_p_p_e_e X f R P Q c d 3) x.
let X f R P Q c d. apply pack_b_r_p_p_e_e_3_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_4_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X f R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_b_r_p_p_e_e_4_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_b_r_p_p_e_e X f R P Q c d 4) x.
let X f R P Q c d. apply pack_b_r_p_p_e_e_4_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_5_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> c = S 5.
let S X f R P Q c d. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_b_r_p_p_e_e_5_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_b_r_p_p_e_e X f R P Q c d 5.
let X f R P Q c d. apply pack_b_r_p_p_e_e_5_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_6_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_b_r_p_p_e_e X f R P Q c d -> d = S 6.
let S X f R P Q c d. assume H1.
rewrite H1. prove d = (X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_b_r_p_p_e_e_6_eq2: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_b_r_p_p_e_e X f R P Q c d 6.
let X f R P Q c d. apply pack_b_r_p_p_e_e_6_eq (pack_b_r_p_p_e_e X f R P Q c d) X f R P Q c d. reflexivity.
Qed.

Theorem pack_b_r_p_p_e_e_inj : forall X X', forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_b_r_p_p_e_e X f R P Q c d = pack_b_r_p_p_e_e X' f' R' P' Q' c' d' -> X = X' /\ (forall x y :e X, f x y = f' x y) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' f f' R R' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_b_r_p_p_e_e X f R P Q c d 0.
{ exact pack_b_r_p_p_e_e_0_eq (pack_b_r_p_p_e_e X f R P Q c d) X' f' R' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_b_r_p_p_e_e_0_eq2 X f R P Q c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove f x y = f' x y.
  rewrite pack_b_r_p_p_e_e_1_eq2 X f R P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_r_p_p_e_e_1_eq2 X' f' R' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_b_r_p_p_e_e_2_eq2 X f R P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_b_r_p_p_e_e_2_eq2 X' f' R' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_b_r_p_p_e_e_3_eq2 X f R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_r_p_p_e_e_3_eq2 X' f' R' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_b_r_p_p_e_e_4_eq2 X f R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_b_r_p_p_e_e_4_eq2 X' f' R' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_b_r_p_p_e_e_5_eq2 X f R P Q c d.
  rewrite H1. symmetry.
  exact pack_b_r_p_p_e_e_5_eq2 X' f' R' P' Q' c' d'.
- prove d = d'.
  rewrite pack_b_r_p_p_e_e_6_eq2 X f R P Q c d.
  rewrite H1. symmetry.
  exact pack_b_r_p_p_e_e_6_eq2 X' f' R' P' Q' c' d'.
Qed.

Theorem pack_b_r_p_p_e_e_ext : forall X, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_b_r_p_p_e_e X f R P Q c d = pack_b_r_p_p_e_e X f' R' P' Q' c d.
let X f f' R R' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_b X f,encode_r X R,encode_p X P,encode_p X Q,c,d) = (X,encode_b X f',encode_r X R',encode_p X P',encode_p X Q',c,d).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_b_r_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_b_r_p_p_e_e X f R P Q c d)) -> q S.

Theorem pack_struct_b_r_p_p_e_e_I: forall X, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_b_r_p_p_e_e (pack_b_r_p_p_e_e X f R P Q c d).
let X f. assume Hf. let R P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X f Hf R P Q c Hc d Hd.
Qed.

Theorem pack_struct_b_r_p_p_e_e_E1: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_r_p_p_e_e (pack_b_r_p_p_e_e X f R P Q c d) -> forall x y :e X, f x y :e X.
let X f R P Q c d. assume H1. apply H1 (fun z => z = pack_b_r_p_p_e_e X f R P Q c d -> forall x y :e X, f x y :e X).
- let X'. let f'. assume Hf'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_r_p_p_e_e X' f' R' P' Q' c' d' = pack_b_r_p_p_e_e X f R P Q c d.
  apply pack_b_r_p_p_e_e_inj X' X f' f R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx. let y. assume Hy.
  rewrite <- Hf'f x Hx y Hy.  exact Hf' x Hx y Hy.
- reflexivity.
Qed.

Theorem pack_struct_b_r_p_p_e_e_E5: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_r_p_p_e_e (pack_b_r_p_p_e_e X f R P Q c d) -> c :e X.
let X f R P Q c d. assume H1. apply H1 (fun z => z = pack_b_r_p_p_e_e X f R P Q c d -> c :e X).
- let X'. let f'. assume Hf'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_r_p_p_e_e X' f' R' P' Q' c' d' = pack_b_r_p_p_e_e X f R P Q c d.
  apply pack_b_r_p_p_e_e_inj X' X f' f R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_b_r_p_p_e_e_E6: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_b_r_p_p_e_e (pack_b_r_p_p_e_e X f R P Q c d) -> d :e X.
let X f R P Q c d. assume H1. apply H1 (fun z => z = pack_b_r_p_p_e_e X f R P Q c d -> d :e X).
- let X'. let f'. assume Hf'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_b_r_p_p_e_e X' f' R' P' Q' c' d' = pack_b_r_p_p_e_e X f R P Q c d.
  apply pack_b_r_p_p_e_e_inj X' X f' f R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hf'f HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_b_r_p_p_e_e_eta: forall S, struct_b_r_p_p_e_e S -> S = pack_b_r_p_p_e_e (S 0) (decode_b (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_b_r_p_p_e_e (z 0) (decode_b (z 1)) (decode_r (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let f. assume _. let R. let P. let Q. let c. assume _. let d. assume _.
prove pack_b_r_p_p_e_e X f R P Q c d = pack_b_r_p_p_e_e (pack_b_r_p_p_e_e X f R P Q c d 0) (decode_b (pack_b_r_p_p_e_e X f R P Q c d 1)) (decode_r (pack_b_r_p_p_e_e X f R P Q c d 2)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 3)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 4)) (pack_b_r_p_p_e_e X f R P Q c d 5) (pack_b_r_p_p_e_e X f R P Q c d 6).
rewrite <- pack_b_r_p_p_e_e_0_eq2 X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_5_eq2 X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_6_eq2 X f R P Q c d.
apply pack_b_r_p_p_e_e_ext.
- exact pack_b_r_p_p_e_e_1_eq2 X f R P Q c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_b_r_p_p_e_e_2_eq2 X f R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_r_p_p_e_e_3_eq2 X f R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_b_r_p_p_e_e_4_eq2 X f R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_r_p_p_e_e_i : set -> (set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_r_p_p_e_e_i_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' R' P' Q' c d = Phi X f R P Q c d)
  ->
  unpack_b_r_p_p_e_e_i (pack_b_r_p_p_e_e X f R P Q c d) Phi = Phi X f R P Q c d.
let Phi X f R P Q c d.
assume HPhi.
prove Phi (pack_b_r_p_p_e_e X f R P Q c d 0) (decode_b (pack_b_r_p_p_e_e X f R P Q c d 1)) (decode_r (pack_b_r_p_p_e_e X f R P Q c d 2)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 3)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 4)) (pack_b_r_p_p_e_e X f R P Q c d 5) (pack_b_r_p_p_e_e X f R P Q c d 6) = Phi X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_0_eq2 X f R P Q c d.
prove Phi X (decode_b (pack_b_r_p_p_e_e X f R P Q c d 1)) (decode_r (pack_b_r_p_p_e_e X f R P Q c d 2)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 3)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 4)) (pack_b_r_p_p_e_e X f R P Q c d 5) (pack_b_r_p_p_e_e X f R P Q c d 6) = Phi X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_5_eq2 X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_6_eq2 X f R P Q c d.
apply HPhi.
- exact pack_b_r_p_p_e_e_1_eq2 X f R P Q c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_r_p_p_e_e X f R P Q c d 2) x y.
  rewrite <- pack_b_r_p_p_e_e_2_eq2 X f R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_r_p_p_e_e X f R P Q c d 3) x.
  rewrite <- pack_b_r_p_p_e_e_3_eq2 X f R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_r_p_p_e_e X f R P Q c d 4) x.
  rewrite <- pack_b_r_p_p_e_e_4_eq2 X f R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_b_r_p_p_e_e_o : set -> (set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_b_r_p_p_e_e_o_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X f' R' P' Q' c d = Phi X f R P Q c d)
  ->
  unpack_b_r_p_p_e_e_o (pack_b_r_p_p_e_e X f R P Q c d) Phi = Phi X f R P Q c d.
let Phi X f R P Q c d.
assume HPhi.
prove Phi (pack_b_r_p_p_e_e X f R P Q c d 0) (decode_b (pack_b_r_p_p_e_e X f R P Q c d 1)) (decode_r (pack_b_r_p_p_e_e X f R P Q c d 2)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 3)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 4)) (pack_b_r_p_p_e_e X f R P Q c d 5) (pack_b_r_p_p_e_e X f R P Q c d 6) = Phi X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_0_eq2 X f R P Q c d.
prove Phi X (decode_b (pack_b_r_p_p_e_e X f R P Q c d 1)) (decode_r (pack_b_r_p_p_e_e X f R P Q c d 2)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 3)) (decode_p (pack_b_r_p_p_e_e X f R P Q c d 4)) (pack_b_r_p_p_e_e X f R P Q c d 5) (pack_b_r_p_p_e_e X f R P Q c d 6) = Phi X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_5_eq2 X f R P Q c d.
rewrite <- pack_b_r_p_p_e_e_6_eq2 X f R P Q c d.
apply HPhi.
- exact pack_b_r_p_p_e_e_1_eq2 X f R P Q c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_b_r_p_p_e_e X f R P Q c d 2) x y.
  rewrite <- pack_b_r_p_p_e_e_2_eq2 X f R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_b_r_p_p_e_e X f R P Q c d 3) x.
  rewrite <- pack_b_r_p_p_e_e_3_eq2 X f R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_b_r_p_p_e_e X f R P Q c d 4) x.
  rewrite <- pack_b_r_p_p_e_e_4_eq2 X f R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_u_u_r_r_p_p : set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set := fun X i j R T P Q => (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q).

Theorem pack_u_u_r_r_p_p_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> X = S 0.
let S X i j R T P Q. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_u_r_r_p_p_0_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, X = pack_u_u_r_r_p_p X i j R T P Q 0.
let X i j R T P Q. apply pack_u_u_r_r_p_p_0_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> forall x :e X, i x = decode_u (S 1) x.
let S X i j R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_u_r_r_p_p_1_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, i x = decode_u (pack_u_u_r_r_p_p X i j R T P Q 1) x.
let X i j R T P Q. apply pack_u_u_r_r_p_p_1_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> forall x :e X, j x = decode_u (S 2) x.
let S X i j R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_u_u_r_r_p_p_2_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, j x = decode_u (pack_u_u_r_r_p_p X i j R T P Q 2) x.
let X i j R T P Q. apply pack_u_u_r_r_p_p_2_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X i j R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_u_u_r_r_p_p_3_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, R x y = decode_r (pack_u_u_r_r_p_p X i j R T P Q 3) x y.
let X i j R T P Q. apply pack_u_u_r_r_p_p_3_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_4_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X i j R T P Q. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_u_u_r_r_p_p_4_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x y :e X, T x y = decode_r (pack_u_u_r_r_p_p X i j R T P Q 4) x y.
let X i j R T P Q. apply pack_u_u_r_r_p_p_4_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_5_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> forall x :e X, P x = decode_p (S 5) x.
let S X i j R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_u_u_r_r_p_p_5_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, P x = decode_p (pack_u_u_r_r_p_p X i j R T P Q 5) x.
let X i j R T P Q. apply pack_u_u_r_r_p_p_5_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_6_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, S = pack_u_u_r_r_p_p X i j R T P Q -> forall x :e X, Q x = decode_p (S 6) x.
let S X i j R T P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) 6) x.
rewrite tuple_7_6_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_u_u_r_r_p_p_6_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall x :e X, Q x = decode_p (pack_u_u_r_r_p_p X i j R T P Q 6) x.
let X i j R T P Q. apply pack_u_u_r_r_p_p_6_eq (pack_u_u_r_r_p_p X i j R T P Q) X i j R T P Q. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_p_inj : forall X X', forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, pack_u_u_r_r_p_p X i j R T P Q = pack_u_u_r_r_p_p X' i' j' R' T' P' Q' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x).
let X X' i i' j j' R R' T T' P P' Q Q'. assume H1.
claim L0: X' = pack_u_u_r_r_p_p X i j R T P Q 0.
{ exact pack_u_u_r_r_p_p_0_eq (pack_u_u_r_r_p_p X i j R T P Q) X' i' j' R' T' P' Q' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_u_r_r_p_p_0_eq2 X i j R T P Q. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_u_r_r_p_p_1_eq2 X i j R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_p_1_eq2 X' i' j' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_u_u_r_r_p_p_2_eq2 X i j R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_p_2_eq2 X' i' j' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_u_u_r_r_p_p_3_eq2 X i j R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_p_3_eq2 X' i' j' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_u_u_r_r_p_p_4_eq2 X i j R T P Q x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_p_4_eq2 X' i' j' R' T' P' Q' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_u_u_r_r_p_p_5_eq2 X i j R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_p_5_eq2 X' i' j' R' T' P' Q' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_u_u_r_r_p_p_6_eq2 X i j R T P Q x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_p_6_eq2 X' i' j' R' T' P' Q' x Lx.
Qed.

Theorem pack_u_u_r_r_p_p_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_u_u_r_r_p_p X i j R T P Q = pack_u_u_r_r_p_p X i' j' R' T' P' Q'.
let X i i' j j' R R' T T' P P' Q Q'. assume H1. assume H2. assume H3. assume H4. assume H5. assume H6.
prove (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,encode_p X Q) = (X,encode_u X i',encode_u X j',encode_r X R',encode_r X T',encode_p X P',encode_p X Q').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
claim L6: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H6. }
rewrite <- L6.
reflexivity.
Qed.

Definition struct_u_u_r_r_p_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, q (pack_u_u_r_r_p_p X i j R T P Q)) -> q S.

Theorem pack_struct_u_u_r_r_p_p_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_u_u_r_r_p_p (pack_u_u_r_r_p_p X i j R T P Q).
let X i. assume Hi. let j. assume Hj. let R T P Q q. assume Hq.
exact Hq X i Hi j Hj R T P Q.
Qed.

Theorem pack_struct_u_u_r_r_p_p_E1: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_u_u_r_r_p_p (pack_u_u_r_r_p_p X i j R T P Q) -> forall x :e X, i x :e X.
let X i j R T P Q. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_p X i j R T P Q -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_u_u_r_r_p_p X' i' j' R' T' P' Q' = pack_u_u_r_r_p_p X i j R T P Q.
  apply pack_u_u_r_r_p_p_inj X' X i' i j' j R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_r_p_p_E2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, struct_u_u_r_r_p_p (pack_u_u_r_r_p_p X i j R T P Q) -> forall x :e X, j x :e X.
let X i j R T P Q. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_p X i j R T P Q -> forall x :e X, j x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let P'. let Q'.
  assume Heq: pack_u_u_r_r_p_p X' i' j' R' T' P' Q' = pack_u_u_r_r_p_p X i j R T P Q.
  apply pack_u_u_r_r_p_p_inj X' X i' i j' j R' R T' T P' P Q' Q Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T HP'P HQ'Q.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem struct_u_u_r_r_p_p_eta: forall S, struct_u_u_r_r_p_p S -> S = pack_u_u_r_r_p_p (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).
let S. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_p (z 0) (decode_u (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (decode_p (z 6))).
let X. let i. assume _. let j. assume _. let R. let T. let P. let Q.
prove pack_u_u_r_r_p_p X i j R T P Q = pack_u_u_r_r_p_p (pack_u_u_r_r_p_p X i j R T P Q 0) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 1)) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 2)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 3)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 4)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 5)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 6)).
rewrite <- pack_u_u_r_r_p_p_0_eq2 X i j R T P Q.
apply pack_u_u_r_r_p_p_ext.
- exact pack_u_u_r_r_p_p_1_eq2 X i j R T P Q.
- exact pack_u_u_r_r_p_p_2_eq2 X i j R T P Q.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_r_p_p_3_eq2 X i j R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_r_p_p_4_eq2 X i j R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_r_r_p_p_5_eq2 X i j R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_r_r_p_p_6_eq2 X i j R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_r_p_p_i : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_u_u_r_r_p_p_i_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' j' R' T' P' Q' = Phi X i j R T P Q)
  ->
  unpack_u_u_r_r_p_p_i (pack_u_u_r_r_p_p X i j R T P Q) Phi = Phi X i j R T P Q.
let Phi X i j R T P Q.
assume HPhi.
prove Phi (pack_u_u_r_r_p_p X i j R T P Q 0) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 1)) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 2)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 3)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 4)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 5)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 6)) = Phi X i j R T P Q.
rewrite <- pack_u_u_r_r_p_p_0_eq2 X i j R T P Q.
prove Phi X (decode_u (pack_u_u_r_r_p_p X i j R T P Q 1)) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 2)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 3)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 4)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 5)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 6)) = Phi X i j R T P Q.
apply HPhi.
- exact pack_u_u_r_r_p_p_1_eq2 X i j R T P Q.
- exact pack_u_u_r_r_p_p_2_eq2 X i j R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_r_p_p X i j R T P Q 3) x y.
  rewrite <- pack_u_u_r_r_p_p_3_eq2 X i j R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_u_u_r_r_p_p X i j R T P Q 4) x y.
  rewrite <- pack_u_u_r_r_p_p_4_eq2 X i j R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_r_p_p X i j R T P Q 5) x.
  rewrite <- pack_u_u_r_r_p_p_5_eq2 X i j R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_u_r_r_p_p X i j R T P Q 6) x.
  rewrite <- pack_u_u_r_r_p_p_6_eq2 X i j R T P Q x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_r_p_p_o : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (decode_p (S 6)).

Theorem unpack_u_u_r_r_p_p_o_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> prop,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' j' R' T' P' Q' = Phi X i j R T P Q)
  ->
  unpack_u_u_r_r_p_p_o (pack_u_u_r_r_p_p X i j R T P Q) Phi = Phi X i j R T P Q.
let Phi X i j R T P Q.
assume HPhi.
prove Phi (pack_u_u_r_r_p_p X i j R T P Q 0) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 1)) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 2)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 3)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 4)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 5)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 6)) = Phi X i j R T P Q.
rewrite <- pack_u_u_r_r_p_p_0_eq2 X i j R T P Q.
prove Phi X (decode_u (pack_u_u_r_r_p_p X i j R T P Q 1)) (decode_u (pack_u_u_r_r_p_p X i j R T P Q 2)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 3)) (decode_r (pack_u_u_r_r_p_p X i j R T P Q 4)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 5)) (decode_p (pack_u_u_r_r_p_p X i j R T P Q 6)) = Phi X i j R T P Q.
apply HPhi.
- exact pack_u_u_r_r_p_p_1_eq2 X i j R T P Q.
- exact pack_u_u_r_r_p_p_2_eq2 X i j R T P Q.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_r_p_p X i j R T P Q 3) x y.
  rewrite <- pack_u_u_r_r_p_p_3_eq2 X i j R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_u_u_r_r_p_p X i j R T P Q 4) x y.
  rewrite <- pack_u_u_r_r_p_p_4_eq2 X i j R T P Q x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_r_p_p X i j R T P Q 5) x.
  rewrite <- pack_u_u_r_r_p_p_5_eq2 X i j R T P Q x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_u_r_r_p_p X i j R T P Q 6) x.
  rewrite <- pack_u_u_r_r_p_p_6_eq2 X i j R T P Q x Hx.
  apply iff_refl.
Qed.


Definition pack_u_u_r_r_p_e : set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X i j R T P c => (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c).

Theorem pack_u_u_r_r_p_e_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> X = S 0.
let S X i j R T P c. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_u_r_r_p_e_0_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, X = pack_u_u_r_r_p_e X i j R T P c 0.
let X i j R T P c. apply pack_u_u_r_r_p_e_0_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> forall x :e X, i x = decode_u (S 1) x.
let S X i j R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_u_r_r_p_e_1_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_u_u_r_r_p_e X i j R T P c 1) x.
let X i j R T P c. apply pack_u_u_r_r_p_e_1_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> forall x :e X, j x = decode_u (S 2) x.
let S X i j R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_u_u_r_r_p_e_2_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, j x = decode_u (pack_u_u_r_r_p_e X i j R T P c 2) x.
let X i j R T P c. apply pack_u_u_r_r_p_e_2_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X i j R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_u_u_r_r_p_e_3_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_u_u_r_r_p_e X i j R T P c 3) x y.
let X i j R T P c. apply pack_u_u_r_r_p_e_3_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_4_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X i j R T P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_u_u_r_r_p_e_4_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x y :e X, T x y = decode_r (pack_u_u_r_r_p_e X i j R T P c 4) x y.
let X i j R T P c. apply pack_u_u_r_r_p_e_4_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_5_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> forall x :e X, P x = decode_p (S 5) x.
let S X i j R T P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_u_u_r_r_p_e_5_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_u_u_r_r_p_e X i j R T P c 5) x.
let X i j R T P c. apply pack_u_u_r_r_p_e_5_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_6_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_u_u_r_r_p_e X i j R T P c -> c = S 6.
let S X i j R T P c. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_u_u_r_r_p_e_6_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c = pack_u_u_r_r_p_e X i j R T P c 6.
let X i j R T P c. apply pack_u_u_r_r_p_e_6_eq (pack_u_u_r_r_p_e X i j R T P c) X i j R T P c. reflexivity.
Qed.

Theorem pack_u_u_r_r_p_e_inj : forall X X', forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c c':set, pack_u_u_r_r_p_e X i j R T P c = pack_u_u_r_r_p_e X' i' j' R' T' P' c' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ c = c'.
let X X' i i' j j' R R' T T' P P' c c'. assume H1.
claim L0: X' = pack_u_u_r_r_p_e X i j R T P c 0.
{ exact pack_u_u_r_r_p_e_0_eq (pack_u_u_r_r_p_e X i j R T P c) X' i' j' R' T' P' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_u_r_r_p_e_0_eq2 X i j R T P c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_u_r_r_p_e_1_eq2 X i j R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_e_1_eq2 X' i' j' R' T' P' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_u_u_r_r_p_e_2_eq2 X i j R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_e_2_eq2 X' i' j' R' T' P' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_u_u_r_r_p_e_3_eq2 X i j R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_e_3_eq2 X' i' j' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_u_u_r_r_p_e_4_eq2 X i j R T P c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_e_4_eq2 X' i' j' R' T' P' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_u_u_r_r_p_e_5_eq2 X i j R T P c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_e_5_eq2 X' i' j' R' T' P' c' x Lx.
- prove c = c'.
  rewrite pack_u_u_r_r_p_e_6_eq2 X i j R T P c.
  rewrite H1. symmetry.
  exact pack_u_u_r_r_p_e_6_eq2 X' i' j' R' T' P' c'.
Qed.

Theorem pack_u_u_r_r_p_e_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_u_u_r_r_p_e X i j R T P c = pack_u_u_r_r_p_e X i' j' R' T' P' c.
let X i i' j j' R R' T T' P P' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,encode_p X P,c) = (X,encode_u X i',encode_u X j',encode_r X R',encode_r X T',encode_p X P',c).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_u_u_r_r_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> q (pack_u_u_r_r_p_e X i j R T P c)) -> q S.

Theorem pack_struct_u_u_r_r_p_e_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_u_u_r_r_p_e (pack_u_u_r_r_p_e X i j R T P c).
let X i. assume Hi. let j. assume Hj. let R T P c. assume Hc. let q. assume Hq.
exact Hq X i Hi j Hj R T P c Hc.
Qed.

Theorem pack_struct_u_u_r_r_p_e_E1: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_u_u_r_r_p_e (pack_u_u_r_r_p_e X i j R T P c) -> forall x :e X, i x :e X.
let X i j R T P c. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_e X i j R T P c -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_u_u_r_r_p_e X' i' j' R' T' P' c' = pack_u_u_r_r_p_e X i j R T P c.
  apply pack_u_u_r_r_p_e_inj X' X i' i j' j R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_r_p_e_E2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_u_u_r_r_p_e (pack_u_u_r_r_p_e X i j R T P c) -> forall x :e X, j x :e X.
let X i j R T P c. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_e X i j R T P c -> forall x :e X, j x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_u_u_r_r_p_e X' i' j' R' T' P' c' = pack_u_u_r_r_p_e X i j R T P c.
  apply pack_u_u_r_r_p_e_inj X' X i' i j' j R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_r_p_e_E6: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set, struct_u_u_r_r_p_e (pack_u_u_r_r_p_e X i j R T P c) -> c :e X.
let X i j R T P c. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_e X i j R T P c -> c :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let P'. let c'. assume Hc'.
  assume Heq: pack_u_u_r_r_p_e X' i' j' R' T' P' c' = pack_u_u_r_r_p_e X i j R T P c.
  apply pack_u_u_r_r_p_e_inj X' X i' i j' j R' R T' T P' P c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T HP'P Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_u_u_r_r_p_e_eta: forall S, struct_u_u_r_r_p_e S -> S = pack_u_u_r_r_p_e (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_u_u_r_r_p_e (z 0) (decode_u (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (decode_p (z 5)) (z 6)).
let X. let i. assume _. let j. assume _. let R. let T. let P. let c. assume _.
prove pack_u_u_r_r_p_e X i j R T P c = pack_u_u_r_r_p_e (pack_u_u_r_r_p_e X i j R T P c 0) (decode_u (pack_u_u_r_r_p_e X i j R T P c 1)) (decode_u (pack_u_u_r_r_p_e X i j R T P c 2)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 3)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 4)) (decode_p (pack_u_u_r_r_p_e X i j R T P c 5)) (pack_u_u_r_r_p_e X i j R T P c 6).
rewrite <- pack_u_u_r_r_p_e_0_eq2 X i j R T P c.
rewrite <- pack_u_u_r_r_p_e_6_eq2 X i j R T P c.
apply pack_u_u_r_r_p_e_ext.
- exact pack_u_u_r_r_p_e_1_eq2 X i j R T P c.
- exact pack_u_u_r_r_p_e_2_eq2 X i j R T P c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_r_p_e_3_eq2 X i j R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_r_p_e_4_eq2 X i j R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_r_r_p_e_5_eq2 X i j R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_r_p_e_i : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_u_u_r_r_p_e_i_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i' j' R' T' P' c = Phi X i j R T P c)
  ->
  unpack_u_u_r_r_p_e_i (pack_u_u_r_r_p_e X i j R T P c) Phi = Phi X i j R T P c.
let Phi X i j R T P c.
assume HPhi.
prove Phi (pack_u_u_r_r_p_e X i j R T P c 0) (decode_u (pack_u_u_r_r_p_e X i j R T P c 1)) (decode_u (pack_u_u_r_r_p_e X i j R T P c 2)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 3)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 4)) (decode_p (pack_u_u_r_r_p_e X i j R T P c 5)) (pack_u_u_r_r_p_e X i j R T P c 6) = Phi X i j R T P c.
rewrite <- pack_u_u_r_r_p_e_0_eq2 X i j R T P c.
prove Phi X (decode_u (pack_u_u_r_r_p_e X i j R T P c 1)) (decode_u (pack_u_u_r_r_p_e X i j R T P c 2)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 3)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 4)) (decode_p (pack_u_u_r_r_p_e X i j R T P c 5)) (pack_u_u_r_r_p_e X i j R T P c 6) = Phi X i j R T P c.
rewrite <- pack_u_u_r_r_p_e_6_eq2 X i j R T P c.
apply HPhi.
- exact pack_u_u_r_r_p_e_1_eq2 X i j R T P c.
- exact pack_u_u_r_r_p_e_2_eq2 X i j R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_r_p_e X i j R T P c 3) x y.
  rewrite <- pack_u_u_r_r_p_e_3_eq2 X i j R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_u_u_r_r_p_e X i j R T P c 4) x y.
  rewrite <- pack_u_u_r_r_p_e_4_eq2 X i j R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_r_p_e X i j R T P c 5) x.
  rewrite <- pack_u_u_r_r_p_e_5_eq2 X i j R T P c x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_r_p_e_o : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_u_u_r_r_p_e_o_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall c:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i' j' R' T' P' c = Phi X i j R T P c)
  ->
  unpack_u_u_r_r_p_e_o (pack_u_u_r_r_p_e X i j R T P c) Phi = Phi X i j R T P c.
let Phi X i j R T P c.
assume HPhi.
prove Phi (pack_u_u_r_r_p_e X i j R T P c 0) (decode_u (pack_u_u_r_r_p_e X i j R T P c 1)) (decode_u (pack_u_u_r_r_p_e X i j R T P c 2)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 3)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 4)) (decode_p (pack_u_u_r_r_p_e X i j R T P c 5)) (pack_u_u_r_r_p_e X i j R T P c 6) = Phi X i j R T P c.
rewrite <- pack_u_u_r_r_p_e_0_eq2 X i j R T P c.
prove Phi X (decode_u (pack_u_u_r_r_p_e X i j R T P c 1)) (decode_u (pack_u_u_r_r_p_e X i j R T P c 2)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 3)) (decode_r (pack_u_u_r_r_p_e X i j R T P c 4)) (decode_p (pack_u_u_r_r_p_e X i j R T P c 5)) (pack_u_u_r_r_p_e X i j R T P c 6) = Phi X i j R T P c.
rewrite <- pack_u_u_r_r_p_e_6_eq2 X i j R T P c.
apply HPhi.
- exact pack_u_u_r_r_p_e_1_eq2 X i j R T P c.
- exact pack_u_u_r_r_p_e_2_eq2 X i j R T P c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_r_p_e X i j R T P c 3) x y.
  rewrite <- pack_u_u_r_r_p_e_3_eq2 X i j R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_u_u_r_r_p_e X i j R T P c 4) x y.
  rewrite <- pack_u_u_r_r_p_e_4_eq2 X i j R T P c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_r_p_e X i j R T P c 5) x.
  rewrite <- pack_u_u_r_r_p_e_5_eq2 X i j R T P c x Hx.
  apply iff_refl.
Qed.


Definition pack_u_u_r_r_e_e : set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set := fun X i j R T c d => (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d).

Theorem pack_u_u_r_r_e_e_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> X = S 0.
let S X i j R T c d. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_u_r_r_e_e_0_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, X = pack_u_u_r_r_e_e X i j R T c d 0.
let X i j R T c d. apply pack_u_u_r_r_e_e_0_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> forall x :e X, i x = decode_u (S 1) x.
let S X i j R T c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_u_r_r_e_e_1_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_u_u_r_r_e_e X i j R T c d 1) x.
let X i j R T c d. apply pack_u_u_r_r_e_e_1_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> forall x :e X, j x = decode_u (S 2) x.
let S X i j R T c d. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_u_u_r_r_e_e_2_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x :e X, j x = decode_u (pack_u_u_r_r_e_e X i j R T c d 2) x.
let X i j R T c d. apply pack_u_u_r_r_e_e_2_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X i j R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_u_u_r_r_e_e_3_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_u_u_r_r_e_e X i j R T c d 3) x y.
let X i j R T c d. apply pack_u_u_r_r_e_e_3_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_4_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> forall x y :e X, T x y = decode_r (S 4) x y.
let S X i j R T c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 4) x y.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_u_u_r_r_e_e_4_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, forall x y :e X, T x y = decode_r (pack_u_u_r_r_e_e X i j R T c d 4) x y.
let X i j R T c d. apply pack_u_u_r_r_e_e_4_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_5_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> c = S 5.
let S X i j R T c d. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_u_u_r_r_e_e_5_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, c = pack_u_u_r_r_e_e X i j R T c d 5.
let X i j R T c d. apply pack_u_u_r_r_e_e_5_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_6_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, S = pack_u_u_r_r_e_e X i j R T c d -> d = S 6.
let S X i j R T c d. assume H1.
rewrite H1. prove d = (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_u_u_r_r_e_e_6_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, d = pack_u_u_r_r_e_e X i j R T c d 6.
let X i j R T c d. apply pack_u_u_r_r_e_e_6_eq (pack_u_u_r_r_e_e X i j R T c d) X i j R T c d. reflexivity.
Qed.

Theorem pack_u_u_r_r_e_e_inj : forall X X', forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c c':set, forall d d':set, pack_u_u_r_r_e_e X i j R T c d = pack_u_u_r_r_e_e X' i' j' R' T' c' d' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ c = c' /\ d = d'.
let X X' i i' j j' R R' T T' c c' d d'. assume H1.
claim L0: X' = pack_u_u_r_r_e_e X i j R T c d 0.
{ exact pack_u_u_r_r_e_e_0_eq (pack_u_u_r_r_e_e X i j R T c d) X' i' j' R' T' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_u_r_r_e_e_0_eq2 X i j R T c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_u_r_r_e_e_1_eq2 X i j R T c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_e_e_1_eq2 X' i' j' R' T' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_u_u_r_r_e_e_2_eq2 X i j R T c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_e_e_2_eq2 X' i' j' R' T' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_u_u_r_r_e_e_3_eq2 X i j R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_e_e_3_eq2 X' i' j' R' T' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_u_u_r_r_e_e_4_eq2 X i j R T c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_r_e_e_4_eq2 X' i' j' R' T' c' d' x Lx y Ly.
- prove c = c'.
  rewrite pack_u_u_r_r_e_e_5_eq2 X i j R T c d.
  rewrite H1. symmetry.
  exact pack_u_u_r_r_e_e_5_eq2 X' i' j' R' T' c' d'.
- prove d = d'.
  rewrite pack_u_u_r_r_e_e_6_eq2 X i j R T c d.
  rewrite H1. symmetry.
  exact pack_u_u_r_r_e_e_6_eq2 X' i' j' R' T' c' d'.
Qed.

Theorem pack_u_u_r_r_e_e_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c, forall d,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_u_u_r_r_e_e X i j R T c d = pack_u_u_r_r_e_e X i' j' R' T' c d.
let X i i' j j' R R' T T' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_u X i,encode_u X j,encode_r X R,encode_r X T,c,d) = (X,encode_u X i',encode_u X j',encode_r X R',encode_r X T',c,d).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_u_u_r_r_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_u_u_r_r_e_e X i j R T c d)) -> q S.

Theorem pack_struct_u_u_r_r_e_e_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_u_u_r_r_e_e (pack_u_u_r_r_e_e X i j R T c d).
let X i. assume Hi. let j. assume Hj. let R T c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X i Hi j Hj R T c Hc d Hd.
Qed.

Theorem pack_struct_u_u_r_r_e_e_E1: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_u_u_r_r_e_e (pack_u_u_r_r_e_e X i j R T c d) -> forall x :e X, i x :e X.
let X i j R T c d. assume H1. apply H1 (fun z => z = pack_u_u_r_r_e_e X i j R T c d -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_r_e_e X' i' j' R' T' c' d' = pack_u_u_r_r_e_e X i j R T c d.
  apply pack_u_u_r_r_e_e_inj X' X i' i j' j R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_r_e_e_E2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_u_u_r_r_e_e (pack_u_u_r_r_e_e X i j R T c d) -> forall x :e X, j x :e X.
let X i j R T c d. assume H1. apply H1 (fun z => z = pack_u_u_r_r_e_e X i j R T c d -> forall x :e X, j x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_r_e_e X' i' j' R' T' c' d' = pack_u_u_r_r_e_e X i j R T c d.
  apply pack_u_u_r_r_e_e_inj X' X i' i j' j R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_r_e_e_E5: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_u_u_r_r_e_e (pack_u_u_r_r_e_e X i j R T c d) -> c :e X.
let X i j R T c d. assume H1. apply H1 (fun z => z = pack_u_u_r_r_e_e X i j R T c d -> c :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_r_e_e X' i' j' R' T' c' d' = pack_u_u_r_r_e_e X i j R T c d.
  apply pack_u_u_r_r_e_e_inj X' X i' i j' j R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_r_e_e_E6: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set, struct_u_u_r_r_e_e (pack_u_u_r_r_e_e X i j R T c d) -> d :e X.
let X i j R T c d. assume H1. apply H1 (fun z => z = pack_u_u_r_r_e_e X i j R T c d -> d :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let T'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_r_e_e X' i' j' R' T' c' d' = pack_u_u_r_r_e_e X i j R T c d.
  apply pack_u_u_r_r_e_e_inj X' X i' i j' j R' R T' T c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HT'T Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_u_u_r_r_e_e_eta: forall S, struct_u_u_r_r_e_e S -> S = pack_u_u_r_r_e_e (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_u_u_r_r_e_e (z 0) (decode_u (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_r (z 4)) (z 5) (z 6)).
let X. let i. assume _. let j. assume _. let R. let T. let c. assume _. let d. assume _.
prove pack_u_u_r_r_e_e X i j R T c d = pack_u_u_r_r_e_e (pack_u_u_r_r_e_e X i j R T c d 0) (decode_u (pack_u_u_r_r_e_e X i j R T c d 1)) (decode_u (pack_u_u_r_r_e_e X i j R T c d 2)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 3)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 4)) (pack_u_u_r_r_e_e X i j R T c d 5) (pack_u_u_r_r_e_e X i j R T c d 6).
rewrite <- pack_u_u_r_r_e_e_0_eq2 X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_5_eq2 X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_6_eq2 X i j R T c d.
apply pack_u_u_r_r_e_e_ext.
- exact pack_u_u_r_r_e_e_1_eq2 X i j R T c d.
- exact pack_u_u_r_r_e_e_2_eq2 X i j R T c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_r_e_e_3_eq2 X i j R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_r_e_e_4_eq2 X i j R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_r_e_e_i : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_u_u_r_r_e_e_i_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> set,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X i' j' R' T' c d = Phi X i j R T c d)
  ->
  unpack_u_u_r_r_e_e_i (pack_u_u_r_r_e_e X i j R T c d) Phi = Phi X i j R T c d.
let Phi X i j R T c d.
assume HPhi.
prove Phi (pack_u_u_r_r_e_e X i j R T c d 0) (decode_u (pack_u_u_r_r_e_e X i j R T c d 1)) (decode_u (pack_u_u_r_r_e_e X i j R T c d 2)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 3)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 4)) (pack_u_u_r_r_e_e X i j R T c d 5) (pack_u_u_r_r_e_e X i j R T c d 6) = Phi X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_0_eq2 X i j R T c d.
prove Phi X (decode_u (pack_u_u_r_r_e_e X i j R T c d 1)) (decode_u (pack_u_u_r_r_e_e X i j R T c d 2)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 3)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 4)) (pack_u_u_r_r_e_e X i j R T c d 5) (pack_u_u_r_r_e_e X i j R T c d 6) = Phi X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_5_eq2 X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_6_eq2 X i j R T c d.
apply HPhi.
- exact pack_u_u_r_r_e_e_1_eq2 X i j R T c d.
- exact pack_u_u_r_r_e_e_2_eq2 X i j R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_r_e_e X i j R T c d 3) x y.
  rewrite <- pack_u_u_r_r_e_e_3_eq2 X i j R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_u_u_r_r_e_e X i j R T c d 4) x y.
  rewrite <- pack_u_u_r_r_e_e_4_eq2 X i j R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_r_e_e_o : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_r (S 4)) (S 5) (S 6).

Theorem unpack_u_u_r_r_e_e_o_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set -> prop,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X i' j' R' T' c d = Phi X i j R T c d)
  ->
  unpack_u_u_r_r_e_e_o (pack_u_u_r_r_e_e X i j R T c d) Phi = Phi X i j R T c d.
let Phi X i j R T c d.
assume HPhi.
prove Phi (pack_u_u_r_r_e_e X i j R T c d 0) (decode_u (pack_u_u_r_r_e_e X i j R T c d 1)) (decode_u (pack_u_u_r_r_e_e X i j R T c d 2)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 3)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 4)) (pack_u_u_r_r_e_e X i j R T c d 5) (pack_u_u_r_r_e_e X i j R T c d 6) = Phi X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_0_eq2 X i j R T c d.
prove Phi X (decode_u (pack_u_u_r_r_e_e X i j R T c d 1)) (decode_u (pack_u_u_r_r_e_e X i j R T c d 2)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 3)) (decode_r (pack_u_u_r_r_e_e X i j R T c d 4)) (pack_u_u_r_r_e_e X i j R T c d 5) (pack_u_u_r_r_e_e X i j R T c d 6) = Phi X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_5_eq2 X i j R T c d.
rewrite <- pack_u_u_r_r_e_e_6_eq2 X i j R T c d.
apply HPhi.
- exact pack_u_u_r_r_e_e_1_eq2 X i j R T c d.
- exact pack_u_u_r_r_e_e_2_eq2 X i j R T c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_r_e_e X i j R T c d 3) x y.
  rewrite <- pack_u_u_r_r_e_e_3_eq2 X i j R T c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_u_u_r_r_e_e X i j R T c d 4) x y.
  rewrite <- pack_u_u_r_r_e_e_4_eq2 X i j R T c d x Hx y Hy.
  apply iff_refl.
Qed.


Definition pack_u_u_r_p_p_e : set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set := fun X i j R P Q c => (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c).

Theorem pack_u_u_r_p_p_e_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> X = S 0.
let S X i j R P Q c. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_u_r_p_p_e_0_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, X = pack_u_u_r_p_p_e X i j R P Q c 0.
let X i j R P Q c. apply pack_u_u_r_p_p_e_0_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> forall x :e X, i x = decode_u (S 1) x.
let S X i j R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_u_r_p_p_e_1_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, i x = decode_u (pack_u_u_r_p_p_e X i j R P Q c 1) x.
let X i j R P Q c. apply pack_u_u_r_p_p_e_1_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> forall x :e X, j x = decode_u (S 2) x.
let S X i j R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_u_u_r_p_p_e_2_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, j x = decode_u (pack_u_u_r_p_p_e X i j R P Q c 2) x.
let X i j R P Q c. apply pack_u_u_r_p_p_e_2_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X i j R P Q c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_u_u_r_p_p_e_3_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x y :e X, R x y = decode_r (pack_u_u_r_p_p_e X i j R P Q c 3) x y.
let X i j R P Q c. apply pack_u_u_r_p_p_e_3_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_4_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> forall x :e X, P x = decode_p (S 4) x.
let S X i j R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_u_u_r_p_p_e_4_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, P x = decode_p (pack_u_u_r_p_p_e X i j R P Q c 4) x.
let X i j R P Q c. apply pack_u_u_r_p_p_e_4_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_5_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> forall x :e X, Q x = decode_p (S 5) x.
let S X i j R P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 5) x.
rewrite tuple_7_5_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_u_u_r_p_p_e_5_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall x :e X, Q x = decode_p (pack_u_u_r_p_p_e X i j R P Q c 5) x.
let X i j R P Q c. apply pack_u_u_r_p_p_e_5_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_6_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_u_u_r_p_p_e X i j R P Q c -> c = S 6.
let S X i j R P Q c. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_u_u_r_p_p_e_6_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c = pack_u_u_r_p_p_e X i j R P Q c 6.
let X i j R P Q c. apply pack_u_u_r_p_p_e_6_eq (pack_u_u_r_p_p_e X i j R P Q c) X i j R P Q c. reflexivity.
Qed.

Theorem pack_u_u_r_p_p_e_inj : forall X X', forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, pack_u_u_r_p_p_e X i j R P Q c = pack_u_u_r_p_p_e X' i' j' R' P' Q' c' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c'.
let X X' i i' j j' R R' P P' Q Q' c c'. assume H1.
claim L0: X' = pack_u_u_r_p_p_e X i j R P Q c 0.
{ exact pack_u_u_r_p_p_e_0_eq (pack_u_u_r_p_p_e X i j R P Q c) X' i' j' R' P' Q' c' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_u_r_p_p_e_0_eq2 X i j R P Q c. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_u_r_p_p_e_1_eq2 X i j R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_p_e_1_eq2 X' i' j' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_u_u_r_p_p_e_2_eq2 X i j R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_p_e_2_eq2 X' i' j' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_u_u_r_p_p_e_3_eq2 X i j R P Q c x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_p_e_3_eq2 X' i' j' R' P' Q' c' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_u_u_r_p_p_e_4_eq2 X i j R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_p_e_4_eq2 X' i' j' R' P' Q' c' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_u_u_r_p_p_e_5_eq2 X i j R P Q c x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_p_e_5_eq2 X' i' j' R' P' Q' c' x Lx.
- prove c = c'.
  rewrite pack_u_u_r_p_p_e_6_eq2 X i j R P Q c.
  rewrite H1. symmetry.
  exact pack_u_u_r_p_p_e_6_eq2 X' i' j' R' P' Q' c'.
Qed.

Theorem pack_u_u_r_p_p_e_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_u_u_r_p_p_e X i j R P Q c = pack_u_u_r_p_p_e X i' j' R' P' Q' c.
let X i i' j j' R R' P P' Q Q' c. assume H1. assume H2. assume H3. assume H4. assume H5.
prove (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,encode_p X Q,c) = (X,encode_u X i',encode_u X j',encode_r X R',encode_p X P',encode_p X Q',c).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
claim L5: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H5. }
rewrite <- L5.
reflexivity.
Qed.

Definition struct_u_u_r_p_p_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> q (pack_u_u_r_p_p_e X i j R P Q c)) -> q S.

Theorem pack_struct_u_u_r_p_p_e_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_u_u_r_p_p_e (pack_u_u_r_p_p_e X i j R P Q c).
let X i. assume Hi. let j. assume Hj. let R P Q c. assume Hc. let q. assume Hq.
exact Hq X i Hi j Hj R P Q c Hc.
Qed.

Theorem pack_struct_u_u_r_p_p_e_E1: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_u_u_r_p_p_e (pack_u_u_r_p_p_e X i j R P Q c) -> forall x :e X, i x :e X.
let X i j R P Q c. assume H1. apply H1 (fun z => z = pack_u_u_r_p_p_e X i j R P Q c -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_u_u_r_p_p_e X' i' j' R' P' Q' c' = pack_u_u_r_p_p_e X i j R P Q c.
  apply pack_u_u_r_p_p_e_inj X' X i' i j' j R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_p_p_e_E2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_u_u_r_p_p_e (pack_u_u_r_p_p_e X i j R P Q c) -> forall x :e X, j x :e X.
let X i j R P Q c. assume H1. apply H1 (fun z => z = pack_u_u_r_p_p_e X i j R P Q c -> forall x :e X, j x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_u_u_r_p_p_e X' i' j' R' P' Q' c' = pack_u_u_r_p_p_e X i j R P Q c.
  apply pack_u_u_r_p_p_e_inj X' X i' i j' j R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_p_p_e_E6: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, struct_u_u_r_p_p_e (pack_u_u_r_p_p_e X i j R P Q c) -> c :e X.
let X i j R P Q c. assume H1. apply H1 (fun z => z = pack_u_u_r_p_p_e X i j R P Q c -> c :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let Q'. let c'. assume Hc'.
  assume Heq: pack_u_u_r_p_p_e X' i' j' R' P' Q' c' = pack_u_u_r_p_p_e X i j R P Q c.
  apply pack_u_u_r_p_p_e_inj X' X i' i j' j R' R P' P Q' Q c' c Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P HQ'Q Hc'c.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem struct_u_u_r_p_p_e_eta: forall S, struct_u_u_r_p_p_e S -> S = pack_u_u_r_p_p_e (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_u_u_r_p_p_e (z 0) (decode_u (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_p (z 4)) (decode_p (z 5)) (z 6)).
let X. let i. assume _. let j. assume _. let R. let P. let Q. let c. assume _.
prove pack_u_u_r_p_p_e X i j R P Q c = pack_u_u_r_p_p_e (pack_u_u_r_p_p_e X i j R P Q c 0) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 1)) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 2)) (decode_r (pack_u_u_r_p_p_e X i j R P Q c 3)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 4)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 5)) (pack_u_u_r_p_p_e X i j R P Q c 6).
rewrite <- pack_u_u_r_p_p_e_0_eq2 X i j R P Q c.
rewrite <- pack_u_u_r_p_p_e_6_eq2 X i j R P Q c.
apply pack_u_u_r_p_p_e_ext.
- exact pack_u_u_r_p_p_e_1_eq2 X i j R P Q c.
- exact pack_u_u_r_p_p_e_2_eq2 X i j R P Q c.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_p_p_e_3_eq2 X i j R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_r_p_p_e_4_eq2 X i j R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_r_p_p_e_5_eq2 X i j R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_p_p_e_i : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_u_u_r_p_p_e_i_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' j' R' P' Q' c = Phi X i j R P Q c)
  ->
  unpack_u_u_r_p_p_e_i (pack_u_u_r_p_p_e X i j R P Q c) Phi = Phi X i j R P Q c.
let Phi X i j R P Q c.
assume HPhi.
prove Phi (pack_u_u_r_p_p_e X i j R P Q c 0) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 1)) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 2)) (decode_r (pack_u_u_r_p_p_e X i j R P Q c 3)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 4)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 5)) (pack_u_u_r_p_p_e X i j R P Q c 6) = Phi X i j R P Q c.
rewrite <- pack_u_u_r_p_p_e_0_eq2 X i j R P Q c.
prove Phi X (decode_u (pack_u_u_r_p_p_e X i j R P Q c 1)) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 2)) (decode_r (pack_u_u_r_p_p_e X i j R P Q c 3)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 4)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 5)) (pack_u_u_r_p_p_e X i j R P Q c 6) = Phi X i j R P Q c.
rewrite <- pack_u_u_r_p_p_e_6_eq2 X i j R P Q c.
apply HPhi.
- exact pack_u_u_r_p_p_e_1_eq2 X i j R P Q c.
- exact pack_u_u_r_p_p_e_2_eq2 X i j R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_p_p_e X i j R P Q c 3) x y.
  rewrite <- pack_u_u_r_p_p_e_3_eq2 X i j R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_p_p_e X i j R P Q c 4) x.
  rewrite <- pack_u_u_r_p_p_e_4_eq2 X i j R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_u_r_p_p_e X i j R P Q c 5) x.
  rewrite <- pack_u_u_r_p_p_e_5_eq2 X i j R P Q c x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_p_p_e_o : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (decode_p (S 5)) (S 6).

Theorem unpack_u_u_r_p_p_e_o_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> prop,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' j' R' P' Q' c = Phi X i j R P Q c)
  ->
  unpack_u_u_r_p_p_e_o (pack_u_u_r_p_p_e X i j R P Q c) Phi = Phi X i j R P Q c.
let Phi X i j R P Q c.
assume HPhi.
prove Phi (pack_u_u_r_p_p_e X i j R P Q c 0) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 1)) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 2)) (decode_r (pack_u_u_r_p_p_e X i j R P Q c 3)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 4)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 5)) (pack_u_u_r_p_p_e X i j R P Q c 6) = Phi X i j R P Q c.
rewrite <- pack_u_u_r_p_p_e_0_eq2 X i j R P Q c.
prove Phi X (decode_u (pack_u_u_r_p_p_e X i j R P Q c 1)) (decode_u (pack_u_u_r_p_p_e X i j R P Q c 2)) (decode_r (pack_u_u_r_p_p_e X i j R P Q c 3)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 4)) (decode_p (pack_u_u_r_p_p_e X i j R P Q c 5)) (pack_u_u_r_p_p_e X i j R P Q c 6) = Phi X i j R P Q c.
rewrite <- pack_u_u_r_p_p_e_6_eq2 X i j R P Q c.
apply HPhi.
- exact pack_u_u_r_p_p_e_1_eq2 X i j R P Q c.
- exact pack_u_u_r_p_p_e_2_eq2 X i j R P Q c.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_p_p_e X i j R P Q c 3) x y.
  rewrite <- pack_u_u_r_p_p_e_3_eq2 X i j R P Q c x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_p_p_e X i j R P Q c 4) x.
  rewrite <- pack_u_u_r_p_p_e_4_eq2 X i j R P Q c x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_u_r_p_p_e X i j R P Q c 5) x.
  rewrite <- pack_u_u_r_p_p_e_5_eq2 X i j R P Q c x Hx.
  apply iff_refl.
Qed.


Definition pack_u_u_r_p_e_e : set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set := fun X i j R P c d => (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d).

Theorem pack_u_u_r_p_e_e_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> X = S 0.
let S X i j R P c d. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_u_r_p_e_e_0_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, X = pack_u_u_r_p_e_e X i j R P c d 0.
let X i j R P c d. apply pack_u_u_r_p_e_e_0_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> forall x :e X, i x = decode_u (S 1) x.
let S X i j R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_u_r_p_e_e_1_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_u_u_r_p_e_e X i j R P c d 1) x.
let X i j R P c d. apply pack_u_u_r_p_e_e_1_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> forall x :e X, j x = decode_u (S 2) x.
let S X i j R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_u_u_r_p_e_e_2_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, j x = decode_u (pack_u_u_r_p_e_e X i j R P c d 2) x.
let X i j R P c d. apply pack_u_u_r_p_e_e_2_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X i j R P c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 3) x y.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_u_u_r_p_e_e_3_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_u_u_r_p_e_e X i j R P c d 3) x y.
let X i j R P c d. apply pack_u_u_r_p_e_e_3_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_4_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> forall x :e X, P x = decode_p (S 4) x.
let S X i j R P c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_u_u_r_p_e_e_4_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_u_u_r_p_e_e X i j R P c d 4) x.
let X i j R P c d. apply pack_u_u_r_p_e_e_4_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_5_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> c = S 5.
let S X i j R P c d. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_u_u_r_p_e_e_5_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, c = pack_u_u_r_p_e_e X i j R P c d 5.
let X i j R P c d. apply pack_u_u_r_p_e_e_5_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_6_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, S = pack_u_u_r_p_e_e X i j R P c d -> d = S 6.
let S X i j R P c d. assume H1.
rewrite H1. prove d = (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_u_u_r_p_e_e_6_eq2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, d = pack_u_u_r_p_e_e X i j R P c d 6.
let X i j R P c d. apply pack_u_u_r_p_e_e_6_eq (pack_u_u_r_p_e_e X i j R P c d) X i j R P c d. reflexivity.
Qed.

Theorem pack_u_u_r_p_e_e_inj : forall X X', forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c c':set, forall d d':set, pack_u_u_r_p_e_e X i j R P c d = pack_u_u_r_p_e_e X' i' j' R' P' c' d' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ c = c' /\ d = d'.
let X X' i i' j j' R R' P P' c c' d d'. assume H1.
claim L0: X' = pack_u_u_r_p_e_e X i j R P c d 0.
{ exact pack_u_u_r_p_e_e_0_eq (pack_u_u_r_p_e_e X i j R P c d) X' i' j' R' P' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_u_r_p_e_e_0_eq2 X i j R P c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_u_r_p_e_e_1_eq2 X i j R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_e_e_1_eq2 X' i' j' R' P' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_u_u_r_p_e_e_2_eq2 X i j R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_e_e_2_eq2 X' i' j' R' P' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_u_u_r_p_e_e_3_eq2 X i j R P c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_e_e_3_eq2 X' i' j' R' P' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_u_u_r_p_e_e_4_eq2 X i j R P c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_r_p_e_e_4_eq2 X' i' j' R' P' c' d' x Lx.
- prove c = c'.
  rewrite pack_u_u_r_p_e_e_5_eq2 X i j R P c d.
  rewrite H1. symmetry.
  exact pack_u_u_r_p_e_e_5_eq2 X' i' j' R' P' c' d'.
- prove d = d'.
  rewrite pack_u_u_r_p_e_e_6_eq2 X i j R P c d.
  rewrite H1. symmetry.
  exact pack_u_u_r_p_e_e_6_eq2 X' i' j' R' P' c' d'.
Qed.

Theorem pack_u_u_r_p_e_e_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall c, forall d,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_u_u_r_p_e_e X i j R P c d = pack_u_u_r_p_e_e X i' j' R' P' c d.
let X i i' j j' R R' P P' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_u X i,encode_u X j,encode_r X R,encode_p X P,c,d) = (X,encode_u X i',encode_u X j',encode_r X R',encode_p X P',c,d).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_u_u_r_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_u_u_r_p_e_e X i j R P c d)) -> q S.

Theorem pack_struct_u_u_r_p_e_e_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_u_u_r_p_e_e (pack_u_u_r_p_e_e X i j R P c d).
let X i. assume Hi. let j. assume Hj. let R P c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X i Hi j Hj R P c Hc d Hd.
Qed.

Theorem pack_struct_u_u_r_p_e_e_E1: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_u_u_r_p_e_e (pack_u_u_r_p_e_e X i j R P c d) -> forall x :e X, i x :e X.
let X i j R P c d. assume H1. apply H1 (fun z => z = pack_u_u_r_p_e_e X i j R P c d -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_p_e_e X' i' j' R' P' c' d' = pack_u_u_r_p_e_e X i j R P c d.
  apply pack_u_u_r_p_e_e_inj X' X i' i j' j R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_p_e_e_E2: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_u_u_r_p_e_e (pack_u_u_r_p_e_e X i j R P c d) -> forall x :e X, j x :e X.
let X i j R P c d. assume H1. apply H1 (fun z => z = pack_u_u_r_p_e_e X i j R P c d -> forall x :e X, j x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_p_e_e X' i' j' R' P' c' d' = pack_u_u_r_p_e_e X i j R P c d.
  apply pack_u_u_r_p_e_e_inj X' X i' i j' j R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_p_e_e_E5: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_u_u_r_p_e_e (pack_u_u_r_p_e_e X i j R P c d) -> c :e X.
let X i j R P c d. assume H1. apply H1 (fun z => z = pack_u_u_r_p_e_e X i j R P c d -> c :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_p_e_e X' i' j' R' P' c' d' = pack_u_u_r_p_e_e X i j R P c d.
  apply pack_u_u_r_p_e_e_inj X' X i' i j' j R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_u_u_r_p_e_e_E6: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set, struct_u_u_r_p_e_e (pack_u_u_r_p_e_e X i j R P c d) -> d :e X.
let X i j R P c d. assume H1. apply H1 (fun z => z = pack_u_u_r_p_e_e X i j R P c d -> d :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let R'. let P'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_r_p_e_e X' i' j' R' P' c' d' = pack_u_u_r_p_e_e X i j R P c d.
  apply pack_u_u_r_p_e_e_inj X' X i' i j' j R' R P' P c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HR'R HP'P Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_u_u_r_p_e_e_eta: forall S, struct_u_u_r_p_e_e S -> S = pack_u_u_r_p_e_e (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_u_u_r_p_e_e (z 0) (decode_u (z 1)) (decode_u (z 2)) (decode_r (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let i. assume _. let j. assume _. let R. let P. let c. assume _. let d. assume _.
prove pack_u_u_r_p_e_e X i j R P c d = pack_u_u_r_p_e_e (pack_u_u_r_p_e_e X i j R P c d 0) (decode_u (pack_u_u_r_p_e_e X i j R P c d 1)) (decode_u (pack_u_u_r_p_e_e X i j R P c d 2)) (decode_r (pack_u_u_r_p_e_e X i j R P c d 3)) (decode_p (pack_u_u_r_p_e_e X i j R P c d 4)) (pack_u_u_r_p_e_e X i j R P c d 5) (pack_u_u_r_p_e_e X i j R P c d 6).
rewrite <- pack_u_u_r_p_e_e_0_eq2 X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_5_eq2 X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_6_eq2 X i j R P c d.
apply pack_u_u_r_p_e_e_ext.
- exact pack_u_u_r_p_e_e_1_eq2 X i j R P c d.
- exact pack_u_u_r_p_e_e_2_eq2 X i j R P c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_u_r_p_e_e_3_eq2 X i j R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_r_p_e_e_4_eq2 X i j R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_p_e_e_i : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_u_u_r_p_e_e_i_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i' j' R' P' c d = Phi X i j R P c d)
  ->
  unpack_u_u_r_p_e_e_i (pack_u_u_r_p_e_e X i j R P c d) Phi = Phi X i j R P c d.
let Phi X i j R P c d.
assume HPhi.
prove Phi (pack_u_u_r_p_e_e X i j R P c d 0) (decode_u (pack_u_u_r_p_e_e X i j R P c d 1)) (decode_u (pack_u_u_r_p_e_e X i j R P c d 2)) (decode_r (pack_u_u_r_p_e_e X i j R P c d 3)) (decode_p (pack_u_u_r_p_e_e X i j R P c d 4)) (pack_u_u_r_p_e_e X i j R P c d 5) (pack_u_u_r_p_e_e X i j R P c d 6) = Phi X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_0_eq2 X i j R P c d.
prove Phi X (decode_u (pack_u_u_r_p_e_e X i j R P c d 1)) (decode_u (pack_u_u_r_p_e_e X i j R P c d 2)) (decode_r (pack_u_u_r_p_e_e X i j R P c d 3)) (decode_p (pack_u_u_r_p_e_e X i j R P c d 4)) (pack_u_u_r_p_e_e X i j R P c d 5) (pack_u_u_r_p_e_e X i j R P c d 6) = Phi X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_5_eq2 X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_6_eq2 X i j R P c d.
apply HPhi.
- exact pack_u_u_r_p_e_e_1_eq2 X i j R P c d.
- exact pack_u_u_r_p_e_e_2_eq2 X i j R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_p_e_e X i j R P c d 3) x y.
  rewrite <- pack_u_u_r_p_e_e_3_eq2 X i j R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_p_e_e X i j R P c d 4) x.
  rewrite <- pack_u_u_r_p_e_e_4_eq2 X i j R P c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_r_p_e_e_o : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_u_u_r_p_e_e_o_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i' j' R' P' c d = Phi X i j R P c d)
  ->
  unpack_u_u_r_p_e_e_o (pack_u_u_r_p_e_e X i j R P c d) Phi = Phi X i j R P c d.
let Phi X i j R P c d.
assume HPhi.
prove Phi (pack_u_u_r_p_e_e X i j R P c d 0) (decode_u (pack_u_u_r_p_e_e X i j R P c d 1)) (decode_u (pack_u_u_r_p_e_e X i j R P c d 2)) (decode_r (pack_u_u_r_p_e_e X i j R P c d 3)) (decode_p (pack_u_u_r_p_e_e X i j R P c d 4)) (pack_u_u_r_p_e_e X i j R P c d 5) (pack_u_u_r_p_e_e X i j R P c d 6) = Phi X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_0_eq2 X i j R P c d.
prove Phi X (decode_u (pack_u_u_r_p_e_e X i j R P c d 1)) (decode_u (pack_u_u_r_p_e_e X i j R P c d 2)) (decode_r (pack_u_u_r_p_e_e X i j R P c d 3)) (decode_p (pack_u_u_r_p_e_e X i j R P c d 4)) (pack_u_u_r_p_e_e X i j R P c d 5) (pack_u_u_r_p_e_e X i j R P c d 6) = Phi X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_5_eq2 X i j R P c d.
rewrite <- pack_u_u_r_p_e_e_6_eq2 X i j R P c d.
apply HPhi.
- exact pack_u_u_r_p_e_e_1_eq2 X i j R P c d.
- exact pack_u_u_r_p_e_e_2_eq2 X i j R P c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_u_r_p_e_e X i j R P c d 3) x y.
  rewrite <- pack_u_u_r_p_e_e_3_eq2 X i j R P c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_r_p_e_e X i j R P c d 4) x.
  rewrite <- pack_u_u_r_p_e_e_4_eq2 X i j R P c d x Hx.
  apply iff_refl.
Qed.


Definition pack_u_u_p_p_e_e : set -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X i j P Q c d => (X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d).

Theorem pack_u_u_p_p_e_e_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> X = S 0.
let S X i j P Q c d. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_u_p_p_e_e_0_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_u_u_p_p_e_e X i j P Q c d 0.
let X i j P Q c d. apply pack_u_u_p_p_e_e_0_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> forall x :e X, i x = decode_u (S 1) x.
let S X i j P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_u_p_p_e_e_1_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_u_u_p_p_e_e X i j P Q c d 1) x.
let X i j P Q c d. apply pack_u_u_p_p_e_e_1_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> forall x :e X, j x = decode_u (S 2) x.
let S X i j P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 2) x.
rewrite tuple_7_2_eq.
symmetry. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_u_u_p_p_e_e_2_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, j x = decode_u (pack_u_u_p_p_e_e X i j P Q c d 2) x.
let X i j P Q c d. apply pack_u_u_p_p_e_e_2_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X i j P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_u_u_p_p_e_e_3_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_u_u_p_p_e_e X i j P Q c d 3) x.
let X i j P Q c d. apply pack_u_u_p_p_e_e_3_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_4_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X i j P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_u_u_p_p_e_e_4_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_u_u_p_p_e_e X i j P Q c d 4) x.
let X i j P Q c d. apply pack_u_u_p_p_e_e_4_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_5_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> c = S 5.
let S X i j P Q c d. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_u_u_p_p_e_e_5_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_u_u_p_p_e_e X i j P Q c d 5.
let X i j P Q c d. apply pack_u_u_p_p_e_e_5_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_6_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_u_p_p_e_e X i j P Q c d -> d = S 6.
let S X i j P Q c d. assume H1.
rewrite H1. prove d = (X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_u_u_p_p_e_e_6_eq2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_u_u_p_p_e_e X i j P Q c d 6.
let X i j P Q c d. apply pack_u_u_p_p_e_e_6_eq (pack_u_u_p_p_e_e X i j P Q c d) X i j P Q c d. reflexivity.
Qed.

Theorem pack_u_u_p_p_e_e_inj : forall X X', forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_u_u_p_p_e_e X i j P Q c d = pack_u_u_p_p_e_e X' i' j' P' Q' c' d' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x :e X, j x = j' x) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' i i' j j' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_u_u_p_p_e_e X i j P Q c d 0.
{ exact pack_u_u_p_p_e_e_0_eq (pack_u_u_p_p_e_e X i j P Q c d) X' i' j' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_u_p_p_e_e_0_eq2 X i j P Q c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_u_p_p_e_e_1_eq2 X i j P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_p_p_e_e_1_eq2 X' i' j' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove j x = j' x.
  rewrite pack_u_u_p_p_e_e_2_eq2 X i j P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_p_p_e_e_2_eq2 X' i' j' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_u_u_p_p_e_e_3_eq2 X i j P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_p_p_e_e_3_eq2 X' i' j' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_u_u_p_p_e_e_4_eq2 X i j P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_u_p_p_e_e_4_eq2 X' i' j' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_u_u_p_p_e_e_5_eq2 X i j P Q c d.
  rewrite H1. symmetry.
  exact pack_u_u_p_p_e_e_5_eq2 X' i' j' P' Q' c' d'.
- prove d = d'.
  rewrite pack_u_u_p_p_e_e_6_eq2 X i j P Q c d.
  rewrite H1. symmetry.
  exact pack_u_u_p_p_e_e_6_eq2 X' i' j' P' Q' c' d'.
Qed.

Theorem pack_u_u_p_p_e_e_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_u_u_p_p_e_e X i j P Q c d = pack_u_u_p_p_e_e X i' j' P' Q' c d.
let X i i' j j' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_u X i,encode_u X j,encode_p X P,encode_p X Q,c,d) = (X,encode_u X i',encode_u X j',encode_p X P',encode_p X Q',c,d).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_u_u_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_u_u_p_p_e_e X i j P Q c d)) -> q S.

Theorem pack_struct_u_u_p_p_e_e_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall j:set -> set, (forall x :e X, j x :e X) -> forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_u_u_p_p_e_e (pack_u_u_p_p_e_e X i j P Q c d).
let X i. assume Hi. let j. assume Hj. let P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X i Hi j Hj P Q c Hc d Hd.
Qed.

Theorem pack_struct_u_u_p_p_e_e_E1: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_u_p_p_e_e (pack_u_u_p_p_e_e X i j P Q c d) -> forall x :e X, i x :e X.
let X i j P Q c d. assume H1. apply H1 (fun z => z = pack_u_u_p_p_e_e X i j P Q c d -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_p_p_e_e X' i' j' P' Q' c' d' = pack_u_u_p_p_e_e X i j P Q c d.
  apply pack_u_u_p_p_e_e_inj X' X i' i j' j P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_p_p_e_e_E2: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_u_p_p_e_e (pack_u_u_p_p_e_e X i j P Q c d) -> forall x :e X, j x :e X.
let X i j P Q c d. assume H1. apply H1 (fun z => z = pack_u_u_p_p_e_e X i j P Q c d -> forall x :e X, j x :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_p_p_e_e X' i' j' P' Q' c' d' = pack_u_u_p_p_e_e X i j P Q c d.
  apply pack_u_u_p_p_e_e_inj X' X i' i j' j P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hj'j x Hx.  exact Hj' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_u_p_p_e_e_E5: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_u_p_p_e_e (pack_u_u_p_p_e_e X i j P Q c d) -> c :e X.
let X i j P Q c d. assume H1. apply H1 (fun z => z = pack_u_u_p_p_e_e X i j P Q c d -> c :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_p_p_e_e X' i' j' P' Q' c' d' = pack_u_u_p_p_e_e X i j P Q c d.
  apply pack_u_u_p_p_e_e_inj X' X i' i j' j P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_u_u_p_p_e_e_E6: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_u_p_p_e_e (pack_u_u_p_p_e_e X i j P Q c d) -> d :e X.
let X i j P Q c d. assume H1. apply H1 (fun z => z = pack_u_u_p_p_e_e X i j P Q c d -> d :e X).
- let X'. let i'. assume Hi'. let j'. assume Hj'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_u_p_p_e_e X' i' j' P' Q' c' d' = pack_u_u_p_p_e_e X i j P Q c d.
  apply pack_u_u_p_p_e_e_inj X' X i' i j' j P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i Hj'j HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_u_u_p_p_e_e_eta: forall S, struct_u_u_p_p_e_e S -> S = pack_u_u_p_p_e_e (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_u_u_p_p_e_e (z 0) (decode_u (z 1)) (decode_u (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let i. assume _. let j. assume _. let P. let Q. let c. assume _. let d. assume _.
prove pack_u_u_p_p_e_e X i j P Q c d = pack_u_u_p_p_e_e (pack_u_u_p_p_e_e X i j P Q c d 0) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 1)) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 2)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 3)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 4)) (pack_u_u_p_p_e_e X i j P Q c d 5) (pack_u_u_p_p_e_e X i j P Q c d 6).
rewrite <- pack_u_u_p_p_e_e_0_eq2 X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_5_eq2 X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_6_eq2 X i j P Q c d.
apply pack_u_u_p_p_e_e_ext.
- exact pack_u_u_p_p_e_e_1_eq2 X i j P Q c d.
- exact pack_u_u_p_p_e_e_2_eq2 X i j P Q c d.
- let x. assume Hx.
  rewrite <- pack_u_u_p_p_e_e_3_eq2 X i j P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_u_p_p_e_e_4_eq2 X i j P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_p_p_e_e_i : set -> (set -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_u_u_p_p_e_e_i_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' j' P' Q' c d = Phi X i j P Q c d)
  ->
  unpack_u_u_p_p_e_e_i (pack_u_u_p_p_e_e X i j P Q c d) Phi = Phi X i j P Q c d.
let Phi X i j P Q c d.
assume HPhi.
prove Phi (pack_u_u_p_p_e_e X i j P Q c d 0) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 1)) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 2)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 3)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 4)) (pack_u_u_p_p_e_e X i j P Q c d 5) (pack_u_u_p_p_e_e X i j P Q c d 6) = Phi X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_0_eq2 X i j P Q c d.
prove Phi X (decode_u (pack_u_u_p_p_e_e X i j P Q c d 1)) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 2)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 3)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 4)) (pack_u_u_p_p_e_e X i j P Q c d 5) (pack_u_u_p_p_e_e X i j P Q c d 6) = Phi X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_5_eq2 X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_6_eq2 X i j P Q c d.
apply HPhi.
- exact pack_u_u_p_p_e_e_1_eq2 X i j P Q c d.
- exact pack_u_u_p_p_e_e_2_eq2 X i j P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_p_p_e_e X i j P Q c d 3) x.
  rewrite <- pack_u_u_p_p_e_e_3_eq2 X i j P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_u_p_p_e_e X i j P Q c d 4) x.
  rewrite <- pack_u_u_p_p_e_e_4_eq2 X i j P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_u_p_p_e_e_o : set -> (set -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_u_u_p_p_e_e_o_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall j':set -> set, (forall x :e X, j x = j' x) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' j' P' Q' c d = Phi X i j P Q c d)
  ->
  unpack_u_u_p_p_e_e_o (pack_u_u_p_p_e_e X i j P Q c d) Phi = Phi X i j P Q c d.
let Phi X i j P Q c d.
assume HPhi.
prove Phi (pack_u_u_p_p_e_e X i j P Q c d 0) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 1)) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 2)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 3)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 4)) (pack_u_u_p_p_e_e X i j P Q c d 5) (pack_u_u_p_p_e_e X i j P Q c d 6) = Phi X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_0_eq2 X i j P Q c d.
prove Phi X (decode_u (pack_u_u_p_p_e_e X i j P Q c d 1)) (decode_u (pack_u_u_p_p_e_e X i j P Q c d 2)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 3)) (decode_p (pack_u_u_p_p_e_e X i j P Q c d 4)) (pack_u_u_p_p_e_e X i j P Q c d 5) (pack_u_u_p_p_e_e X i j P Q c d 6) = Phi X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_5_eq2 X i j P Q c d.
rewrite <- pack_u_u_p_p_e_e_6_eq2 X i j P Q c d.
apply HPhi.
- exact pack_u_u_p_p_e_e_1_eq2 X i j P Q c d.
- exact pack_u_u_p_p_e_e_2_eq2 X i j P Q c d.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_u_p_p_e_e X i j P Q c d 3) x.
  rewrite <- pack_u_u_p_p_e_e_3_eq2 X i j P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_u_p_p_e_e X i j P Q c d 4) x.
  rewrite <- pack_u_u_p_p_e_e_4_eq2 X i j P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_u_r_p_p_e_e : set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X i R P Q c d => (X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d).

Theorem pack_u_r_p_p_e_e_0_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> X = S 0.
let S X i R P Q c d. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_u_r_p_p_e_e_0_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_u_r_p_p_e_e X i R P Q c d 0.
let X i R P Q c d. apply pack_u_r_p_p_e_e_0_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_1_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> forall x :e X, i x = decode_u (S 1) x.
let S X i R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 1) x.
rewrite tuple_7_1_eq.
symmetry. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_u_r_p_p_e_e_1_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, i x = decode_u (pack_u_r_p_p_e_e X i R P Q c d 1) x.
let X i R P Q c d. apply pack_u_r_p_p_e_e_1_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_2_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X i R P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_u_r_p_p_e_e_2_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_u_r_p_p_e_e X i R P Q c d 2) x y.
let X i R P Q c d. apply pack_u_r_p_p_e_e_2_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_3_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X i R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_u_r_p_p_e_e_3_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_u_r_p_p_e_e X i R P Q c d 3) x.
let X i R P Q c d. apply pack_u_r_p_p_e_e_3_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_4_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X i R P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_u_r_p_p_e_e_4_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_u_r_p_p_e_e X i R P Q c d 4) x.
let X i R P Q c d. apply pack_u_r_p_p_e_e_4_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_5_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> c = S 5.
let S X i R P Q c d. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_u_r_p_p_e_e_5_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_u_r_p_p_e_e X i R P Q c d 5.
let X i R P Q c d. apply pack_u_r_p_p_e_e_5_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_6_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_u_r_p_p_e_e X i R P Q c d -> d = S 6.
let S X i R P Q c d. assume H1.
rewrite H1. prove d = (X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_u_r_p_p_e_e_6_eq2: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_u_r_p_p_e_e X i R P Q c d 6.
let X i R P Q c d. apply pack_u_r_p_p_e_e_6_eq (pack_u_r_p_p_e_e X i R P Q c d) X i R P Q c d. reflexivity.
Qed.

Theorem pack_u_r_p_p_e_e_inj : forall X X', forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_u_r_p_p_e_e X i R P Q c d = pack_u_r_p_p_e_e X' i' R' P' Q' c' d' -> X = X' /\ (forall x :e X, i x = i' x) /\ (forall x y :e X, R x y = R' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' i i' R R' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_u_r_p_p_e_e X i R P Q c d 0.
{ exact pack_u_r_p_p_e_e_0_eq (pack_u_r_p_p_e_e X i R P Q c d) X' i' R' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_u_r_p_p_e_e_0_eq2 X i R P Q c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X.
  prove i x = i' x.
  rewrite pack_u_r_p_p_e_e_1_eq2 X i R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_r_p_p_e_e_1_eq2 X' i' R' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_u_r_p_p_e_e_2_eq2 X i R P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_u_r_p_p_e_e_2_eq2 X' i' R' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_u_r_p_p_e_e_3_eq2 X i R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_r_p_p_e_e_3_eq2 X' i' R' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_u_r_p_p_e_e_4_eq2 X i R P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_u_r_p_p_e_e_4_eq2 X' i' R' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_u_r_p_p_e_e_5_eq2 X i R P Q c d.
  rewrite H1. symmetry.
  exact pack_u_r_p_p_e_e_5_eq2 X' i' R' P' Q' c' d'.
- prove d = d'.
  rewrite pack_u_r_p_p_e_e_6_eq2 X i R P Q c d.
  rewrite H1. symmetry.
  exact pack_u_r_p_p_e_e_6_eq2 X' i' R' P' Q' c' d'.
Qed.

Theorem pack_u_r_p_p_e_e_ext : forall X, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_u_r_p_p_e_e X i R P Q c d = pack_u_r_p_p_e_e X i' R' P' Q' c d.
let X i i' R R' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_u X i,encode_r X R,encode_p X P,encode_p X Q,c,d) = (X,encode_u X i',encode_r X R',encode_p X P',encode_p X Q',c,d).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_u_r_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_u_r_p_p_e_e X i R P Q c d)) -> q S.

Theorem pack_struct_u_r_p_p_e_e_I: forall X, forall i:set -> set, (forall x :e X, i x :e X) -> forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_u_r_p_p_e_e (pack_u_r_p_p_e_e X i R P Q c d).
let X i. assume Hi. let R P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X i Hi R P Q c Hc d Hd.
Qed.

Theorem pack_struct_u_r_p_p_e_e_E1: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_r_p_p_e_e (pack_u_r_p_p_e_e X i R P Q c d) -> forall x :e X, i x :e X.
let X i R P Q c d. assume H1. apply H1 (fun z => z = pack_u_r_p_p_e_e X i R P Q c d -> forall x :e X, i x :e X).
- let X'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_r_p_p_e_e X' i' R' P' Q' c' d' = pack_u_r_p_p_e_e X i R P Q c d.
  apply pack_u_r_p_p_e_e_inj X' X i' i R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  let x. assume Hx.
  rewrite <- Hi'i x Hx.  exact Hi' x Hx.
- reflexivity.
Qed.

Theorem pack_struct_u_r_p_p_e_e_E5: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_r_p_p_e_e (pack_u_r_p_p_e_e X i R P Q c d) -> c :e X.
let X i R P Q c d. assume H1. apply H1 (fun z => z = pack_u_r_p_p_e_e X i R P Q c d -> c :e X).
- let X'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_r_p_p_e_e X' i' R' P' Q' c' d' = pack_u_r_p_p_e_e X i R P Q c d.
  apply pack_u_r_p_p_e_e_inj X' X i' i R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_u_r_p_p_e_e_E6: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_u_r_p_p_e_e (pack_u_r_p_p_e_e X i R P Q c d) -> d :e X.
let X i R P Q c d. assume H1. apply H1 (fun z => z = pack_u_r_p_p_e_e X i R P Q c d -> d :e X).
- let X'. let i'. assume Hi'. let R'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_u_r_p_p_e_e X' i' R' P' Q' c' d' = pack_u_r_p_p_e_e X i R P Q c d.
  apply pack_u_r_p_p_e_e_inj X' X i' i R' R P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X Hi'i HR'R HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_u_r_p_p_e_e_eta: forall S, struct_u_r_p_p_e_e S -> S = pack_u_r_p_p_e_e (S 0) (decode_u (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_u_r_p_p_e_e (z 0) (decode_u (z 1)) (decode_r (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let i. assume _. let R. let P. let Q. let c. assume _. let d. assume _.
prove pack_u_r_p_p_e_e X i R P Q c d = pack_u_r_p_p_e_e (pack_u_r_p_p_e_e X i R P Q c d 0) (decode_u (pack_u_r_p_p_e_e X i R P Q c d 1)) (decode_r (pack_u_r_p_p_e_e X i R P Q c d 2)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 3)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 4)) (pack_u_r_p_p_e_e X i R P Q c d 5) (pack_u_r_p_p_e_e X i R P Q c d 6).
rewrite <- pack_u_r_p_p_e_e_0_eq2 X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_5_eq2 X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_6_eq2 X i R P Q c d.
apply pack_u_r_p_p_e_e_ext.
- exact pack_u_r_p_p_e_e_1_eq2 X i R P Q c d.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_u_r_p_p_e_e_2_eq2 X i R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_r_p_p_e_e_3_eq2 X i R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_u_r_p_p_e_e_4_eq2 X i R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_r_p_p_e_e_i : set -> (set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_u_r_p_p_e_e_i_eq : forall Phi:set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' R' P' Q' c d = Phi X i R P Q c d)
  ->
  unpack_u_r_p_p_e_e_i (pack_u_r_p_p_e_e X i R P Q c d) Phi = Phi X i R P Q c d.
let Phi X i R P Q c d.
assume HPhi.
prove Phi (pack_u_r_p_p_e_e X i R P Q c d 0) (decode_u (pack_u_r_p_p_e_e X i R P Q c d 1)) (decode_r (pack_u_r_p_p_e_e X i R P Q c d 2)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 3)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 4)) (pack_u_r_p_p_e_e X i R P Q c d 5) (pack_u_r_p_p_e_e X i R P Q c d 6) = Phi X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_0_eq2 X i R P Q c d.
prove Phi X (decode_u (pack_u_r_p_p_e_e X i R P Q c d 1)) (decode_r (pack_u_r_p_p_e_e X i R P Q c d 2)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 3)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 4)) (pack_u_r_p_p_e_e X i R P Q c d 5) (pack_u_r_p_p_e_e X i R P Q c d 6) = Phi X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_5_eq2 X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_6_eq2 X i R P Q c d.
apply HPhi.
- exact pack_u_r_p_p_e_e_1_eq2 X i R P Q c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_r_p_p_e_e X i R P Q c d 2) x y.
  rewrite <- pack_u_r_p_p_e_e_2_eq2 X i R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_r_p_p_e_e X i R P Q c d 3) x.
  rewrite <- pack_u_r_p_p_e_e_3_eq2 X i R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_r_p_p_e_e X i R P Q c d 4) x.
  rewrite <- pack_u_r_p_p_e_e_4_eq2 X i R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_u_r_p_p_e_e_o : set -> (set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_u_r_p_p_e_e_o_eq : forall Phi:set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall i':set -> set, (forall x :e X, i x = i' x) ->  forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X i' R' P' Q' c d = Phi X i R P Q c d)
  ->
  unpack_u_r_p_p_e_e_o (pack_u_r_p_p_e_e X i R P Q c d) Phi = Phi X i R P Q c d.
let Phi X i R P Q c d.
assume HPhi.
prove Phi (pack_u_r_p_p_e_e X i R P Q c d 0) (decode_u (pack_u_r_p_p_e_e X i R P Q c d 1)) (decode_r (pack_u_r_p_p_e_e X i R P Q c d 2)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 3)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 4)) (pack_u_r_p_p_e_e X i R P Q c d 5) (pack_u_r_p_p_e_e X i R P Q c d 6) = Phi X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_0_eq2 X i R P Q c d.
prove Phi X (decode_u (pack_u_r_p_p_e_e X i R P Q c d 1)) (decode_r (pack_u_r_p_p_e_e X i R P Q c d 2)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 3)) (decode_p (pack_u_r_p_p_e_e X i R P Q c d 4)) (pack_u_r_p_p_e_e X i R P Q c d 5) (pack_u_r_p_p_e_e X i R P Q c d 6) = Phi X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_5_eq2 X i R P Q c d.
rewrite <- pack_u_r_p_p_e_e_6_eq2 X i R P Q c d.
apply HPhi.
- exact pack_u_r_p_p_e_e_1_eq2 X i R P Q c d.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_u_r_p_p_e_e X i R P Q c d 2) x y.
  rewrite <- pack_u_r_p_p_e_e_2_eq2 X i R P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_u_r_p_p_e_e X i R P Q c d 3) x.
  rewrite <- pack_u_r_p_p_e_e_3_eq2 X i R P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_u_r_p_p_e_e X i R P Q c d 4) x.
  rewrite <- pack_u_r_p_p_e_e_4_eq2 X i R P Q c d x Hx.
  apply iff_refl.
Qed.


Definition pack_r_r_p_p_e_e : set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set := fun X R T P Q c d => (X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d).

Theorem pack_r_r_p_p_e_e_0_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> X = S 0.
let S X R T P Q c d. assume H1. rewrite H1.
prove X = (X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 0.
symmetry. apply tuple_7_0_eq.
Qed.

Theorem pack_r_r_p_p_e_e_0_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, X = pack_r_r_p_p_e_e X R T P Q c d 0.
let X R T P Q c d. apply pack_r_r_p_p_e_e_0_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_1_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R T P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 1) x y.
rewrite tuple_7_1_eq.
symmetry. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_r_r_p_p_e_e_1_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, R x y = decode_r (pack_r_r_p_p_e_e X R T P Q c d 1) x y.
let X R T P Q c d. apply pack_r_r_p_p_e_e_1_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_2_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> forall x y :e X, T x y = decode_r (S 2) x y.
let S X R T P Q c d. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 2) x y.
rewrite tuple_7_2_eq.
symmetry. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_r_r_p_p_e_e_2_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x y :e X, T x y = decode_r (pack_r_r_p_p_e_e X R T P Q c d 2) x y.
let X R T P Q c d. apply pack_r_r_p_p_e_e_2_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_3_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> forall x :e X, P x = decode_p (S 3) x.
let S X R T P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 3) x.
rewrite tuple_7_3_eq.
symmetry. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_r_r_p_p_e_e_3_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, P x = decode_p (pack_r_r_p_p_e_e X R T P Q c d 3) x.
let X R T P Q c d. apply pack_r_r_p_p_e_e_3_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_4_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> forall x :e X, Q x = decode_p (S 4) x.
let S X R T P Q c d. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 4) x.
rewrite tuple_7_4_eq.
symmetry. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_r_r_p_p_e_e_4_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, forall x :e X, Q x = decode_p (pack_r_r_p_p_e_e X R T P Q c d 4) x.
let X R T P Q c d. apply pack_r_r_p_p_e_e_4_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_5_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> c = S 5.
let S X R T P Q c d. assume H1.
rewrite H1. prove c = (X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 5. symmetry. apply tuple_7_5_eq.
Qed.

Theorem pack_r_r_p_p_e_e_5_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, c = pack_r_r_p_p_e_e X R T P Q c d 5.
let X R T P Q c d. apply pack_r_r_p_p_e_e_5_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_6_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, S = pack_r_r_p_p_e_e X R T P Q c d -> d = S 6.
let S X R T P Q c d. assume H1.
rewrite H1. prove d = (X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) 6. symmetry. apply tuple_7_6_eq.
Qed.

Theorem pack_r_r_p_p_e_e_6_eq2: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, d = pack_r_r_p_p_e_e X R T P Q c d 6.
let X R T P Q c d. apply pack_r_r_p_p_e_e_6_eq (pack_r_r_p_p_e_e X R T P Q c d) X R T P Q c d. reflexivity.
Qed.

Theorem pack_r_r_p_p_e_e_inj : forall X X', forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c c':set, forall d d':set, pack_r_r_p_p_e_e X R T P Q c d = pack_r_r_p_p_e_e X' R' T' P' Q' c' d' -> X = X' /\ (forall x y :e X, R x y = R' x y) /\ (forall x y :e X, T x y = T' x y) /\ (forall x :e X, P x = P' x) /\ (forall x :e X, Q x = Q' x) /\ c = c' /\ d = d'.
let X X' R R' T T' P P' Q Q' c c' d d'. assume H1.
claim L0: X' = pack_r_r_p_p_e_e X R T P Q c d 0.
{ exact pack_r_r_p_p_e_e_0_eq (pack_r_r_p_p_e_e X R T P Q c d) X' R' T' P' Q' c' d' H1. }
claim L1: X = X'.
{ rewrite L0. exact pack_r_r_p_p_e_e_0_eq2 X R T P Q c d. }
apply and7I.
- exact L1.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove R x y = R' x y.
  rewrite pack_r_r_p_p_e_e_1_eq2 X R T P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_r_r_p_p_e_e_1_eq2 X' R' T' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X. let y. assume Hy: y :e X.
  prove T x y = T' x y.
  rewrite pack_r_r_p_p_e_e_2_eq2 X R T P Q c d x Hx y Hy.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  claim Ly: y :e X'.
  { rewrite <- L1. exact Hy. }
  rewrite H1. symmetry.
  exact pack_r_r_p_p_e_e_2_eq2 X' R' T' P' Q' c' d' x Lx y Ly.
- let x. assume Hx: x :e X.
  prove P x = P' x.
  rewrite pack_r_r_p_p_e_e_3_eq2 X R T P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_r_r_p_p_e_e_3_eq2 X' R' T' P' Q' c' d' x Lx.
- let x. assume Hx: x :e X.
  prove Q x = Q' x.
  rewrite pack_r_r_p_p_e_e_4_eq2 X R T P Q c d x Hx.
  claim Lx: x :e X'.
  { rewrite <- L1. exact Hx. }
  rewrite H1. symmetry.
  exact pack_r_r_p_p_e_e_4_eq2 X' R' T' P' Q' c' d' x Lx.
- prove c = c'.
  rewrite pack_r_r_p_p_e_e_5_eq2 X R T P Q c d.
  rewrite H1. symmetry.
  exact pack_r_r_p_p_e_e_5_eq2 X' R' T' P' Q' c' d'.
- prove d = d'.
  rewrite pack_r_r_p_p_e_e_6_eq2 X R T P Q c d.
  rewrite H1. symmetry.
  exact pack_r_r_p_p_e_e_6_eq2 X' R' T' P' Q' c' d'.
Qed.

Theorem pack_r_r_p_p_e_e_ext : forall X, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop, forall Q Q':set -> prop, forall c, forall d,
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_r_r_p_p_e_e X R T P Q c d = pack_r_r_p_p_e_e X R' T' P' Q' c d.
let X R R' T T' P P' Q Q' c d. assume H1. assume H2. assume H3. assume H4.
prove (X,encode_r X R,encode_r X T,encode_p X P,encode_p X Q,c,d) = (X,encode_r X R',encode_r X T',encode_p X P',encode_p X Q',c,d).
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
claim L4: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H4. }
rewrite <- L4.
reflexivity.
Qed.

Definition struct_r_r_p_p_e_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> q (pack_r_r_p_p_e_e X R T P Q c d)) -> q S.

Theorem pack_struct_r_r_p_p_e_e_I: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> forall d:set, d :e X -> struct_r_r_p_p_e_e (pack_r_r_p_p_e_e X R T P Q c d).
let X R T P Q c. assume Hc. let d. assume Hd. let q. assume Hq.
exact Hq X R T P Q c Hc d Hd.
Qed.

Theorem pack_struct_r_r_p_p_e_e_E5: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_r_r_p_p_e_e (pack_r_r_p_p_e_e X R T P Q c d) -> c :e X.
let X R T P Q c d. assume H1. apply H1 (fun z => z = pack_r_r_p_p_e_e X R T P Q c d -> c :e X).
- let X'. let R'. let T'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_r_r_p_p_e_e X' R' T' P' Q' c' d' = pack_r_r_p_p_e_e X R T P Q c d.
  apply pack_r_r_p_p_e_e_inj X' X R' R T' T P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HR'R HT'T HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hc'c.  exact Hc'.
- reflexivity.
Qed.

Theorem pack_struct_r_r_p_p_e_e_E6: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set, struct_r_r_p_p_e_e (pack_r_r_p_p_e_e X R T P Q c d) -> d :e X.
let X R T P Q c d. assume H1. apply H1 (fun z => z = pack_r_r_p_p_e_e X R T P Q c d -> d :e X).
- let X'. let R'. let T'. let P'. let Q'. let c'. assume Hc'. let d'. assume Hd'.
  assume Heq: pack_r_r_p_p_e_e X' R' T' P' Q' c' d' = pack_r_r_p_p_e_e X R T P Q c d.
  apply pack_r_r_p_p_e_e_inj X' X R' R T' T P' P Q' Q c' c d' d Heq.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume H. apply H.
  assume HX'X HR'R HT'T HP'P HQ'Q Hc'c Hd'd.
  rewrite <- HX'X.  rewrite <- Hd'd.  exact Hd'.
- reflexivity.
Qed.

Theorem struct_r_r_p_p_e_e_eta: forall S, struct_r_r_p_p_e_e S -> S = pack_r_r_p_p_e_e (S 0) (decode_r (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).
let S. assume H1. apply H1 (fun z => z = pack_r_r_p_p_e_e (z 0) (decode_r (z 1)) (decode_r (z 2)) (decode_p (z 3)) (decode_p (z 4)) (z 5) (z 6)).
let X. let R. let T. let P. let Q. let c. assume _. let d. assume _.
prove pack_r_r_p_p_e_e X R T P Q c d = pack_r_r_p_p_e_e (pack_r_r_p_p_e_e X R T P Q c d 0) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 1)) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 2)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 3)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 4)) (pack_r_r_p_p_e_e X R T P Q c d 5) (pack_r_r_p_p_e_e X R T P Q c d 6).
rewrite <- pack_r_r_p_p_e_e_0_eq2 X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_5_eq2 X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_6_eq2 X R T P Q c d.
apply pack_r_r_p_p_e_e_ext.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_r_r_p_p_e_e_1_eq2 X R T P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  rewrite <- pack_r_r_p_p_e_e_2_eq2 X R T P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_r_r_p_p_e_e_3_eq2 X R T P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  rewrite <- pack_r_r_p_p_e_e_4_eq2 X R T P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_r_r_p_p_e_e_i : set -> (set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set) -> set := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_r_r_p_p_e_e_i_eq : forall Phi:set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> set,
  forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X R' T' P' Q' c d = Phi X R T P Q c d)
  ->
  unpack_r_r_p_p_e_e_i (pack_r_r_p_p_e_e X R T P Q c d) Phi = Phi X R T P Q c d.
let Phi X R T P Q c d.
assume HPhi.
prove Phi (pack_r_r_p_p_e_e X R T P Q c d 0) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 1)) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 2)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 3)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 4)) (pack_r_r_p_p_e_e X R T P Q c d 5) (pack_r_r_p_p_e_e X R T P Q c d 6) = Phi X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_0_eq2 X R T P Q c d.
prove Phi X (decode_r (pack_r_r_p_p_e_e X R T P Q c d 1)) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 2)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 3)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 4)) (pack_r_r_p_p_e_e X R T P Q c d 5) (pack_r_r_p_p_e_e X R T P Q c d 6) = Phi X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_5_eq2 X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_6_eq2 X R T P Q c d.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_r_r_p_p_e_e X R T P Q c d 1) x y.
  rewrite <- pack_r_r_p_p_e_e_1_eq2 X R T P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_r_r_p_p_e_e X R T P Q c d 2) x y.
  rewrite <- pack_r_r_p_p_e_e_2_eq2 X R T P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_r_r_p_p_e_e X R T P Q c d 3) x.
  rewrite <- pack_r_r_p_p_e_e_3_eq2 X R T P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_r_r_p_p_e_e X R T P Q c d 4) x.
  rewrite <- pack_r_r_p_p_e_e_4_eq2 X R T P Q c d x Hx.
  apply iff_refl.
Qed.


Definition unpack_r_r_p_p_e_e_o : set -> (set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop) -> prop := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_r (S 2)) (decode_p (S 3)) (decode_p (S 4)) (S 5) (S 6).

Theorem unpack_r_r_p_p_e_e_o_eq : forall Phi:set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> (set -> prop) -> set -> set -> prop,
  forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, forall Q:set -> prop, forall c:set, forall d:set,
  ( forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X R' T' P' Q' c d = Phi X R T P Q c d)
  ->
  unpack_r_r_p_p_e_e_o (pack_r_r_p_p_e_e X R T P Q c d) Phi = Phi X R T P Q c d.
let Phi X R T P Q c d.
assume HPhi.
prove Phi (pack_r_r_p_p_e_e X R T P Q c d 0) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 1)) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 2)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 3)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 4)) (pack_r_r_p_p_e_e X R T P Q c d 5) (pack_r_r_p_p_e_e X R T P Q c d 6) = Phi X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_0_eq2 X R T P Q c d.
prove Phi X (decode_r (pack_r_r_p_p_e_e X R T P Q c d 1)) (decode_r (pack_r_r_p_p_e_e X R T P Q c d 2)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 3)) (decode_p (pack_r_r_p_p_e_e X R T P Q c d 4)) (pack_r_r_p_p_e_e X R T P Q c d 5) (pack_r_r_p_p_e_e X R T P Q c d 6) = Phi X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_5_eq2 X R T P Q c d.
rewrite <- pack_r_r_p_p_e_e_6_eq2 X R T P Q c d.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove R x y <-> decode_r (pack_r_r_p_p_e_e X R T P Q c d 1) x y.
  rewrite <- pack_r_r_p_p_e_e_1_eq2 X R T P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove T x y <-> decode_r (pack_r_r_p_p_e_e X R T P Q c d 2) x y.
  rewrite <- pack_r_r_p_p_e_e_2_eq2 X R T P Q c d x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove P x <-> decode_p (pack_r_r_p_p_e_e X R T P Q c d 3) x.
  rewrite <- pack_r_r_p_p_e_e_3_eq2 X R T P Q c d x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove Q x <-> decode_p (pack_r_r_p_p_e_e X R T P Q c d 4) x.
  rewrite <- pack_r_r_p_p_e_e_4_eq2 X R T P Q c d x Hx.
  apply iff_refl.
Qed.

